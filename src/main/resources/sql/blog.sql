/*
 Navicat Premium Data Transfer

 Source Server         : local-docker-mysql
 Source Server Type    : MySQL
 Source Server Version : 80019
 Source Host           : 192.168.31.202:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80019
 File Encoding         : 65001

 Date: 01/12/2020 22:13:01
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog_article
-- ----------------------------
DROP TABLE IF EXISTS `blog_article`;
CREATE TABLE `blog_article`  (
  `id` int(0) NOT NULL DEFAULT 0,
  `article_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `article_digest` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '摘要',
  `article_content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `article_html_content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `article_image` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `article_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `categories_id` int(0) DEFAULT NULL,
  `create_date` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `update_date` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `likes` int(0) DEFAULT 0,
  `last_article_id` int(0) DEFAULT NULL,
  `next_article_id` int(0) DEFAULT NULL,
  `top` tinyint(0) DEFAULT NULL COMMENT '是否置顶',
  `draft` tinyint(0) DEFAULT 0 COMMENT '草稿',
  `privacy` tinyint(0) DEFAULT 0 COMMENT '是否私密文章',
  `user_id` int(0) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKiclpweghphhdyo4g09ljuiaki`(`last_article_id`) USING BTREE,
  INDEX `FKm33seyrrr5c7y0ikroymbsa0i`(`next_article_id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_article
-- ----------------------------
INSERT INTO `blog_article` VALUES (121, 'kaptcha谷歌验证码工具', 'Kaptcha 简介 Kaptcha 是一个可高度配置的实用验证码生成工具，可自由配置的选项如： 验证码的字体 验证码字体的大小 验证码字体的字体颜色 验证码内容的范围(数字，字母，中文汉字！) 验证码图片的大小，边框，边框粗细，边框颜色 验证码的干扰线 验证码的样式(鱼眼样式、3D、普通模糊、…) Kaptcha 详细配置表 属性 含义 默认值 kaptcha.border 图片边框，合法值：yes , no yes kaptcha.border.color 边框颜色，合法值：', '## Kaptcha 简介\nKaptcha 是一个可高度配置的实用验证码生成工具，可自由配置的选项如：\n\n+ 验证码的字体\n+ 验证码字体的大小\n+ 验证码字体的字体颜色\n+ 验证码内容的范围(数字，字母，中文汉字！)\n+ 验证码图片的大小，边框，边框粗细，边框颜色\n+ 验证码的干扰线\n+ 验证码的样式(鱼眼样式、3D、普通模糊、...)\n\n## Kaptcha 详细配置表\n\n|  属性 | 含义  |默认值   |\n| ------------ | ------------ | ------------ |\n|kaptcha.border|图片边框，合法值：yes , no|yes|\n|kaptcha.border.color|边框颜色，合法值： r,g,b (and optional alpha) 或者 white,black,blue.|black|\n|kaptcha.image.width|图片宽|200|\n|kaptcha.image.height|图片高|50|\n|kaptcha.producer.impl|图片实现类|com.google.code.kaptcha.impl.DefaultKaptcha||\n|kaptcha.textproducer.impl|文本实现类|com.google.code.kaptcha.text.impl.DefaultTextCreator|\n|kaptcha.textproducer.char.string|文本集合，验证码值从此集合中获取|abcde2345678gfynmnpwx|\n|kaptcha.textproducer.char.length|验证码长度|5|\n|kaptcha.textproducer.font.names|字体|Arial, Courier|\n|kaptcha.textproducer.font.size|字体大小|40px.|\n|kaptcha.textproducer.font.color|字体颜色，合法值： r,g,b 或者 white,black,blue.|black|\n|kaptcha.textproducer.char.space|文字间隔|2|\n|kaptcha.noise.impl|干扰实现类|com.google.code.kaptcha.impl.DefaultNoise|\n|kaptcha.noise.color|干扰 颜色，合法值： r,g,b 或者 white,black,blue.|black|\n|kaptcha.obscurificator.impl|图片样式：水 纹 com.google.code.kaptcha.impl.WaterRipple 鱼 眼 com.google.code.kaptcha.impl.FishEyeGimpy 阴 影 com.google.code.kaptcha.impl.ShadowGimpy | com.google.code.kaptcha.impl.WaterRipple|\n|kaptcha.background.impl|背景实现类|com.google.code.kaptcha.impl.DefaultBackground|\n|kaptcha.background.clear.from|背景颜色渐变，开始颜色|light grey|\n|kaptcha.background.clear.to|背景颜色渐变， 结束颜色|white|\n|kaptcha.word.impl|文字渲染器|com.google.code.kaptcha.text.impl.DefaultWordRenderer|\n|kaptcha.session.key|session key|KAPTCHA_SESSION_KEY|\n|kaptcha.session.date|session date|KAPTCHA_SESSION_DATE|\n## 在Spring中使用\n\n### 引入kaptcha\n1.可以去官网[下载jar包](http://code.google.com/p/kaptcha/ \"下载jar包\")\n2.在pom.xml中导入\n\n```xml\n<dependency>\n    <groupId>com.github.penggle</groupId>\n    <artifactId>kaptcha</artifactId>\n    <version>2.3.2</version>\n</dependency>\n```\n### 配置类KaptchaConfig\n```java\n@Component\npublic class KaptchaConfig {\n    @Bean\n    public DefaultKaptcha getDDefaultKaptcha() {\n        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n        Properties properties = new Properties();\n        properties.setProperty(\"kaptcha.border\", \"yes\");\n        properties.setProperty(\"kaptcha.border.color\", \"105,179,90\");\n        properties.setProperty(\"kaptcha.textproducer.font.color\", \"red\");\n        properties.setProperty(\"kaptcha.image.width\", \"110\");\n        properties.setProperty(\"kaptcha.image.height\", \"38\");\n        properties.setProperty(\"kaptcha.textproducer.font.size\", \"30\");\n        properties.setProperty(\"kaptcha.session.key\", \"code\");\n        properties.setProperty(\"kaptcha.textproducer.char.length\", \"4\");\n        properties.setProperty(\"kaptcha.textproducer.font.names\", \"宋体,楷体,微软雅黑\");\n        Config config = new Config(properties);\n        defaultKaptcha.setConfig(config)\n        return defaultKaptcha;\n    }\n}\n```\n### Controller\n```java\n@Controller\n@RequestMapping(\"/admin\")\npublic class KaptchaController {\n    \n    @Autowired\n    DefaultKaptcha defaultKaptcha;\n	/**\n	 * 获取验证码\n	 */\n    @RequestMapping(\"/defaultKaptcha\")\n    public void defaultKaptcha(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        byte[] captcha = null;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        try {\n            // 将生成的验证码保存在session中\n            String createText = defaultKaptcha.createText();\n            request.getSession().setAttribute(\"rightCode\", createText);\n            BufferedImage bi = defaultKaptcha.createImage(createText);\n            ImageIO.write(bi, \"jpg\", out);\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        captcha = out.toByteArray();\n        response.setHeader(\"Cache-Control\", \"no-store\");\n        response.setHeader(\"Pragma\", \"no-cache\");\n        response.setDateHeader(\"Expires\", 0);\n        response.setContentType(\"image/jpeg\");\n        ServletOutputStream sout = response.getOutputStream();\n        sout.write(captcha);\n        sout.flush();\n        sout.close();\n    }\n}\n\n```\n\n### 前台页面\n```html\n<div class=\"layui-col-xs4 layui-col-sm4 layui-col-md4\">\n	<img alt=\"验证码\" onclick=\"this.src=\'/admin/defaultKaptcha?d=\' + new Date()*1\" \n		src=\"/admin/defaultKaptcha\" />\n</div>\n```\n效果图如下\n![登录验证码效果图](https://img-blog.csdnimg.cn/20200919121911425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n### 验证\n```java\n@RequestMapping(\"/checkCode\")\n@ResponseBody\npublic boolean imgvrifyControllerDefaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){\n	String verCode = (String) httpServletRequest.getSession().getAttribute(\"verCode\");\n	String rightCode = httpServletRequest.getParameter(\"rightCode\");\n\n	if (!verCode.equals(rightCode)) {\n		return false;\n	} else {\n		return true;\n	}\n}\n```', '<h2 id=\"h2-kaptcha-\"><a name=\"Kaptcha 简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Kaptcha 简介</h2><p>Kaptcha 是一个可高度配置的实用验证码生成工具，可自由配置的选项如：</p>\n<ul>\n<li>验证码的字体</li><li>验证码字体的大小</li><li>验证码字体的字体颜色</li><li>验证码内容的范围(数字，字母，中文汉字！)</li><li>验证码图片的大小，边框，边框粗细，边框颜色</li><li>验证码的干扰线</li><li>验证码的样式(鱼眼样式、3D、普通模糊、…)</li></ul>\n<h2 id=\"h2-kaptcha-\"><a name=\"Kaptcha 详细配置表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Kaptcha 详细配置表</h2><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>kaptcha.border</td>\n<td>图片边框，合法值：yes , no</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>kaptcha.border.color</td>\n<td>边框颜色，合法值： r,g,b (and optional alpha) 或者 white,black,blue.</td>\n<td>black</td>\n</tr>\n<tr>\n<td>kaptcha.image.width</td>\n<td>图片宽</td>\n<td>200</td>\n</tr>\n<tr>\n<td>kaptcha.image.height</td>\n<td>图片高</td>\n<td>50</td>\n</tr>\n<tr>\n<td>kaptcha.producer.impl</td>\n<td>图片实现类</td>\n<td>com.google.code.kaptcha.impl.DefaultKaptcha</td>\n<td></td>\n</tr>\n<tr>\n<td>kaptcha.textproducer.impl</td>\n<td>文本实现类</td>\n<td>com.google.code.kaptcha.text.impl.DefaultTextCreator</td>\n</tr>\n<tr>\n<td>kaptcha.textproducer.char.string</td>\n<td>文本集合，验证码值从此集合中获取</td>\n<td>abcde2345678gfynmnpwx</td>\n</tr>\n<tr>\n<td>kaptcha.textproducer.char.length</td>\n<td>验证码长度</td>\n<td>5</td>\n</tr>\n<tr>\n<td>kaptcha.textproducer.font.names</td>\n<td>字体</td>\n<td>Arial, Courier</td>\n</tr>\n<tr>\n<td>kaptcha.textproducer.font.size</td>\n<td>字体大小</td>\n<td>40px.</td>\n</tr>\n<tr>\n<td>kaptcha.textproducer.font.color</td>\n<td>字体颜色，合法值： r,g,b 或者 white,black,blue.</td>\n<td>black</td>\n</tr>\n<tr>\n<td>kaptcha.textproducer.char.space</td>\n<td>文字间隔</td>\n<td>2</td>\n</tr>\n<tr>\n<td>kaptcha.noise.impl</td>\n<td>干扰实现类</td>\n<td>com.google.code.kaptcha.impl.DefaultNoise</td>\n</tr>\n<tr>\n<td>kaptcha.noise.color</td>\n<td>干扰 颜色，合法值： r,g,b 或者 white,black,blue.</td>\n<td>black</td>\n</tr>\n<tr>\n<td>kaptcha.obscurificator.impl</td>\n<td>图片样式：水 纹 com.google.code.kaptcha.impl.WaterRipple 鱼 眼 com.google.code.kaptcha.impl.FishEyeGimpy 阴 影 com.google.code.kaptcha.impl.ShadowGimpy</td>\n<td>com.google.code.kaptcha.impl.WaterRipple</td>\n</tr>\n<tr>\n<td>kaptcha.background.impl</td>\n<td>背景实现类</td>\n<td>com.google.code.kaptcha.impl.DefaultBackground</td>\n</tr>\n<tr>\n<td>kaptcha.background.clear.from</td>\n<td>背景颜色渐变，开始颜色</td>\n<td>light grey</td>\n</tr>\n<tr>\n<td>kaptcha.background.clear.to</td>\n<td>背景颜色渐变， 结束颜色</td>\n<td>white</td>\n</tr>\n<tr>\n<td>kaptcha.word.impl</td>\n<td>文字渲染器</td>\n<td>com.google.code.kaptcha.text.impl.DefaultWordRenderer</td>\n</tr>\n<tr>\n<td>kaptcha.session.key</td>\n<td>session key</td>\n<td>KAPTCHA_SESSION_KEY</td>\n</tr>\n<tr>\n<td>kaptcha.session.date</td>\n<td>session date</td>\n<td>KAPTCHA_SESSION_DATE</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2--spring-\"><a name=\"在Spring中使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>在Spring中使用</h2><h3 id=\"h3--kaptcha\"><a name=\"引入kaptcha\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>引入kaptcha</h3><p>1.可以去官网<a href=\"http://code.google.com/p/kaptcha/\" title=\"下载jar包\">下载jar包</a><br>2.在pom.xml中导入</p>\n<pre><code class=\"lang-xml\">&lt;dependency&gt;\n    &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;\n    &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;\n    &lt;version&gt;2.3.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<h3 id=\"h3--kaptchaconfig\"><a name=\"配置类KaptchaConfig\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置类KaptchaConfig</h3><pre><code class=\"lang-java\">@Component\npublic class KaptchaConfig {\n    @Bean\n    public DefaultKaptcha getDDefaultKaptcha() {\n        DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n        Properties properties = new Properties();\n        properties.setProperty(&quot;kaptcha.border&quot;, &quot;yes&quot;);\n        properties.setProperty(&quot;kaptcha.border.color&quot;, &quot;105,179,90&quot;);\n        properties.setProperty(&quot;kaptcha.textproducer.font.color&quot;, &quot;red&quot;);\n        properties.setProperty(&quot;kaptcha.image.width&quot;, &quot;110&quot;);\n        properties.setProperty(&quot;kaptcha.image.height&quot;, &quot;38&quot;);\n        properties.setProperty(&quot;kaptcha.textproducer.font.size&quot;, &quot;30&quot;);\n        properties.setProperty(&quot;kaptcha.session.key&quot;, &quot;code&quot;);\n        properties.setProperty(&quot;kaptcha.textproducer.char.length&quot;, &quot;4&quot;);\n        properties.setProperty(&quot;kaptcha.textproducer.font.names&quot;, &quot;宋体,楷体,微软雅黑&quot;);\n        Config config = new Config(properties);\n        defaultKaptcha.setConfig(config)\n        return defaultKaptcha;\n    }\n}\n</code></pre>\n<h3 id=\"h3-controller\"><a name=\"Controller\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Controller</h3><pre><code class=\"lang-java\">@Controller\n@RequestMapping(&quot;/admin&quot;)\npublic class KaptchaController {\n\n    @Autowired\n    DefaultKaptcha defaultKaptcha;\n    /**\n     * 获取验证码\n     */\n    @RequestMapping(&quot;/defaultKaptcha&quot;)\n    public void defaultKaptcha(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        byte[] captcha = null;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        try {\n            // 将生成的验证码保存在session中\n            String createText = defaultKaptcha.createText();\n            request.getSession().setAttribute(&quot;rightCode&quot;, createText);\n            BufferedImage bi = defaultKaptcha.createImage(createText);\n            ImageIO.write(bi, &quot;jpg&quot;, out);\n        } catch (Exception e) {\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\n            return;\n        }\n        captcha = out.toByteArray();\n        response.setHeader(&quot;Cache-Control&quot;, &quot;no-store&quot;);\n        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);\n        response.setDateHeader(&quot;Expires&quot;, 0);\n        response.setContentType(&quot;image/jpeg&quot;);\n        ServletOutputStream sout = response.getOutputStream();\n        sout.write(captcha);\n        sout.flush();\n        sout.close();\n    }\n}\n</code></pre>\n<h3 id=\"h3-u524Du53F0u9875u9762\"><a name=\"前台页面\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前台页面</h3><pre><code class=\"lang-html\">&lt;div class=&quot;layui-col-xs4 layui-col-sm4 layui-col-md4&quot;&gt;\n    &lt;img alt=&quot;验证码&quot; onclick=&quot;this.src=&#39;/admin/defaultKaptcha?d=&#39; + new Date()*1&quot; \n        src=&quot;/admin/defaultKaptcha&quot; /&gt;\n&lt;/div&gt;\n</code></pre>\n<p>效果图如下<br><img src=\"https://img-blog.csdnimg.cn/20200919121911425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"登录验证码效果图\"></p>\n<h3 id=\"h3-u9A8Cu8BC1\"><a name=\"验证\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>验证</h3><pre><code class=\"lang-java\">@RequestMapping(&quot;/checkCode&quot;)\n@ResponseBody\npublic boolean imgvrifyControllerDefaultKaptcha(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse){\n    String verCode = (String) httpServletRequest.getSession().getAttribute(&quot;verCode&quot;);\n    String rightCode = httpServletRequest.getParameter(&quot;rightCode&quot;);\n\n    if (!verCode.equals(rightCode)) {\n        return false;\n    } else {\n        return true;\n    }\n}\n</code></pre>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/11.jpg', '/article/121', 47, '2020-09-19', NULL, 0, 117, 124, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (124, 'SpringBoot 在IDEA中实现热部署', '在POM文件添加热部署插件&lt,开启IDEA的自动编译（静态）具体步骤,在项目添加热部署插件（可选）具体步骤', '## 开启IDEA的自动编译（静态）\n具体步骤：打开顶部工具栏 File -> Settings（快捷键Ctrl+Alt+s）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191230143112159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n## 开启IDEA的自动编译（动态）\n具体步骤：同时按住 Ctrl + Shift + Alt + / 然后进入Registry ，勾选自动编译并调整延时参数。\n\ncompiler.automake.allow.when.app.running -> 自动编译\ncompile.document.save.trigger.delay -> 自动更新文件\nPS：网上极少有人提到compile.document.save.trigger.delay 它主要是针对静态文件如JS CSS的更新，将延迟时间减少后，直接按F5刷新页面就能看到效果！\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191230143456473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n## 开启IDEA的热部署策略（非常重要）\n具体步骤：顶部菜单- >Edit Configurations->SpringBoot插件->目标项目->勾选热更新。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200121213017976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191230143550288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n## 在项目添加热部署插件（可选）\n\n\n具体步骤：在POM文件添加热部署插件\n```\n<dependency>\n	<groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <scope>runtime</scope>\n</dependency>\n```\n       \n## 关闭浏览器缓存（重要）\n打开谷歌浏览器，打开F12的Network选项栏，然后勾选【✅】Disable cache 。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019123014375857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n\n', '<h2 id=\"h2--idea-\"><a name=\"开启IDEA的自动编译（静态）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开启IDEA的自动编译（静态）</h2><p>具体步骤：打开顶部工具栏 File -&gt; Settings（快捷键Ctrl+Alt+s）<br><img src=\"https://img-blog.csdnimg.cn/20191230143112159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2--idea-\"><a name=\"开启IDEA的自动编译（动态）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开启IDEA的自动编译（动态）</h2><p>具体步骤：同时按住 Ctrl + Shift + Alt + / 然后进入Registry ，勾选自动编译并调整延时参数。</p>\n<p>compiler.automake.allow.when.app.running -&gt; 自动编译<br>compile.document.save.trigger.delay -&gt; 自动更新文件<br>PS：网上极少有人提到compile.document.save.trigger.delay 它主要是针对静态文件如JS CSS的更新，将延迟时间减少后，直接按F5刷新页面就能看到效果！<br><img src=\"https://img-blog.csdnimg.cn/20191230143456473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2--idea-\"><a name=\"开启IDEA的热部署策略（非常重要）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>开启IDEA的热部署策略（非常重要）</h2><p>具体步骤：顶部菜单- &gt;Edit Configurations-&gt;SpringBoot插件-&gt;目标项目-&gt;勾选热更新。<br><img src=\"https://img-blog.csdnimg.cn/20200121213017976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20191230143550288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2--\"><a name=\"在项目添加热部署插件（可选）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>在项目添加热部署插件（可选）</h2><p>具体步骤：在POM文件添加热部署插件</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"h2--\"><a name=\"关闭浏览器缓存（重要）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关闭浏览器缓存（重要）</h2><p>打开谷歌浏览器，打开F12的Network选项栏，然后勾选【✅】Disable cache 。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019123014375857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/16.jpg', '/article/124', 45, '2020-09-19', NULL, 0, 121, 126, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (126, 'SpringBoot入门到精通：（三）配置文件', '可以在配置文件中使用spring.profiles.active=xxx指定使用哪个配置文件比如我们想使用application-dev.yml这个配置文件就可以在主配置文件中配置spring,我们就可以在配置类中使用@PropertySource注解来指定加载user.properties配置文件@PropertySource(value={&quot,比如配置文件中user-name使用@ConfigurationProperties可以给userName属性注入值', '![](https://img-blog.csdnimg.cn/20191013195748147.png)\n## 前言\nSpring Boot使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。但是如果有些配置不符合我们的要求怎么办呢，这就需要了解Spring Boot的配置文件了。\n\n## 正文\n### 默认配置文件\nSpringBoot使用一个全局的配置文件，配置文件支持properties和yml两种类型的配置，配置文件名是固定的`application.properties/application.yml`，Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。\n\n### 配置文件的优先级\nspringboot 启动会扫描以下位置的`application.properties/application.yml`文件作为Spring boot的默认配置文件\n\n+ –file:./config/           （项目的config文件夹下 ）\n\n+ –file:./                     （直接放到项目路径下）\n\n- –classpath:/config/  （类路径下的config文件夹下）\n\n- –classpath:/            （直接放到类路径下）\n\n优先级由高到底，高优先级的配置会覆盖低优先级的配置；\n\nSpringBoot会从这四个位置全部加载主配置文件；**互补配置**；\n\n### 配置文件占位符\n\n#### 1、随机数\n配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。\n```ymal\nrandomtest:\n  value: ${random.value}\n  int: ${random.int}\n  intarr: ${random.int(10)}\n  long: ${random.long}\n  longstr: ${random.long(10)}\n  uuid: ${random.uuid}\n```\n#### 2、占位符获取之前配置的值，如果没有可以s使用指定默认值\n```ymal\nuser: \n	user-name: 张三${random.uuid}\n	age: ${random.int}\n	birth: 2017/12/15	\n	dog: \n		name=${user.hello:hello}_dog  //如果有user.hello，使用前面配置的user.hello的值，没有则使用默认值hello\n		age=15\n```\n\n### 使用自定义配置文件\n有时候我们不希望把所有配置都放在application.properties里面，那么我们就可以使用`@PropertySource`注解来加载指定的配置文件\n我们可以自定义一个配置文件，比如`user.properties`,路径跟也放在src/main/resources下面。\n我们就可以在配置类中使用`@PropertySource`注解来指定加载`user.properties`配置文件\n\n```java\n@PropertySource(value = {\"classpath:user.properties\"})\n@ConfigurationProperties(prefix = \"user\")\n@Component\n@Data\npublic class User {\n\n    private String userName;\n    private int age;\n    private Date birthday;\n\n}\n```\n==注：`@PropertySource`注解不支持yml配置文件==\n\n### 外部配置-命令行参数配置\nSpring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行：\n\n```\njava -jar xx.jar\n```\n可以以下命令修改tomcat端口号：\n```\njava -jar xx.jar --server.port=8081\n```\n\n可以看出，命令行中连续的两个减号--就是对application.properties中的属性值进行赋值的标识。\n所以java -jar xx.jar --server.port=8081等价于在配置文件中添加属性server.port=8081。\n如果你怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。\n\n实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种：\n\n\n1. 命令行参数，所有的配置都可以在命令行上进行指定,多个配置用空格分开； --配置项=值\n\n\n	```\n	java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc\n	```\n\n\n\n\n2. 来自java:comp/env的JNDI属性\n\n3. Java系统属性（System.getProperties()）\n\n4. 操作系统环境变量\n\n5. RandomValuePropertySource配置的random.*属性值\n\n	==**由jar包外向jar包内进行寻找；**==\n\n	==**优先加载带profile**==\n\n6. jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件\n\n7. jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件**\n\n\n\n	==**再来加载不带profile**==\n\n8. jar包外部的application.properties或application.yml(不带spring.profile)配置文件\n\n9. jar包内部的application.properties或application.yml(不带spring.profile)配置文件\n\n10. @Configuration注解类上的@PropertySource\n\n11. 通过SpringApplication.setDefaultProperties指定的默认属性\n\n所有支持的配置加载来源；[参考官方文档](https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-external-config)\n### 配置文件值获取\nSpringBoot有两种方式获取配置文件的值\n\n#### 使用@Value注解 \n配置文件中提供自定义属性的支持，这样我们就可以把一些常量配置在这里：\n```yaml\nuser:\n  user-name: 张三\n  age: 18\n  birthday: 2000/01/01\n```\n然后直接在要使用的地方通过注解`@Value(value=”${config.name}”)`就可以绑定到你想要的属性上面\n```java\n@Component\n@Data\npublic class User{\n\n    @Value(\"${user.user-name}\")\n    private String userName;\n    @Value(\"${user.age}\")\n    private int age;\n    @Value(\"${user.birthday}\")\n    private Date birthday;\n\n}\n```\n\n测试运行，输出获取到的user\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootApplicationTests {\n    @Autowired\n    User user;\n    @Test\n    public void contextLoads() {\n        System.out.println(user);\n    }\n}\n```\n输出结果如下\n> User(userName=张三, age=18, birthday=Sat Jan 01 00:00:00 CST 2000)\n\n#### 使用@ConfigurationProperties注解\n有时候属性太多了，一个个绑定到属性字段上太累，我们可以使用`@ConfigurationProperties` 注解\n该注解的含义是将配置文件中配置的每一个属性的值，映射到这个组件中，其属性prefix = \"xxx\"指定配置文件中哪个下面的所有属性进行一一映射\n注：只有这个组件是容器中的组件，才能容器提供的`@ConfigurationProperties`功能；所以类上必须有`@Component`注解\n这样我们就不必在每个属性上都配置`@Value`注解，只需要在类上配置`@ConfigurationProperties(prefix = \"user\")`\nSpringBoot就会自动将每个属性都映射上配置文件中对应的值\n```java\n@Component\n@ConfigurationProperties(prefix = \"user\")\n@Data\npublic class User{\n\n    private String userName;\n\n    private int age;\n\n    private Date birthday;\n\n}\n```\n\n\n测试运行，输出获取到的user\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootApplicationTests {\n    @Autowired\n    User user;\n    @Test\n    public void contextLoads() {\n        System.out.println(user);\n    }\n}\n```\n输出结果如下\n> User(userName=张三, age=18, birthday=Sat Jan 01 00:00:00 CST 2000)\n\n#### @Value和@ConfigurationProperties注解的区别\n|            | @ConfigurationProperties | @Value |\n| ---------- | ------------------------ | ------ |\n| 批量配置         | 支持            | 不支持  |\n| 松散绑定（松散语法） | 支持                       | 不支持    |\n| SpEL       | 不支持                      | 支持     |\n| JSR303数据校验 | 支持                       | 不支持    |\n| 复杂类型封装     | 支持                       | 不支持    |\n\n1. 批量配置：如上面实例中所示，`@ConfigurationProperties`可以批量注入配置文件中的属性，`@Value`只能一个一个注入\n2. 松散语法：`@ConfigurationProperties`支持松散语法，比如配置文件中user-name使用`@ConfigurationProperties`可以给userName属性注入值，但是`@Value(\"${user.userName}\")`不能将配置文件中的user-name属性赋值给userName\n3. SpEL语言：`@value`支持SpEL语言，比如:\n	```java\n	@Value(\"#{11*2}\")\n	private int age;\n	```\n	但是如果在配置文件中age=#{11*2},`@ConfigurationProperties`并不能将计算后的值注入给age属性\n4. JSR303数据校验：使用`@ConfigurationProperties`可以使用数据校验，比如：\n	```java\n	@Email\n	private String email;\n	```\n5. `@ConfigurationProperties`支持复杂性封装，比如\n	```yaml\n	user:\n	  user-name: 张三\n	  age: 18\n	  birthday: 2000/01/01\n	  map: {1:v1,k2:v2}\n	```\n	```java\n	@Component\n	@ConfigurationProperties(prefix = \"user\")\n	@Data\n	public class User{\n	\n	    private String userName;\n	\n	    private int age;\n	\n	    private Map map;\n	\n	}\n	```\n	`@ConfigurationProperties`可以直接将配置文件中的map赋值给map属性\n\n### Profile-多环境配置\n当应用程序需要部署到不同运行环境时，配置通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。如果每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了两种解决方案，命令带上参数就搞定。\n\n#### 1、多Profile文件\n\n我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml\n默认使用`application.properties`的配置，可以在配置文件中使用` spring.profiles.active= xxx`指定使用哪个配置文件\n比如我们想使用`application-dev.yml `这个配置文件就可以在主配置文件中配置\n```yml\nspring:\n  profiles:\n    active: dev\n```\n#### 2、yml支持多文档块方式\nyml可以使用`---`来分割代码块，可以指定使用哪个代码块\n```yml\nserver:\n  port: 8081\nspring:\n  profiles:\n    active: prod\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev\n\n---\nserver:\n  port: 8084\nspring:\n  profiles: prod  #指定属于哪个环境\n```\n\n也可以使用外部参数激活使用哪个配置文件\n```java\njava -jar spring-boot.jar --spring.profiles.active=dev；\n```\n或者使用虚拟机参数\n```\n-Dspring.profiles.active=dev\n```\n', '<p><img src=\"https://img-blog.csdnimg.cn/20191013195748147.png\" alt=\"\"></p>\n<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>Spring Boot使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速运行起来。但是如果有些配置不符合我们的要求怎么办呢，这就需要了解Spring Boot的配置文件了。</p>\n<h2 id=\"h2-u6B63u6587\"><a name=\"正文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>正文</h2><h3 id=\"h3-u9ED8u8BA4u914Du7F6Eu6587u4EF6\"><a name=\"默认配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>默认配置文件</h3><p>SpringBoot使用一个全局的配置文件，配置文件支持properties和yml两种类型的配置，配置文件名是固定的<code>application.properties/application.yml</code>，Sping Boot的全局配置文件的作用是对一些默认配置的配置值进行修改。</p>\n<h3 id=\"h3-u914Du7F6Eu6587u4EF6u7684u4F18u5148u7EA7\"><a name=\"配置文件的优先级\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置文件的优先级</h3><p>springboot 启动会扫描以下位置的<code>application.properties/application.yml</code>文件作为Spring boot的默认配置文件</p>\n<ul>\n<li><p>–file:./config/           （项目的config文件夹下 ）</p>\n</li><li><p>–file:./                     （直接放到项目路径下）</p>\n</li></ul>\n<ul>\n<li><p>–classpath:/config/  （类路径下的config文件夹下）</p>\n</li><li><p>–classpath:/            （直接放到类路径下）</p>\n</li></ul>\n<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>\n<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>\n<h3 id=\"h3-u914Du7F6Eu6587u4EF6u5360u4F4Du7B26\"><a name=\"配置文件占位符\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置文件占位符</h3><h4 id=\"h4-1-\"><a name=\"1、随机数\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、随机数</h4><p>配置文件中${random} 可以用来生成各种不同类型的随机值，从而简化了代码生成的麻烦，例如 生成 int 值、long 值或者 string 字符串。</p>\n<pre><code class=\"lang-ymal\">randomtest:\n  value: ${random.value}\n  int: ${random.int}\n  intarr: ${random.int(10)}\n  long: ${random.long}\n  longstr: ${random.long(10)}\n  uuid: ${random.uuid}\n</code></pre>\n<h4 id=\"h4-2-s-\"><a name=\"2、占位符获取之前配置的值，如果没有可以s使用指定默认值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、占位符获取之前配置的值，如果没有可以s使用指定默认值</h4><pre><code class=\"lang-ymal\">user: \n    user-name: 张三${random.uuid}\n    age: ${random.int}\n    birth: 2017/12/15    \n    dog: \n        name=${user.hello:hello}_dog  //如果有user.hello，使用前面配置的user.hello的值，没有则使用默认值hello\n        age=15\n</code></pre>\n<h3 id=\"h3-u4F7Fu7528u81EAu5B9Au4E49u914Du7F6Eu6587u4EF6\"><a name=\"使用自定义配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用自定义配置文件</h3><p>有时候我们不希望把所有配置都放在application.properties里面，那么我们就可以使用<code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>注解来加载指定的配置文件<br>我们可以自定义一个配置文件，比如<code>user.properties</code>,路径跟也放在src/main/resources下面。<br>我们就可以在配置类中使用<code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>注解来指定加载<code>user.properties</code>配置文件</p>\n<pre><code class=\"lang-java\">@PropertySource(value = {&quot;classpath:user.properties&quot;})\n@ConfigurationProperties(prefix = &quot;user&quot;)\n@Component\n@Data\npublic class User {\n\n    private String userName;\n    private int age;\n    private Date birthday;\n\n}\n</code></pre>\n<p>==注：<code><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></code>注解不支持yml配置文件==</p>\n<h3 id=\"h3--\"><a name=\"外部配置-命令行参数配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>外部配置-命令行参数配置</h3><p>Spring Boot是基于jar包运行的，打成jar包的程序可以直接通过下面命令运行：</p>\n<pre><code>java -jar xx.jar\n</code></pre><p>可以以下命令修改tomcat端口号：</p>\n<pre><code>java -jar xx.jar --server.port=8081\n</code></pre><p>可以看出，命令行中连续的两个减号—就是对application.properties中的属性值进行赋值的标识。<br>所以java -jar xx.jar —server.port=8081等价于在配置文件中添加属性server.port=8081。<br>如果你怕命令行有风险，可以使用SpringApplication.setAddCommandLineProperties(false)禁用它。</p>\n<p>实际上，Spring Boot应用程序有多种设置途径，Spring Boot能从多重属性源获得属性，包括如下几种：</p>\n<ol>\n<li>命令行参数，所有的配置都可以在命令行上进行指定,多个配置用空格分开； —配置项=值</li></ol>\n<pre><code>```\njava -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc\n```\n</code></pre><ol>\n<li><p>来自java:comp/env的JNDI属性</p>\n</li><li><p>Java系统属性（System.getProperties()）</p>\n</li><li><p>操作系统环境变量</p>\n</li><li><p>RandomValuePropertySource配置的random.*属性值</p>\n<p> ==<strong>由jar包外向jar包内进行寻找；</strong>==</p>\n<p> ==<strong>优先加载带profile</strong>==</p>\n</li><li><p>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p>\n</li><li><p>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件**</p>\n</li></ol>\n<pre><code>==**再来加载不带profile**==\n</code></pre><ol>\n<li><p>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</p>\n</li><li><p>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</p>\n</li><li><p><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\"><a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a></a>注解类上的<a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\"><a href=\"https://github.com/PropertySource\" title=\"&#64;PropertySource\" class=\"at-link\">@PropertySource</a></a></p>\n</li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p>\n</li></ol>\n<p>所有支持的配置加载来源；<a href=\"https://docs.spring.io/spring-boot/docs/2.0.4.RELEASE/reference/htmlsingle/#boot-features-external-config\">参考官方文档</a></p>\n<h3 id=\"h3-u914Du7F6Eu6587u4EF6u503Cu83B7u53D6\"><a name=\"配置文件值获取\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>配置文件值获取</h3><p>SpringBoot有两种方式获取配置文件的值</p>\n<h4 id=\"h4--value-\"><a name=\"使用@Value注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用<a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>注解</h4><p>配置文件中提供自定义属性的支持，这样我们就可以把一些常量配置在这里：</p>\n<pre><code class=\"lang-yaml\">user:\n  user-name: 张三\n  age: 18\n  birthday: 2000/01/01\n</code></pre>\n<p>然后直接在要使用的地方通过注解<code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>(value=”${config.name}”)</code>就可以绑定到你想要的属性上面</p>\n<pre><code class=\"lang-java\">@Component\n@Data\npublic class User{\n\n    @Value(&quot;${user.user-name}&quot;)\n    private String userName;\n    @Value(&quot;${user.age}&quot;)\n    private int age;\n    @Value(&quot;${user.birthday}&quot;)\n    private Date birthday;\n\n}\n</code></pre>\n<p>测试运行，输出获取到的user</p>\n<pre><code class=\"lang-java\">@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootApplicationTests {\n    @Autowired\n    User user;\n    @Test\n    public void contextLoads() {\n        System.out.println(user);\n    }\n}\n</code></pre>\n<p>输出结果如下</p>\n<blockquote>\n<p>User(userName=张三, age=18, birthday=Sat Jan 01 00&#58;00&#58;00 CST 2000)</p>\n</blockquote>\n<h4 id=\"h4--configurationproperties-\"><a name=\"使用@ConfigurationProperties注解\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用<a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a>注解</h4><p>有时候属性太多了，一个个绑定到属性字段上太累，我们可以使用<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code> 注解<br>该注解的含义是将配置文件中配置的每一个属性的值，映射到这个组件中，其属性prefix = “xxx”指定配置文件中哪个下面的所有属性进行一一映射<br>注：只有这个组件是容器中的组件，才能容器提供的<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>功能；所以类上必须有<code><a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a></code>注解<br>这样我们就不必在每个属性上都配置<code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></code>注解，只需要在类上配置<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a>(prefix = &quot;user&quot;)</code><br>SpringBoot就会自动将每个属性都映射上配置文件中对应的值</p>\n<pre><code class=\"lang-java\">@Component\n@ConfigurationProperties(prefix = &quot;user&quot;)\n@Data\npublic class User{\n\n    private String userName;\n\n    private int age;\n\n    private Date birthday;\n\n}\n</code></pre>\n<p>测试运行，输出获取到的user</p>\n<pre><code class=\"lang-java\">@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringbootApplicationTests {\n    @Autowired\n    User user;\n    @Test\n    public void contextLoads() {\n        System.out.println(user);\n    }\n}\n</code></pre>\n<p>输出结果如下</p>\n<blockquote>\n<p>User(userName=张三, age=18, birthday=Sat Jan 01 00&#58;00&#58;00 CST 2000)</p>\n</blockquote>\n<h4 id=\"h4--value-configurationproperties-\"><a name=\"@Value和@ConfigurationProperties注解的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>和<a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a>注解的区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></th>\n<th><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>批量配置</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>松散绑定（松散语法）</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>SpEL</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>JSR303数据校验</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>复杂类型封装</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>批量配置：如上面实例中所示，<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>可以批量注入配置文件中的属性，<code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a></code>只能一个一个注入</li><li>松散语法：<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>支持松散语法，比如配置文件中user-name使用<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>可以给userName属性注入值，但是<code><a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>(&quot;${user.userName}&quot;)</code>不能将配置文件中的user-name属性赋值给userName</li><li>SpEL语言：<code><a href=\"https://github.com/value\" title=\"&#64;value\" class=\"at-link\">@value</a></code>支持SpEL语言，比如:<pre><code class=\"lang-java\"> <a href=\"https://github.com/Value\" title=\"&#64;Value\" class=\"at-link\">@Value</a>(&quot;#{11*2}&quot;)\n private int age;\n</code></pre>\n 但是如果在配置文件中age=#{11*2},<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>并不能将计算后的值注入给age属性</li><li>JSR303数据校验：使用<code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></code>可以使用数据校验，比如：<pre><code class=\"lang-java\"> <a href=\"https://github.com/Email\" title=\"&#64;Email\" class=\"at-link\">@Email</a>\n private String email;\n</code></pre>\n</li><li><p><code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\"><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></a></code>支持复杂性封装，比如</p>\n<pre><code class=\"lang-yaml\"> user:\n   user-name: 张三\n   age: 18\n   birthday: 2000/01/01\n   map: {1:v1,k2:v2}\n</code></pre>\n<pre><code class=\"lang-java\"> <a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>\n <a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a>(prefix = &quot;user&quot;)\n <a href=\"https://github.com/Data\" title=\"&#64;Data\" class=\"at-link\">@Data</a>\n public class User{\n\n     private String userName;\n\n     private int age;\n\n     private Map map;\n\n }\n</code></pre>\n<p> <code><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\"><a href=\"https://github.com/ConfigurationProperties\" title=\"&#64;ConfigurationProperties\" class=\"at-link\">@ConfigurationProperties</a></a></code>可以直接将配置文件中的map赋值给map属性</p>\n</li></ol>\n<h3 id=\"h3-profile-\"><a name=\"Profile-多环境配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Profile-多环境配置</h3><p>当应用程序需要部署到不同运行环境时，配置通常会有所不同，最简单的比如日志，生产日志会将日志级别设置为WARN或更高级别，并将日志写入日志文件，而开发的时候需要日志级别为DEBUG，日志输出到控制台即可。如果每次发布的时候替换掉配置文件，这样太麻烦了，Spring Boot的Profile就给我们提供了两种解决方案，命令带上参数就搞定。</p>\n<h4 id=\"h4-1-profile-\"><a name=\"1、多Profile文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、多Profile文件</h4><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml<br>默认使用<code>application.properties</code>的配置，可以在配置文件中使用<code>spring.profiles.active= xxx</code>指定使用哪个配置文件<br>比如我们想使用<code>application-dev.yml</code>这个配置文件就可以在主配置文件中配置</p>\n<pre><code class=\"lang-yml\">spring:\n  profiles:\n    active: dev\n</code></pre>\n<h4 id=\"h4-2-yml-\"><a name=\"2、yml支持多文档块方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、yml支持多文档块方式</h4><p>yml可以使用<code>---</code>来分割代码块，可以指定使用哪个代码块</p>\n<pre><code class=\"lang-yml\">server:\n  port: 8081\nspring:\n  profiles:\n    active: prod\n---\nserver:\n  port: 8083\nspring:\n  profiles: dev\n\n---\nserver:\n  port: 8084\nspring:\n  profiles: prod  #指定属于哪个环境\n</code></pre>\n<p>也可以使用外部参数激活使用哪个配置文件</p>\n<pre><code class=\"lang-java\">java -jar spring-boot.jar --spring.profiles.active=dev；\n</code></pre>\n<p>或者使用虚拟机参数</p>\n<pre><code>-Dspring.profiles.active=dev\n</code></pre>', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/12.jpg', '/article/126', 45, '2020-09-19', NULL, 0, 124, 130, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (130, '高性能MySQL：创建高性能索引', '索引才会被使用,则不使用索引,避免select*尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列））', '## 索引的概述\n索引时存储引擎用于快速找到记录的一种**数据结构**，索引主要用来**查找和排序**。\n由索引的定义我们看出，索引就是满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。如下面的示意图所示 :\n![](/images/153/1601106660243index001.png)\n左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是\n一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一\n个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据\n库中用来提高性能的最常用的工具。\n\n索引对于良好的性能非常关键。数据量越大时，索引对性能的影响也越重要，好的索引可以将查询性能提高几个数量级，但是在数据量很大时，糟糕的索引也会使MySQL的性能急剧的下降\n## 索引的语法\n\n### 创建索引\n索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。\n\n创建表之后添加索引\n	```sql\n	CREATE INDEX indexName ON tableName(columnName(length));\n	或者\n	ALTER table tableName ADD INDEX indexName(columnName)\n	```\n创建表的时候直接指定\n	```sql\n	CREATE TABLE mytable(  \n	 \n		ID INT NOT NULL,   \n	 \n		username VARCHAR(16) NOT NULL,  \n	 \n		INDEX [indexName] (username(length))  \n	 \n	);  \n	```\n### 删除索引\n```sql\nDROP INDEX [indexName] ON tableName ; \n或者\nALTER TABLE table_name DROP INDEX index_name;\n```\n### 查看索引\n```sql\nSHOW INDEX FROM tableName ;\n```\n ### 查看查询语句使用索引的情况\n ```sql\n# explain 加查询语句\nexplain SELECT * FROM table_name WHERE column_1 = \'123\';\n```\n\n## 索引的优缺点\n\n###  索引的优点\n\n索引可以让服务器快速的定位到表的指定位置。但是这并不是索引的唯一作用，到目前位置，可以看到，根据索引的数据结构不同，索引也有一些其他的附加作用，总结下来索引有以下三个优点：\n1. 索引大大减少了服务器需要扫描的数据量\n2. 索引可以帮助服务器避免排序和临时表\n3. 索引可以将随机I/O变为顺序I/O	```\n\n### 索引的缺点\n索引本身也是表，因此会占用存储空间，创建和维护索引需要耗费空间和时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；\n\n## 索引的分类\nMySQL目前主要有以下五种索引类型：\n1.普通索引\n是最基本的索引，它没有任何限制。\n```sql\nALTER TABLE \'table_name\' ADD INDEX index_name(\'col\');\n```\n2.唯一索引\n与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。\n```\nALTER TABLE \'table_name\' ADD UNIQUE index_name(\'col\');\n```\n3.主键索引\n是一种特殊的唯一索引，一个表只能有一个主键，索引列的值必须唯一，不允许有空值。一般是在建表的时候同时创建主键索引\n```sql\nALTER TABLE \'table_name\' ADD PRIMARY KEY pk_index(\'col\');\n```\n4.组合索引\n指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合\n```sql\nALTER TABLE \'table_name\' ADD INDEX index_name(\'col1\',\'col2\',\'col3\');\n```\n5.全文索引\n主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。\n创建时需要在INDEX前面加上FULLTEXT\n```sql\nALTER TABLE \'table_name\' ADD FULLTEXT INDEX ft_index(\'col\');\n```\n\n## 索引的结构\n索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，\n也不是所有的存储引擎都支持所有的索引类型的。MySQL常用的索引有以下四种4种索引：\n+ **BTree 索引** ： 最常见的索引类型，大部分索引都支持 B 树索引。目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。当谈论索引的时候，如果没有特别指明类型，多半说的是BTree索引。\nBTree索引的原理请参考[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html \"MySQL索引背后的数据结构及算法原理\")\n+ **Hash 索引**：只有Memory引擎支持 ， 使用场景简单 。\n+ **R-Tree 索引（空间索引）**：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常\n使用较少，不做特别介绍。\n+ **Full-text （全文索引）** ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从\nMysql5.6版本开始支持全文索引。\n\n** MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持**\n\n|  索引 |  InnoDB引擎 | MyISAM引擎  | Memory引擎  |\n| ------------ | ------------ | ------------ | ------------ |\n|  BTREE索引 |  支持 |  支持 |  支持 |\n| HASH 索引  |  不支持 | 不支持  |  支持 |\n| R-tree 索引  |  不支持 | 支持 |  不支持 |\n|  Full-text |  5.6版本之后支持 |  支持 | 不支持  |\n\n\n\n\n## 索引的使用\n\n正确地创建和使用索引是实现高效能查询的基础。高效的选择和使用索引有很多种方式，其中有些是针对特殊案例的优化方法，有些则是针对特定行为的优化。索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。\n\n### 索引设计原则\n索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。\n	\n+ 主键自动建立主键索引；查询中与其他表关联的字段，外键关系最好建立索引；查询中统计或者分组的字段或者用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引\n+ 作为排序的列要建立索引，排序字段通过索引去访问，会大大提高排序速度\n+ 使用唯一索引，区分度越高，使用索引的效率越高。有大量重复且分布均匀的数据的列不建立索引。\n+ 对查询频次较高，且数据量比较大的表建立索引。(表记录太少,全表扫描也很快，没有必要建立索引）\n+ 索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。\n+ 经常增删改的字段上不要建立索引，对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。\n+ 使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。\n+ 利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。\n+ 高并发条件下倾向组合索引；\n\n### 高性能的索引策略\n\n环境准备\n```sql\n# 创建表\ncreate table `tb_seller` (\n`sellerid` varchar (100),\n`name` varchar (100),\n`nickname` varchar (50),\n`password` varchar (60),\n`status` varchar (1),\n`address` varchar (100),\n`createtime` datetime,\nprimary key(`sellerid`)\n)engine=innodb default charset=utf8mb4;\n# 插入数据\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'alibaba\',\'阿里巴巴\',\'阿里小\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'baidu\',\'百度科技有限公司\',\'百度小\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'huawei\',\'华为科技有限公司\',\'华为小\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'0\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'itcast\',\'传智播客教育科技有限公司\',\'传智播\n客\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'itheima\',\'黑马程序员\',\'黑马程序\n员\',\'e10adc3949ba59abbe56e057f20f883e\',\'0\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'luoji\',\'罗技科技有限公司\',\'罗技小\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'oppo\',\'OPPO科技有限公司\',\'OPPO官方旗舰\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'0\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'ourpalm\',\'掌趣科技股份有限公司\',\'掌趣小\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'qiandu\',\'千度科技\',\'千度小\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'2\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'sina\',\'新浪科技有限公司\',\'新浪官方旗舰\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'北京市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'xiaomi\',\'小米科技\',\'小米官方旗舰\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'西安市\',\'2088-01-01 12:00:00\');\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(\'yijia\',\'宜家家居\',\'宜家家居旗舰\n店\',\'e10adc3949ba59abbe56e057f20f883e\',\'1\',\'北京市\',\'2088-01-01 12:00:00\');\n# 创建索引\ncreate index idx_seller_name_sta_addr on tb_seller(name,status,address);\n```\n\n\n#### 全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。\n```sql\nexplain select * from tb_seller where name=\'小米科技\' and status=\'1\' and address=\'北京市\';\n```\n![](/images/130/1602130525763file_1602130525000.png)\n\n#### 最左前缀法则\n如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。\n匹配最左前缀法则，走索引：\n![](/images/130/1602130699394file_1602130699000.png)\n\n如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：\n![](/images/130/1602131114682file_1602131114000.png)\n\n范围查询右边的列，不能使用索引 。\n![](/images/130/1602131003020file_1602131003000.png)\n根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。\n\n违法最左前缀法则，索引失效：\n![](/images/130/1602130915356file_1602130915000.png)\n\n#### 独立的列\n如果查询中的列不是独立的，则MySQL就不会使用索引。独立的列指索引列不能是表达式的一部分，也不能是函数的参数\n比如：\n```sql\nselect * from tb_seller where status+1 = \'2\';\n```\n或者\n```sql\nselect * from tb_seller where substring(name,3,2)=\'科技\';\n```\n![](/images/130/1602131742193file_1602131742000.png)\n\n#### 字符串不加单引号，造成索引失效。\n![](/images/130/1602131992775file_1602131992000.png)\n由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。\n\n#### 尽量使用覆盖索引，避免select *\n尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。\n\n|Extra| 含义|\n| ------------ | ------------ |\n|using index  | 使用覆盖索引的时候就会出现 |\n|using where  | 在查找使用索引的情况下，需要回表去查询所需的数据  |\n|using index condition|查找使用了索引，但是需要回表查询数据|\n|using index ; using where |  查找使用了索引，且需要的数据都在索引列中能找到，不需要回表查询数据|\n![](/images/130/1602132470133file_1602132470000.png)\n\n#### 减少使用or\n用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。\n示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：\n\n####  like的使用\n1）如果仅仅是尾部模糊匹配，索引不会失效。\n![](/images/130/1602133145368file_1602133145000.png)\n2）如果是头部模糊匹配，索引失效。\n![](/images/130/1602133229216file_1602133229000.png)\n\n3）解决方案 ：通过覆盖索引来解决\n![](/images/null/1602144484231file_1602144484000.png)\n#### 如果MySQL评估使用索引比全表更慢，则不使用索引。\n\n####  is NULL ， is NOT NULL 有时索引失效。\n\n####  in 走索引， not in 索引失效。\n\n####  单列索引和复合索引。\n尽量使用复合索引，而少使用单列索引 。', '<h2 id=\"h2-u7D22u5F15u7684u6982u8FF0\"><a name=\"索引的概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的概述</h2><p>索引时存储引擎用于快速找到记录的一种<strong>数据结构</strong>，索引主要用来<strong>查找和排序</strong>。<br>由索引的定义我们看出，索引就是满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。如下面的示意图所示 :<br><img src=\"/images/153/1601106660243index001.png\" alt=\"\"><br>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是<br>一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一<br>个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。<br>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据<br>库中用来提高性能的最常用的工具。</p>\n<p>索引对于良好的性能非常关键。数据量越大时，索引对性能的影响也越重要，好的索引可以将查询性能提高几个数量级，但是在数据量很大时，糟糕的索引也会使MySQL的性能急剧的下降</p>\n<h2 id=\"h2-u7D22u5F15u7684u8BEDu6CD5\"><a name=\"索引的语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的语法</h2><h3 id=\"h3-u521Bu5EFAu7D22u5F15\"><a name=\"创建索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建索引</h3><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p>\n<p>创建表之后添加索引</p>\n<pre><code>```sql\nCREATE INDEX indexName ON tableName(columnName(length));\n或者\nALTER table tableName ADD INDEX indexName(columnName)\n```\n</code></pre><p>创建表的时候直接指定</p>\n<pre><code>```sql\nCREATE TABLE mytable(  \n\n    ID INT NOT NULL,   \n\n    username VARCHAR(16) NOT NULL,  \n\n    INDEX [indexName] (username(length))  \n\n);  \n```\n</code></pre><h3 id=\"h3-u5220u9664u7D22u5F15\"><a name=\"删除索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除索引</h3><pre><code class=\"lang-sql\">DROP INDEX [indexName] ON tableName ; \n或者\nALTER TABLE table_name DROP INDEX index_name;\n</code></pre>\n<h3 id=\"h3-u67E5u770Bu7D22u5F15\"><a name=\"查看索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看索引</h3><pre><code class=\"lang-sql\">SHOW INDEX FROM tableName ;\n</code></pre>\n<h3 id=\"h3-u67E5u770Bu67E5u8BE2u8BEDu53E5u4F7Fu7528u7D22u5F15u7684u60C5u51B5\"><a name=\"查看查询语句使用索引的情况\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看查询语句使用索引的情况</h3><pre><code class=\"lang-sql\"># explain 加查询语句\nexplain SELECT * FROM table_name WHERE column_1 = &#39;123&#39;;\n</code></pre>\n<h2 id=\"h2-u7D22u5F15u7684u4F18u7F3Au70B9\"><a name=\"索引的优缺点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的优缺点</h2><h3 id=\"h3-u7D22u5F15u7684u4F18u70B9\"><a name=\"索引的优点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的优点</h3><p>索引可以让服务器快速的定位到表的指定位置。但是这并不是索引的唯一作用，到目前位置，可以看到，根据索引的数据结构不同，索引也有一些其他的附加作用，总结下来索引有以下三个优点：</p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机I/O变为顺序I/O    ```</li></ol>\n<h3 id=\"h3-u7D22u5F15u7684u7F3Au70B9\"><a name=\"索引的缺点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的缺点</h3><p>索引本身也是表，因此会占用存储空间，创建和维护索引需要耗费空间和时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</p>\n<h2 id=\"h2-u7D22u5F15u7684u5206u7C7B\"><a name=\"索引的分类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的分类</h2><p>MySQL目前主要有以下五种索引类型：<br>1.普通索引<br>是最基本的索引，它没有任何限制。</p>\n<pre><code class=\"lang-sql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;);\n</code></pre>\n<p>2.唯一索引<br>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p>\n<pre><code>ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;);\n</code></pre><p>3.主键索引<br>是一种特殊的唯一索引，一个表只能有一个主键，索引列的值必须唯一，不允许有空值。一般是在建表的时候同时创建主键索引</p>\n<pre><code class=\"lang-sql\">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;);\n</code></pre>\n<p>4.组合索引<br>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合</p>\n<pre><code class=\"lang-sql\">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;);\n</code></pre>\n<p>5.全文索引<br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。<br>创建时需要在INDEX前面加上FULLTEXT</p>\n<pre><code class=\"lang-sql\">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;);\n</code></pre>\n<h2 id=\"h2-u7D22u5F15u7684u7ED3u6784\"><a name=\"索引的结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的结构</h2><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，<br>也不是所有的存储引擎都支持所有的索引类型的。MySQL常用的索引有以下四种4种索引：</p>\n<ul>\n<li><strong>BTree 索引</strong> ： 最常见的索引类型，大部分索引都支持 B 树索引。目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。当谈论索引的时候，如果没有特别指明类型，多半说的是BTree索引。<br>BTree索引的原理请参考<a href=\"http://blog.codinglabs.org/articles/theory-of-mysql-index.html\" title=\"MySQL索引背后的数据结构及算法原理\">MySQL索引背后的数据结构及算法原理</a></li><li><strong>Hash 索引</strong>：只有Memory引擎支持 ， 使用场景简单 。</li><li><strong>R-Tree 索引（空间索引）</strong>：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常<br>使用较少，不做特别介绍。</li><li><strong>Full-text （全文索引）</strong> ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从<br>Mysql5.6版本开始支持全文索引。</li></ul>\n<p><strong> MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</strong></p>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>InnoDB引擎</th>\n<th>MyISAM引擎</th>\n<th>Memory引擎</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BTREE索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>HASH 索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>R-tree 索引</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>Full-text</td>\n<td>5.6版本之后支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-u7D22u5F15u7684u4F7Fu7528\"><a name=\"索引的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的使用</h2><p>正确地创建和使用索引是实现高效能查询的基础。高效的选择和使用索引有很多种方式，其中有些是针对特殊案例的优化方法，有些则是针对特定行为的优化。索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。</p>\n<h3 id=\"h3-u7D22u5F15u8BBEu8BA1u539Fu5219\"><a name=\"索引设计原则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引设计原则</h3><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p>\n<ul>\n<li>主键自动建立主键索引；查询中与其他表关联的字段，外键关系最好建立索引；查询中统计或者分组的字段或者用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</li><li>作为排序的列要建立索引，排序字段通过索引去访问，会大大提高排序速度</li><li>使用唯一索引，区分度越高，使用索引的效率越高。有大量重复且分布均匀的数据的列不建立索引。</li><li>对查询频次较高，且数据量比较大的表建立索引。(表记录太少,全表扫描也很快，没有必要建立索引）</li><li>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</li><li>经常增删改的字段上不要建立索引，对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</li><li>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。</li><li>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</li><li>高并发条件下倾向组合索引；</li></ul>\n<h3 id=\"h3-u9AD8u6027u80FDu7684u7D22u5F15u7B56u7565\"><a name=\"高性能的索引策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>高性能的索引策略</h3><p>环境准备</p>\n<pre><code class=\"lang-sql\"># 创建表\ncreate table `tb_seller` (\n`sellerid` varchar (100),\n`name` varchar (100),\n`nickname` varchar (50),\n`password` varchar (60),\n`status` varchar (1),\n`address` varchar (100),\n`createtime` datetime,\nprimary key(`sellerid`)\n)engine=innodb default charset=utf8mb4;\n# 插入数据\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;alibaba&#39;,&#39;阿里巴巴&#39;,&#39;阿里小\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;baidu&#39;,&#39;百度科技有限公司&#39;,&#39;百度小\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;huawei&#39;,&#39;华为科技有限公司&#39;,&#39;华为小\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;itcast&#39;,&#39;传智播客教育科技有限公司&#39;,&#39;传智播\n客&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;itheima&#39;,&#39;黑马程序员&#39;,&#39;黑马程序\n员&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;luoji&#39;,&#39;罗技科技有限公司&#39;,&#39;罗技小\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;oppo&#39;,&#39;OPPO科技有限公司&#39;,&#39;OPPO官方旗舰\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;0&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;ourpalm&#39;,&#39;掌趣科技股份有限公司&#39;,&#39;掌趣小\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;qiandu&#39;,&#39;千度科技&#39;,&#39;千度小\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;2&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;sina&#39;,&#39;新浪科技有限公司&#39;,&#39;新浪官方旗舰\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;xiaomi&#39;,&#39;小米科技&#39;,&#39;小米官方旗舰\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;西安市&#39;,&#39;2088-01-01 12:00:00&#39;);\ninsert into `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`,\n`address`, `createtime`) values(&#39;yijia&#39;,&#39;宜家家居&#39;,&#39;宜家家居旗舰\n店&#39;,&#39;e10adc3949ba59abbe56e057f20f883e&#39;,&#39;1&#39;,&#39;北京市&#39;,&#39;2088-01-01 12:00:00&#39;);\n# 创建索引\ncreate index idx_seller_name_sta_addr on tb_seller(name,status,address);\n</code></pre>\n<h4 id=\"h4--\"><a name=\"全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。</h4><pre><code class=\"lang-sql\">explain select * from tb_seller where name=&#39;小米科技&#39; and status=&#39;1&#39; and address=&#39;北京市&#39;;\n</code></pre>\n<p><img src=\"/images/130/1602130525763file_1602130525000.png\" alt=\"\"></p>\n<h4 id=\"h4-u6700u5DE6u524Du7F00u6CD5u5219\"><a name=\"最左前缀法则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>最左前缀法则</h4><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。<br>匹配最左前缀法则，走索引：<br><img src=\"/images/130/1602130699394file_1602130699000.png\" alt=\"\"></p>\n<p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：<br><img src=\"/images/130/1602131114682file_1602131114000.png\" alt=\"\"></p>\n<p>范围查询右边的列，不能使用索引 。<br><img src=\"/images/130/1602131003020file_1602131003000.png\" alt=\"\"><br>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p>\n<p>违法最左前缀法则，索引失效：<br><img src=\"/images/130/1602130915356file_1602130915000.png\" alt=\"\"></p>\n<h4 id=\"h4-u72ECu7ACBu7684u5217\"><a name=\"独立的列\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>独立的列</h4><p>如果查询中的列不是独立的，则MySQL就不会使用索引。独立的列指索引列不能是表达式的一部分，也不能是函数的参数<br>比如：</p>\n<pre><code class=\"lang-sql\">select * from tb_seller where status+1 = &#39;2&#39;;\n</code></pre>\n<p>或者</p>\n<pre><code class=\"lang-sql\">select * from tb_seller where substring(name,3,2)=&#39;科技&#39;;\n</code></pre>\n<p><img src=\"/images/130/1602131742193file_1602131742000.png\" alt=\"\"></p>\n<h4 id=\"h4--\"><a name=\"字符串不加单引号，造成索引失效。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>字符串不加单引号，造成索引失效。</h4><p><img src=\"/images/130/1602131992775file_1602131992000.png\" alt=\"\"><br>由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p>\n<h4 id=\"h4--select-\"><a name=\"尽量使用覆盖索引，避免select *\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>尽量使用覆盖索引，避免select *</h4><p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p>\n<table>\n<thead>\n<tr>\n<th>Extra</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>using index</td>\n<td>使用覆盖索引的时候就会出现</td>\n</tr>\n<tr>\n<td>using where</td>\n<td>在查找使用索引的情况下，需要回表去查询所需的数据</td>\n</tr>\n<tr>\n<td>using index condition</td>\n<td>查找使用了索引，但是需要回表查询数据</td>\n</tr>\n<tr>\n<td>using index ; using where</td>\n<td>查找使用了索引，且需要的数据都在索引列中能找到，不需要回表查询数据</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/images/130/1602132470133file_1602132470000.png\" alt=\"\"></p>\n<h4 id=\"h4--or\"><a name=\"减少使用or\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>减少使用or</h4><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。<br>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：</p>\n<h4 id=\"h4-like-\"><a name=\"like的使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>like的使用</h4><p>1）如果仅仅是尾部模糊匹配，索引不会失效。<br><img src=\"/images/130/1602133145368file_1602133145000.png\" alt=\"\"><br>2）如果是头部模糊匹配，索引失效。<br><img src=\"/images/130/1602133229216file_1602133229000.png\" alt=\"\"></p>\n<p>3）解决方案 ：通过覆盖索引来解决<br><img src=\"/images/null/1602144484231file_1602144484000.png\" alt=\"\"></p>\n<h4 id=\"h4--mysql-\"><a name=\"如果MySQL评估使用索引比全表更慢，则不使用索引。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如果MySQL评估使用索引比全表更慢，则不使用索引。</h4><h4 id=\"h4-is-null-is-not-null-\"><a name=\"is NULL ， is NOT NULL 有时索引失效。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>is NULL ， is NOT NULL 有时索引失效。</h4><h4 id=\"h4-in-not-in-\"><a name=\"in 走索引， not in 索引失效。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>in 走索引， not in 索引失效。</h4><h4 id=\"h4--\"><a name=\"单列索引和复合索引。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>单列索引和复合索引。</h4><p>尽量使用复合索引，而少使用单列索引 。</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/14.jpg', '/article/130', 48, '2020-09-21', NULL, 0, 126, 152, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (161, 'Idea', 'FileTypes在右侧Ignorefilesandfolders中加入要隐藏的文件类型（比如.iml和.idea）设置默认工作空间File—&gt,IDEA设置设置背景色File--&gt,setting—&gt', '##IDEA设置\n### 设置背景色\n```\nFile --> setting --> Editor --> Color Scheme\n```\n![](/images/159/1601390143041设置背景.png)\n\n### 设置字体大小\n```\nFile --> setting --> Editor --> Font\n```\n### 忽略大小写\n```\nFile --> setting --> Editor --> General --> Code Completion\n在右侧配置界面选中All letters\n在右侧配置界面把Match case（匹配大小写）前面的√去掉，\n```\n![](/images/159/1601391189056忽略大小写.png)\n\n### 隐藏.iml和.idea等自动生成文件\nFile --> setting --> Editor --> File Types\n在右侧Ignore files and folders中加入要隐藏的文件类型（比如*.iml和*.idea）\n![](/images/161/1602988958044file_1602988957000.png)\n\n### 设置默认工作空间\nFile --> setting --> System Settings\n在Default directory中选择要设置的工作空间路径\n![](/images/161/1603089103813file_1603089103000.png)\n## IDEA插件', '<h2 id=\"h2-idea-\"><a name=\"IDEA设置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IDEA设置</h2><h3 id=\"h3-u8BBEu7F6Eu80CCu666Fu8272\"><a name=\"设置背景色\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置背景色</h3><pre><code>File --&gt; setting --&gt; Editor --&gt; Color Scheme\n</code></pre><p><img src=\"/images/159/1601390143041设置背景.png\" alt=\"\"></p>\n<h3 id=\"h3-u8BBEu7F6Eu5B57u4F53u5927u5C0F\"><a name=\"设置字体大小\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置字体大小</h3><pre><code>File --&gt; setting --&gt; Editor --&gt; Font\n</code></pre><h3 id=\"h3-u5FFDu7565u5927u5C0Fu5199\"><a name=\"忽略大小写\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>忽略大小写</h3><pre><code>File --&gt; setting --&gt; Editor --&gt; General --&gt; Code Completion\n在右侧配置界面选中All letters\n在右侧配置界面把Match case（匹配大小写）前面的√去掉，\n</code></pre><p><img src=\"/images/159/1601391189056忽略大小写.png\" alt=\"\"></p>\n<h3 id=\"h3--iml-idea-\"><a name=\"隐藏.iml和.idea等自动生成文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>隐藏.iml和.idea等自动生成文件</h3><p>File —&gt; setting —&gt; Editor —&gt; File Types<br>在右侧Ignore files and folders中加入要隐藏的文件类型（比如<em>.iml和</em>.idea）<br><img src=\"/images/161/1602988958044file_1602988957000.png\" alt=\"\"></p>\n<h3 id=\"h3-u8BBEu7F6Eu9ED8u8BA4u5DE5u4F5Cu7A7Au95F4\"><a name=\"设置默认工作空间\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置默认工作空间</h3><p>File —&gt; setting —&gt; System Settings<br>在Default directory中选择要设置的工作空间路径<br><img src=\"/images/161/1603089103813file_1603089103000.png\" alt=\"\"></p>\n<h2 id=\"h2-idea-\"><a name=\"IDEA插件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>IDEA插件</h2>', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/6.jpg', '/article/161', 47, '2020-09-29', NULL, 0, 154, 168, 0, 1, 0, 1);
INSERT INTO `blog_article` VALUES (117, 'SpringBoot入门到精通：（二）启动原理解析', '将这些值作为自动配置类导入到容器中,将所有符合自动配置条件的bean定义加载到IoC容器,SpringBoot帮我们自动配置', '![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013195748147.png)\n## 前言\n前面见识了SpringBoot为我们做的自动配置，非常方便快捷，相比于之前繁琐的配置文件，简直不要太优秀，让我们不禁好奇，到底是怎么做到的呢，让我们一起来探究一下\n\n---\n## 正文 \n\n我们开发任何一个Spring Boot项目，都会用到如下的启动类\n\n```java\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n从上面代码可以看出，Annotation定义（@SpringBootApplication）和类定义（SpringApplication.run）最为耀眼，所以要揭开SpringBoot的神秘面纱，我们要从这两位开始就可以了。\n\n@**SpringBootApplication**:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；\n看一下他的源码：\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n```\n\nSpringBootApplication是一个组合注解，虽然定义使用了多个Annotation进行了原信息标注，但重要的只有三个Annotation：\n+ @SpringBootConfiguration\n+ @EnableAutoConfiguration\n+ @ComponentScan\n\n所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等：\n```java\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n每次写这3个比较累，所以写一个@SpringBootApplication方便点。接下来分别介绍这3个Annotation。\n\n\n### 1. @**SpringBootConfiguration**:Spring Boot的配置类；\n\n​		标注在某个类上，表示这是一个Spring Boot的配置类；\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\npublic @interface SpringBootConfiguration {\n\n}\n```\n​@Configuration对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个@Configuration，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。配置类也是容器中的一个组件；@Component\n\n举几个简单例子回顾下，XML跟config配置方式的区别：\n\n表达形式层面\n基于XML配置的方式是这样：\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"\n       default-lazy-init=\"true\">\n    <!--bean定义-->\n</beans>\n```\n而基于JavaConfig的配置方式是这样：\n```java\n@Configuration\npublic class MockConfiguration{\n    //bean定义\n}\n\n```\n任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类。\n\n注册bean定义层面\n基于XML的配置形式是这样：\n```xml\n<bean id=\"userService\" class=\"..UserServiceImpl\">\n    ...\n</bean>\n```\n而基于JavaConfig的配置形式是这样的：\n```java\n@Configuration\npublic class SpringConfiguration{\n    @Bean\n    public UserService userService(){\n        return new UserServiceImpl();\n    }\n}\n```\n任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。\n\n表达依赖注入关系层面\n为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：\n```xml\n<bean id=\"mockService\" class=\"..MockServiceImpl\">\n    <propery name =\"dependencyService\" ref=\"dependencyService\" />\n</bean>\n\n<bean id=\"dependencyService\" class=\"DependencyServiceImpl\"></bean>\n```\n而基于JavaConfig的配置形式是这样的：\n```java\n@Configuration\npublic class SpringConfiguration{\n    @Bean\n    public UserService userService(){\n        return new UserServiceImpl(dependencyService());\n    }\n    \n    @Bean\n    public DependencyService dependencyService(){\n        return new DependencyServiceImpl();\n    }\n}\n```\n如果一个bean的定义依赖其他bean,则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。\n\n---\n\n### 2. @**ComponentScan**：开启自动配置功能；\n@ComponentScan这个注解在Spring中很重要，它对应XML配置中的元素，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。\n\n我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。\n\n**注**：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。\n\n### 3. @**EnableAutoConfiguration**：开启自动配置功能；\n\nSpringBoot之所以可以零配置，其核心就是​@EnableAutoConfiguration这个Annotation，以前我们需要配置的东西，Spring Boot帮我们自动配置；而@**EnableAutoConfiguration**告诉SpringBoot开启自动配置功能；这样自动配置才能生效；\n大家是否还记得Spring框架提供的各种名字为@Enable开头的Annotation定义？比如@EnableScheduling、@EnableCaching、@EnableMBeanExport等，@EnableAutoConfiguration的理念和做事方式其实一脉相承\n简单概括一下就是，借助**@Import的支持，收集和注册特定场景相关的bean定义**。\n@EnableScheduling是通过@Import将Spring调度框架相关的bean定义都加载到IoC容器。\n@EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。\n而@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！\n\n```java\n@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n```\n\n​      	@**AutoConfigurationPackage**：自动配置包\n\n​		@**Import**(AutoConfigurationPackages.Registrar.class)：\n\n​		Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==\n\n​	    @**Import**(EnableAutoConfigurationImportSelector.class)；\n\n​		给容器中导入组件？\n\n​		**EnableAutoConfigurationImportSelector**：导入哪些组件的选择器；\n\n​		将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；\n\n​		会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；		\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101419355125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；\n借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们；\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191014200657927.png)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191014200702151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191014200723840.png)\nJ2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure中\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191014195708246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n\n', '<p><img src=\"https://img-blog.csdnimg.cn/20191013195748147.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2-u524Du8A00\"><a name=\"前言\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前言</h2><p>前面见识了SpringBoot为我们做的自动配置，非常方便快捷，相比于之前繁琐的配置文件，简直不要太优秀，让我们不禁好奇，到底是怎么做到的呢，让我们一起来探究一下</p>\n<hr>\n<h2 id=\"h2-u6B63u6587\"><a name=\"正文\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>正文</h2><p>我们开发任何一个Spring Boot项目，都会用到如下的启动类</p>\n<pre><code class=\"lang-java\">@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>\n<p>从上面代码可以看出，Annotation定义（<a href=\"https://github.com/SpringBootApplication\" title=\"&#64;SpringBootApplication\" class=\"at-link\">@SpringBootApplication</a>）和类定义（SpringApplication.run）最为耀眼，所以要揭开SpringBoot的神秘面纱，我们要从这两位开始就可以了。</p>\n<p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；<br>看一下他的源码：</p>\n<pre><code class=\"lang-java\">@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = {\n      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n</code></pre>\n<p>SpringBootApplication是一个组合注解，虽然定义使用了多个Annotation进行了原信息标注，但重要的只有三个Annotation：</p>\n<ul>\n<li><a href=\"https://github.com/SpringBootConfiguration\" title=\"&#64;SpringBootConfiguration\" class=\"at-link\">@SpringBootConfiguration</a></li><li><a href=\"https://github.com/EnableAutoConfiguration\" title=\"&#64;EnableAutoConfiguration\" class=\"at-link\">@EnableAutoConfiguration</a></li><li><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a></li></ul>\n<p>所以，如果我们使用如下的SpringBoot启动类，整个SpringBoot应用依然可以与之前的启动类功能对等：</p>\n<pre><code class=\"lang-java\">@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre>\n<p>每次写这3个比较累，所以写一个<a href=\"https://github.com/SpringBootApplication\" title=\"&#64;SpringBootApplication\" class=\"at-link\">@SpringBootApplication</a>方便点。接下来分别介绍这3个Annotation。</p>\n<h3 id=\"h3-1-strong-springbootconfiguration-strong-spring-boot-\"><a name=\"1. @<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1. @<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</h3><p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p>\n<pre><code class=\"lang-java\">@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\npublic @interface SpringBootConfiguration {\n\n}\n</code></pre>\n<p>​<a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>对我们来说不陌生，它就是JavaConfig形式的Spring Ioc容器的配置类使用的那个<a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>，SpringBoot社区推荐使用基于JavaConfig的配置形式，所以，这里的启动类标注了<a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>之后，本身其实也是一个IoC容器的配置类。配置类也是容器中的一个组件；<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a></p>\n<p>举几个简单例子回顾下，XML跟config配置方式的区别：</p>\n<p>表达形式层面<br>基于XML配置的方式是这样：</p>\n<pre><code class=\"lang-xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;\n       default-lazy-init=&quot;true&quot;&gt;\n    &lt;!--bean定义--&gt;\n&lt;/beans&gt;\n</code></pre>\n<p>而基于JavaConfig的配置方式是这样：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class MockConfiguration{\n    //bean定义\n}\n</code></pre>\n<p>任何一个标注了<a href=\"https://github.com/Configuration\" title=\"&#64;Configuration\" class=\"at-link\">@Configuration</a>的Java类定义都是一个JavaConfig配置类。</p>\n<p>注册bean定义层面<br>基于XML的配置形式是这样：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;userService&quot; class=&quot;..UserServiceImpl&quot;&gt;\n    ...\n&lt;/bean&gt;\n</code></pre>\n<p>而基于JavaConfig的配置形式是这样的：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class SpringConfiguration{\n    @Bean\n    public UserService userService(){\n        return new UserServiceImpl();\n    }\n}\n</code></pre>\n<p>任何一个标注了<a href=\"https://github.com/Bean\" title=\"&#64;Bean\" class=\"at-link\">@Bean</a>的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。</p>\n<p>表达依赖注入关系层面<br>为了表达bean与bean之间的依赖关系，在XML形式中一般是这样：</p>\n<pre><code class=\"lang-xml\">&lt;bean id=&quot;mockService&quot; class=&quot;..MockServiceImpl&quot;&gt;\n    &lt;propery name =&quot;dependencyService&quot; ref=&quot;dependencyService&quot; /&gt;\n&lt;/bean&gt;\n\n&lt;bean id=&quot;dependencyService&quot; class=&quot;DependencyServiceImpl&quot;&gt;&lt;/bean&gt;\n</code></pre>\n<p>而基于JavaConfig的配置形式是这样的：</p>\n<pre><code class=\"lang-java\">@Configuration\npublic class SpringConfiguration{\n    @Bean\n    public UserService userService(){\n        return new UserServiceImpl(dependencyService());\n    }\n\n    @Bean\n    public DependencyService dependencyService(){\n        return new DependencyServiceImpl();\n    }\n}\n</code></pre>\n<p>如果一个bean的定义依赖其他bean,则直接调用对应的JavaConfig类中依赖bean的创建方法就可以了。</p>\n<hr>\n<h3 id=\"h3-2-strong-componentscan-strong-\"><a name=\"2. @<strong>ComponentScan</strong>：开启自动配置功能；\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2. @<strong>ComponentScan</strong>：开启自动配置功能；</h3><p><a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>这个注解在Spring中很重要，它对应XML配置中的元素，<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>的功能其实就是自动扫描并加载符合条件的组件（比如<a href=\"https://github.com/Component\" title=\"&#64;Component\" class=\"at-link\">@Component</a>和<a href=\"https://github.com/Repository\" title=\"&#64;Repository\" class=\"at-link\">@Repository</a>等）或者bean定义，最终将这些bean定义加载到IoC容器中。</p>\n<p>我们可以通过basePackages等属性来细粒度的定制<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>自动扫描的范围，如果不指定，则默认Spring框架实现会从声明<a href=\"https://github.com/ComponentScan\" title=\"&#64;ComponentScan\" class=\"at-link\">@ComponentScan</a>所在类的package进行扫描。</p>\n<p><strong>注</strong>：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p>\n<h3 id=\"h3-3-strong-enableautoconfiguration-strong-\"><a name=\"3. @<strong>EnableAutoConfiguration</strong>：开启自动配置功能；\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. @<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</h3><p>SpringBoot之所以可以零配置，其核心就是​<a href=\"https://github.com/EnableAutoConfiguration\" title=\"&#64;EnableAutoConfiguration\" class=\"at-link\">@EnableAutoConfiguration</a>这个Annotation，以前我们需要配置的东西，Spring Boot帮我们自动配置；而@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；<br>大家是否还记得Spring框架提供的各种名字为<a href=\"https://github.com/Enable\" title=\"&#64;Enable\" class=\"at-link\">@Enable</a>开头的Annotation定义？比如<a href=\"https://github.com/EnableScheduling\" title=\"&#64;EnableScheduling\" class=\"at-link\">@EnableScheduling</a>、<a href=\"https://github.com/EnableCaching\" title=\"&#64;EnableCaching\" class=\"at-link\">@EnableCaching</a>、<a href=\"https://github.com/EnableMBeanExport\" title=\"&#64;EnableMBeanExport\" class=\"at-link\">@EnableMBeanExport</a>等，<a href=\"https://github.com/EnableAutoConfiguration\" title=\"&#64;EnableAutoConfiguration\" class=\"at-link\">@EnableAutoConfiguration</a>的理念和做事方式其实一脉相承<br>简单概括一下就是，借助<strong><a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>的支持，收集和注册特定场景相关的bean定义</strong>。<br><a href=\"https://github.com/EnableScheduling\" title=\"&#64;EnableScheduling\" class=\"at-link\">@EnableScheduling</a>是通过<a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>将Spring调度框架相关的bean定义都加载到IoC容器。<br><a href=\"https://github.com/EnableMBeanExport\" title=\"&#64;EnableMBeanExport\" class=\"at-link\">@EnableMBeanExport</a>是通过<a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>将JMX相关的bean定义加载到IoC容器。<br>而<a href=\"https://github.com/EnableAutoConfiguration\" title=\"&#64;EnableAutoConfiguration\" class=\"at-link\">@EnableAutoConfiguration</a>也是借助<a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！</p>\n<pre><code class=\"lang-java\">@AutoConfigurationPackage\n@Import(EnableAutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n</code></pre>\n<p>​          @<strong>AutoConfigurationPackage</strong>：自动配置包</p>\n<p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p>\n<p>​        Spring的底层注解<a href=\"https://github.com/Import\" title=\"&#64;Import\" class=\"at-link\">@Import</a>，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class==将主配置类（<a href=\"https://github.com/SpringBootApplication\" title=\"&#64;SpringBootApplication\" class=\"at-link\">@SpringBootApplication</a>标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==</p>\n<p>​        @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p>\n<p>​        给容器中导入组件？</p>\n<p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p>\n<p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p>\n<p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；<br><img src=\"https://img-blog.csdnimg.cn/2019101419355125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；<br>借助于Spring框架原有的一个工具类：SpringFactoriesLoader的支持，SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们；</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191014200657927.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20191014200702151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20191014200723840.png\" alt=\"在这里插入图片描述\"><br>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20191014195708246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/3.jpg', '/article/117', 45, '2020-09-19', NULL, 0, 116, 121, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (116, 'SpringBoot入门到精通：（一）Hello World', '我们之所以在上面的项目中没有手动的去配置Tomcat服务器,（项目中存在大量的配置,SpringBoot是所有基于Spring开发的项目的起点', '![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013182144841.png)\n## Spring Boot 概述\n>**Build Anything with Spring Boot：**\n>Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.\n\n上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191014202643364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n在SpringBoot官方网站上，介绍了SpringBoot的特点\n就是快速简洁的创建独立的Spring应用程序，并且完全不需要任何配置文件\n它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。\n它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架\n\n## SpringBoot快速搭建\n第一步：新建项目\n选择 Spring Initializr ，然后选择默认的 url 点击【Next】：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013182424420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n然后修改一下项目的信息：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101318255057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n勾选项目需要的模块\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013182649432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n选择项目路径，修改项目名，点击Finish\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013182748525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n至此，项目创建完成，项目结构如下\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013183132126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n\n+ DemoApplication： 一个带有 main() 方法的类，用于启动应用程序\n+ DemoApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的  Spring 应用程序上下文\n+ resource文件夹目录结构\n	+ static：用于存储静态文件（css,js等）\n	+  templates：用于存放模板页面\n	+ application.properties：SpringBoot应用的配置文件，可以用来修改一些默认配置\n+ pom.xml： Maven 构建说明文件\n\n\n第一步：Hello World\n在【cn.example.demo】包下新建一个package【controller】，新建类【HelloWorldController】：\n\n```java\n@RestController\npublic class HelloWorldController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n\n        return \"Hello World !!!\";\n\n    }\n}\n```\n第三步：利用 IDEA 启动 Spring Boot\n我们回到 DemoApplication 这个类中，然后右键点击运行：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101318443227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n+ **注意**：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat\n启动成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101318460481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “/hello” 地址试一下：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20191013184646707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n至此，一个SpringBoot的HelloWorld完成\n', '<p><img src=\"https://img-blog.csdnimg.cn/20191013182144841.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2-spring-boot-\"><a name=\"Spring Boot 概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Spring Boot 概述</h2><blockquote>\n<p><strong>Build Anything with Spring Boot：</strong><br>Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.</p>\n</blockquote>\n<p>上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。<br><img src=\"https://img-blog.csdnimg.cn/20191014202643364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>在SpringBoot官方网站上，介绍了SpringBoot的特点<br>就是快速简洁的创建独立的Spring应用程序，并且完全不需要任何配置文件<br>它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。<br>它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架</p>\n<h2 id=\"h2-springboot-\"><a name=\"SpringBoot快速搭建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>SpringBoot快速搭建</h2><p>第一步：新建项目<br>选择 Spring Initializr ，然后选择默认的 url 点击【Next】：<br><img src=\"https://img-blog.csdnimg.cn/20191013182424420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>然后修改一下项目的信息：<br><img src=\"https://img-blog.csdnimg.cn/2019101318255057.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>勾选项目需要的模块<br><img src=\"https://img-blog.csdnimg.cn/20191013182649432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>选择项目路径，修改项目名，点击Finish<br><img src=\"https://img-blog.csdnimg.cn/20191013182748525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>至此，项目创建完成，项目结构如下<br><img src=\"https://img-blog.csdnimg.cn/20191013183132126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>DemoApplication： 一个带有 main() 方法的类，用于启动应用程序</li><li>DemoApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的  Spring 应用程序上下文</li><li>resource文件夹目录结构<ul>\n<li>static：用于存储静态文件（css,js等）</li><li>templates：用于存放模板页面</li><li>application.properties：SpringBoot应用的配置文件，可以用来修改一些默认配置</li></ul>\n</li><li>pom.xml： Maven 构建说明文件</li></ul>\n<p>第一步：Hello World<br>在【cn.example.demo】包下新建一个package【controller】，新建类【HelloWorldController】：</p>\n<pre><code class=\"lang-java\">@RestController\npublic class HelloWorldController {\n\n    @RequestMapping(&quot;/hello&quot;)\n    public String hello(){\n\n        return &quot;Hello World !!!&quot;;\n\n    }\n}\n</code></pre>\n<p>第三步：利用 IDEA 启动 Spring Boot<br>我们回到 DemoApplication 这个类中，然后右键点击运行：<br><img src=\"https://img-blog.csdnimg.cn/2019101318443227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><strong>注意</strong>：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat<br>启动成功<br><img src=\"https://img-blog.csdnimg.cn/2019101318460481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “/hello” 地址试一下：<br><img src=\"https://img-blog.csdnimg.cn/20191013184646707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>至此，一个SpringBoot的HelloWorld完成</li></ul>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/4.jpg', '/article/116', 45, '2020-09-19', NULL, 0, 113, 117, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (154, 'MySQL索引', '只有在查询条件中使用了创建索引时的第一个字段,必须按照索引创建顺序存储引擎不能使用索引中范围条件右边的列在使用不等于&lt,就以什么顺序使用==4.3.5覆盖索引如果索引包含（或者说覆盖）所有需要查询的字段的值', '## 索引的概述\n索引时存储引擎用于快速找到记录的一种**数据结构**，索引主要用来**查找和排序**。\n由索引的定义我们看出，索引就是满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。如下面的示意图所示 :\n![](/images/153/1601106660243index001.png)\n左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是\n一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一\n个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。\n一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据\n库中用来提高性能的最常用的工具。\n\n索引对于良好的性能非常关键。数据量越大时，索引对性能的影响也越重要，好的索引可以将查询性能提高几个数量级，但是在数据量很大时，糟糕的索引也会使MySQL的性能急剧的下降\n\n## 索引的优势劣势\n\n### 索引的优势\n索引可以让服务器快速的定位到表的指定位置。但是这并不是索引的唯一作用，到目前位置，可以看到，根据索引的数据结构不同，索引也有一些其他的附加作用，总结下来索引有以下三个优点：\n1. 索引大大减少了服务器需要扫描的数据量\n2. 索引可以帮助服务器避免排序和临时表\n3. 索引可以将随机I/O变为顺序I/O \n\n### 索引的劣势\n索引本身也是表，因此会占用存储空间，创建和维护索引需要耗费空间和时间成本，这个成本随着数据量增大而增大；\n构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；\n\n## 索引的结构\n索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，\n也不是所有的存储引擎都支持所有的索引类型的。MySQL常用的索引有以下四种4种索引：\n+ **BTree 索引** ： 最常见的索引类型，大部分索引都支持 B 树索引。目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。当谈论索引的时候，如果没有特别指明类型，多半说的是BTree索引。\nBTree索引的原理请参考[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html \"MySQL索引背后的数据结构及算法原理\")\n+ **Hash 索引**：只有Memory引擎支持 ， 使用场景简单 。\n+ **R-Tree 索引（空间索引）**：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常\n使用较少，不做特别介绍。\n+ **Full-text （全文索引）** ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从\nMysql5.6版本开始支持全文索引。\n\n **MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持**\n\n|  索引 |  InnoDB引擎 | MyISAM引擎  | Memory引擎  |\n| ------------ | ------------ | ------------ | ------------ |\n|  BTREE索引 |  支持 |  支持 |  支持 |\n| HASH 索引  |  不支持 | 不支持  |  支持 |\n| R-tree 索引  |  不支持 | 支持 |  不支持 |\n|  Full-text |  5.6版本之后支持 |  支持 | 不支持  |\n\n\n## 索引的分类\nMySQL目前主要有以下五种索引类型：\n1.单值索引\n是最基本的索引，它没有任何限制。\n2.唯一索引\n与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。\n3.主键索引\n是一种特殊的唯一索引，一个表只能有一个主键，索引列的值必须唯一，不允许有空值。一般是在建表的时候同时创建主键索引\n4.复合索引\n指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合\n5.全文索引\n主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。\n创建时需要在INDEX前面加上FULLTEXT\n\n## 索引的语法\n\n索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。\n\n准备环境\n```sql\ncreate database demo_01 default charset=utf8mb4;\nuse demo_01;\nCREATE TABLE `city` (\n	`city_id` int(11) NOT NULL AUTO_INCREMENT,\n	`city_name` varchar(50) NOT NULL,\n	`country_id` int(11) NOT NULL,\n	PRIMARY KEY (`city_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nCREATE TABLE `country` (\n	`country_id` int(11) NOT NULL AUTO_INCREMENT,\n	`country_name` varchar(100) NOT NULL,\n	PRIMARY KEY (`country_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(1,\'西安\',1);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(2,\'NewYork\',2);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(3,\'北京\',1);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(4,\'上海\',1);\ninsert into `country` (`country_id`, `country_name`) values(1,\'China\');\ninsert into `country` (`country_id`, `country_name`) values(2,\'America\');\ninsert into `country` (`country_id`, `country_name`) values(3,\'Japan\');\ninsert into `country` (`country_id`, `country_name`) values(4,\'UK\');\n```\n### 创建索引\n```sql\nCREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name\n[USING index_type]\nON tbl_name(index_col_name,...)\nindex_col_name : column_name[(length)][ASC | DESC]\n```\n示例 ： 为city表中的city_name字段创建索引 ；\n\n### 查看索引\n```sql\nshow index from table_name;\n```\n示例：查看city表中的索引信息；\n### 删除索引\n```sql\nDROP INDEX index_name ON tbl_name;\n```\n示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：\n\n### ALTER命令\n\n1). alter table tb_name add primary key(column_list);\n该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL\n2). alter table tb_name add unique index_name(column_list);\n这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）\n3). alter table tb_name add index index_name(column_list);\n添加普通索引， 索引值可以出现多次。\n4). alter table tb_name add fulltext index_name(column_list);\n该语句指定了索引为FULLTEXT， 用于全文索引\n\n### 查看查询语句使用索引的情况\n```sql\n# explain 加查询语句\nexplain SELECT * FROM table_name WHERE column_1 = \'123\';\n```\n\n2.6 索引设计原则\n索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高\n效的使用索引。\n对查询频次较高，且数据量比较大的表建立索引。\n1 DROP INDEX index_name ON tbl_name;\n1). alter table tb_name add primary key(column_list);\n该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL\n2). alter table tb_name add unique index_name(column_list);\n这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）\n3). alter table tb_name add index index_name(column_list);\n添加普通索引， 索引值可以出现多次。\n4). alter table tb_name add fulltext index_name(column_list);\n该语句指定了索引为FULLTEXT， 用于全文索引\n## 索引设计原则\n索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高\n效的使用索引。\n对查询频次较高，且数据量比较大的表建立索引。\n索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑\n选最常用、过滤效果最好的列的组合。\n使用唯一索引，区分度越高，使用索引的效率越高。\n索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨\n船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低\nDML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然\n会找到一个可用的索引，但无疑提高了选择的代价。\n使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效\n率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有\n效的提升MySQL访问索引的I/O效率。\n利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了\n组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。\n## 四、高性能的索引策略\n### 4.1 三星系统\n正确地创建和使用索引是实现高效能查询的基础。高效的选择和使用索引有很多种方式，其中有些是针对特殊案例的优化方法，有些则是针对特定行为的优化。\nLahdenmaki和Leach在书中介绍如何评价一个索引是否适合某个查询的==三星系统==\n1. 索引将相关记录放在一起则获得一星\n2. 索引的数据顺序和排列顺序一致则获得二星\n3. 如果索引中的列包含了查询中的全部列则获取三星\n\n### 4.2 什么时候要使用索引？\n1. 主键自动建立主键索引\n2. 频繁作为查询条件在WHERE\n3. 查询中与其他表关联的字段，外键关系建立索引\n4. 作为排序的列要建立索引，排序字段通过索引去访问，会大大提高排序速度\n5. 高并发条件下倾向组合索引；\n6. 查询中统计或者分组的字段或者用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引\n\n### 4.3 什么时候尽量不要建立索引\n1. 表记录太少（全表扫描也很快，没有必要）\n2. 经常增删改的字段上不要建立索引\n3. 有大量重复且分布均匀的数据的列不建立索引\n\n### 4.3 高性能的索引策略\n正确的创建和使用索引是实现高性能查询的基础。前面已经介绍了各种类型的索引及其对应的优缺点， 我们通常会看到一些查询不当的使用索引，或者使用MySQL无法使用已有的索引，高性能的索引策略就是要避免索引失效，并尽可能的发挥这些索引的优势。\n\n#### 4.3.1 独立的列\n如果查询中的列不是独立的，则MySQL就不会使用索引。独立的列指索引列不能是表达式的一部分，也不能是函数的参数\n比如：\n```sql\nmysql> SELECT actor_id FROM actor WHERE actor_id + 1 = 5\n```\n或者\n```sql\nmysql> SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10\n```\n\n#### 4.3.2 前缀索引和索引选择性\n##### 4.3.2.1 前缀索引\n有时候需要很长的字符列，就会让索引变的大且慢。一个策略是前面提到过的Hash索引。另外一种方式就是使用前缀索引。\n前缀索引就是指使用索引列开始的部分字符建立索引\n\n##### 4.3.2.2 前缀索引的优缺点\n优点：这样可以大大节约索引的空间，从而提高索引的效率。\n缺点：使用前缀索引会降低索引的选择性，而且无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描\n\n##### 4.3.2.3 索引的选择性：\n索引的选择性是指不重复的索引值（也成为基数）和数据表记录总数（#T）的比值，范围从1/#T到1之间，索引选择性越高，查询效率越快\n\n##### 4.3.2.4 如何选则前缀索引长度\n选择前缀的索引的原则是要选择足够的长度保证索引较高的选择性，前缀索引的选择性应该接近于索引的整个列，但同时又不能太长。\n\n可以根据，前缀的基数应该接近于完整列的基数，来确定基数的长度，我们可以通过截取不同长度的字符和完整列进行比较，找到合适的长度\n另外一个办法就是计算完整列的选择性，并使用前缀的选择性接近完整列的选择性\n```sql\nmysql>select count(distinct left(city,3))/count(*) as sel3\n->  count(distinct left(city,4))/count(*) as sel4\n->  count(distinct left(city,5))/count(*) as sel5\n->  count(distinct left(city,6))/count(*) as sel6\n->  count(distinct left(city,7))/count(*) as sel7\n->  from city_table\n```\n比例接近完整列的选择性的，就可以使用作为前缀索引的长度\n**注**：只看平均选择性长度是不够的，对于数据分布很不均匀的数据，可能会有陷阱，比如平均值很接近完整列的选择性，但是由于数据的不均匀，可能对于某些数据很不友好，比如选择4个字段，平均值可能很好，但是\"San\"和\"New\"开头的选择性就特别糟糕，因此在选怎前缀索引时，要根据实际情况\n\n#### 4.3.3 多列索引\n多列索引指的是组合索引，组合多个列创建一个索引，很多人对多列索引理解不够，常见的就是为每一个列创建独立的索引，或者按照错误的顺序创建组合索引。\n再多个列上建立单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新的版本引入了一种“索引合并”（index merge）的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。\n在MySQL’更早的版本中只能使用其中某一个单列索引。但在MySQL5.0和更新的版本中，查询能够同时使用多个单列索引进行扫描，并将结果进行合并。\n该特新主要应用于以下三种场景：\n1、 对OR语句求并集，如查询SELECT * FROM TB1 WHERE c1=\"xxx\" OR c2=\"\"xxx\"时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作，得到最终结果\n2、 对AND语句求交集，如查询SELECT * FROM TB1 WHERE c1=\"xxx\" AND c2=\"\"xxx\"时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作，得到最终结果\n3、 对AND和OR组合语句求结果\n\n\n```sql\nmysql> explain select *  from t01 where c1 = 1 or c2 = 2 \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200502140229213.png)\nMySQL合并策略有时候是一种优化的结果，但实际上更多的时候说明了表上的索引建的很糟糕\n+ 当出现多个索引相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引\n+ 当出现多个索引联合操作时（通常有多个OR条件），通常需要消耗大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性并不高，需要合并扫描返回大量数据的时候\n+ 更重要的是，优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。这会使得查询成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。通常来说，还不如MySQL4.1之前，将查询改写成UNION的方式好\n\n如果在`EXPLAIN`中看到索引合并，应该好好检查一下查询和表结构，看是不是已经是最优。\n\n#### 4.3.4 选择合适的索引列顺序\n我们遇到最容易引起困惑的问题就是索引列的顺序，正确的顺序依赖于使用该索引的查询，并且同时满足排序和分组的需要（适用于B-Tree索引，Hash或者其他类型的索引并不会想B-Tree索引一样按照顺序存储数据）\n在多列索引中，索引的顺序非常重要，如果索引的顺序不正确，会导致索引失效\n1. 最佳左前缀法则\n在一个多列B-Tree索引中，索引列的顺序意味着索引首先先按照最左列进行排序，其次是第二列\n以下面查询位列\n	```sql\n	mysql>select * from payment where staff_id = 2 and customer_id = 584;\n	```\n	应该如何创建索引呢？是（staff_id ，customer_id ）索引还是颠倒一下呢，我们可以泡一下查询来确定这个表中值的分布情况，来确定哪个列的查询到的数据量更小，将查询到数据量小的列放在左边\n\n	索引创建后，必须按照索引创建顺序\n2. 存储引擎不能使用索引中范围条件右边的列\n3. 在使用不等于<>或者!= 时，无法使用索引会导致全表扫描\n4. is null和is not null无法使用索引\n5. like以通配符%开头，索引会失效，可以使用‘***%’，索引不会失效（这是底层存储引擎API的限制，MySQL可以将最左前缀的LIKE比较转换为简单的比较操作）\n6. 字符串不加单引号，索引会失效\n8. 少用or，用他连接会导致索引失效\n\n假设复合索引index(a,b,c)\n|where语句|索引使用情况  |\n|--|--|\n| where a=3 | Y，使用到了a |\n| where a=3 and b = 5 |Y，使用到了a,b  |\n| where a=3 and b = 5 and c= 6 | Y，使用到了a,b ,c |\n| where b=3或者 where b=3 and c=5|N,没有用到最左侧的索引，索引就会失效  |\n| where a = 3 and c = 5 |Y,只使用到了a ，b索引没有被用到，只要左侧的索引没有用到，后面的索引就都会失效 |\n| where a = 3 and b > 4 and c = 5 |Y,只使用到了a 和b，b使用了范围，其后续索引失效  |\n| where a=3 and b like \'kk%\' and c=5 |  Y，使用到了a,b ,c|\n| where a=3 and b like \'%kk%\' and c=5 |Y,只是用到了a  |\n| where a=3 and b like \'k%kk%\' and c=5 |Y，使用到了a,b ,c  |\n\nORDER BY 和GROUP BY使用复合索引时，也要注意顺序\n|where语句|索引使用情况  |\n|--|--|\n| where a=3 order by c | 排序 Using filesort |\n|where c1 = 2  order by c3,c2| 排序 Using filesort|\n| where a=3 and b=4 order by c 或者where a=3 order by b,c  |排序也使用索引  |\n\n==注：where a=3 and b = 5 and c= 6 也会使用到所有的索引，因为MySQL优化器会调整顺序，但是最好还是以什么顺序创建的，就以什么顺序使用==\n\n\n#### 4.3.5 覆盖索引\n如果索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。覆盖索引可以使用索引直接获取列数据，这样就不再需要读取数据行\n覆盖索引是非常有用的工具，能够极大的提高性能。\n+ 索引条目通常远远小于数据行操作，索引如果只需要读取索引，那么MySQL就会极大的减少数据访问量\n+ 因为索引是按照列值顺序存储的（至少单个页内如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的多\n+ 一些存储引擎如MyISAM的内存中只缓存索引，数据则依赖操作系统来缓存，因此访问数据需要一次系统调用。这会导致严重的性能问题\n+ 由于InnoDB的聚簇索引，覆盖索引对于InnoDB表特别有用。由于InnoDB的二级索引在叶子结点中保存了行的主键值，如果二级主键能够覆盖查询，则可以便面对主键索引的二次查询\n\n不是所有的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，索引哈希索引、空间索引、全文索引的都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引\n\n当发起一个呗索引覆盖的查询，在`explain`的Extra列可以看到“Using index”的信息\n\nt02表（字段，c1,c2,c3,c4），创建索引（index_c12）\nmysql查询优化器会在执行查询前判断是否有一个索引能进行覆盖，假设索引覆盖了where条件中的字段，但不是整个查询涉及的字段，mysql5.5和之前的版本也会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020050216291587.png)\n\n\n\n如上图则无法使用覆盖查询，原因：\n1.没有任何索引能够覆盖这个索引。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。\n2.mysql不能在索引中执行LIke操作。mysql能在索引中做最左前缀匹配的like比较，但是如果是通配符开头的like查询，存储引擎就无法做比较匹配。这种情况下mysql只能提取数据行的值而不是索引值来做比较\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200502163143954.png)\n\n\n优化后SQL：使用了延迟关联(延迟了对列的访问)。在查询的第一阶段（join 子句中的查询），MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的c1，然后根据c1值，在外层查询匹配获取所有的列值。\n\n\n\n', '<h2 id=\"h2-u7D22u5F15u7684u6982u8FF0\"><a name=\"索引的概述\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的概述</h2><p>索引时存储引擎用于快速找到记录的一种<strong>数据结构</strong>，索引主要用来<strong>查找和排序</strong>。<br>由索引的定义我们看出，索引就是满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。如下面的示意图所示 :<br><img src=\"/images/153/1601106660243index001.png\" alt=\"\"><br>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是<br>一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一<br>个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。<br>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据<br>库中用来提高性能的最常用的工具。</p>\n<p>索引对于良好的性能非常关键。数据量越大时，索引对性能的影响也越重要，好的索引可以将查询性能提高几个数量级，但是在数据量很大时，糟糕的索引也会使MySQL的性能急剧的下降</p>\n<h2 id=\"h2-u7D22u5F15u7684u4F18u52BFu52A3u52BF\"><a name=\"索引的优势劣势\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的优势劣势</h2><h3 id=\"h3-u7D22u5F15u7684u4F18u52BF\"><a name=\"索引的优势\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的优势</h3><p>索引可以让服务器快速的定位到表的指定位置。但是这并不是索引的唯一作用，到目前位置，可以看到，根据索引的数据结构不同，索引也有一些其他的附加作用，总结下来索引有以下三个优点：</p>\n<ol>\n<li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机I/O变为顺序I/O </li></ol>\n<h3 id=\"h3-u7D22u5F15u7684u52A3u52BF\"><a name=\"索引的劣势\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的劣势</h3><p>索引本身也是表，因此会占用存储空间，创建和维护索引需要耗费空间和时间成本，这个成本随着数据量增大而增大；<br>构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表；</p>\n<h2 id=\"h2-u7D22u5F15u7684u7ED3u6784\"><a name=\"索引的结构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的结构</h2><p>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，<br>也不是所有的存储引擎都支持所有的索引类型的。MySQL常用的索引有以下四种4种索引：</p>\n<ul>\n<li><strong>BTree 索引</strong> ： 最常见的索引类型，大部分索引都支持 B 树索引。目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构。当谈论索引的时候，如果没有特别指明类型，多半说的是BTree索引。<br>BTree索引的原理请参考<a href=\"http://blog.codinglabs.org/articles/theory-of-mysql-index.html\" title=\"MySQL索引背后的数据结构及算法原理\">MySQL索引背后的数据结构及算法原理</a></li><li><strong>Hash 索引</strong>：只有Memory引擎支持 ， 使用场景简单 。</li><li><strong>R-Tree 索引（空间索引）</strong>：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常<br>使用较少，不做特别介绍。</li><li><p><strong>Full-text （全文索引）</strong> ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从<br>Mysql5.6版本开始支持全文索引。</p>\n<p><strong>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</strong></p>\n</li></ul>\n<table>\n<thead>\n<tr>\n<th>索引</th>\n<th>InnoDB引擎</th>\n<th>MyISAM引擎</th>\n<th>Memory引擎</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BTREE索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>HASH 索引</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>R-tree 索引</td>\n<td>不支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>Full-text</td>\n<td>5.6版本之后支持</td>\n<td>支持</td>\n<td>不支持</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-u7D22u5F15u7684u5206u7C7B\"><a name=\"索引的分类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的分类</h2><p>MySQL目前主要有以下五种索引类型：<br>1.单值索引<br>是最基本的索引，它没有任何限制。<br>2.唯一索引<br>与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。<br>3.主键索引<br>是一种特殊的唯一索引，一个表只能有一个主键，索引列的值必须唯一，不允许有空值。一般是在建表的时候同时创建主键索引<br>4.复合索引<br>指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合<br>5.全文索引<br>主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用，不过目前只有char、varchar，text 列上可以创建全文索引。值得一提的是，在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多。<br>创建时需要在INDEX前面加上FULLTEXT</p>\n<h2 id=\"h2-u7D22u5F15u7684u8BEDu6CD5\"><a name=\"索引的语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引的语法</h2><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p>\n<p>准备环境</p>\n<pre><code class=\"lang-sql\">create database demo_01 default charset=utf8mb4;\nuse demo_01;\nCREATE TABLE `city` (\n    `city_id` int(11) NOT NULL AUTO_INCREMENT,\n    `city_name` varchar(50) NOT NULL,\n    `country_id` int(11) NOT NULL,\n    PRIMARY KEY (`city_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nCREATE TABLE `country` (\n    `country_id` int(11) NOT NULL AUTO_INCREMENT,\n    `country_name` varchar(100) NOT NULL,\n    PRIMARY KEY (`country_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(1,&#39;西安&#39;,1);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(2,&#39;NewYork&#39;,2);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(3,&#39;北京&#39;,1);\ninsert into `city` (`city_id`, `city_name`, `country_id`) values(4,&#39;上海&#39;,1);\ninsert into `country` (`country_id`, `country_name`) values(1,&#39;China&#39;);\ninsert into `country` (`country_id`, `country_name`) values(2,&#39;America&#39;);\ninsert into `country` (`country_id`, `country_name`) values(3,&#39;Japan&#39;);\ninsert into `country` (`country_id`, `country_name`) values(4,&#39;UK&#39;);\n</code></pre>\n<h3 id=\"h3-u521Bu5EFAu7D22u5F15\"><a name=\"创建索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建索引</h3><pre><code class=\"lang-sql\">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name\n[USING index_type]\nON tbl_name(index_col_name,...)\nindex_col_name : column_name[(length)][ASC | DESC]\n</code></pre>\n<p>示例 ： 为city表中的city_name字段创建索引 ；</p>\n<h3 id=\"h3-u67E5u770Bu7D22u5F15\"><a name=\"查看索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看索引</h3><pre><code class=\"lang-sql\">show index from table_name;\n</code></pre>\n<p>示例：查看city表中的索引信息；</p>\n<h3 id=\"h3-u5220u9664u7D22u5F15\"><a name=\"删除索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除索引</h3><pre><code class=\"lang-sql\">DROP INDEX index_name ON tbl_name;\n</code></pre>\n<p>示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：</p>\n<h3 id=\"h3-alter-\"><a name=\"ALTER命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>ALTER命令</h3><p>1). alter table tb_name add primary key(column_list);<br>该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL<br>2). alter table tb_name add unique index_name(column_list);<br>这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）<br>3). alter table tb_name add index index_name(column_list);<br>添加普通索引， 索引值可以出现多次。<br>4). alter table tb_name add fulltext index_name(column_list);<br>该语句指定了索引为FULLTEXT， 用于全文索引</p>\n<h3 id=\"h3-u67E5u770Bu67E5u8BE2u8BEDu53E5u4F7Fu7528u7D22u5F15u7684u60C5u51B5\"><a name=\"查看查询语句使用索引的情况\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看查询语句使用索引的情况</h3><pre><code class=\"lang-sql\"># explain 加查询语句\nexplain SELECT * FROM table_name WHERE column_1 = &#39;123&#39;;\n</code></pre>\n<p>2.6 索引设计原则<br>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高<br>效的使用索引。<br>对查询频次较高，且数据量比较大的表建立索引。<br>1 DROP INDEX index_name ON tbl_name;<br>1). alter table tb_name add primary key(column_list);<br>该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL<br>2). alter table tb_name add unique index_name(column_list);<br>这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）<br>3). alter table tb_name add index index_name(column_list);<br>添加普通索引， 索引值可以出现多次。<br>4). alter table tb_name add fulltext index_name(column_list);<br>该语句指定了索引为FULLTEXT， 用于全文索引</p>\n<h2 id=\"h2-u7D22u5F15u8BBEu8BA1u539Fu5219\"><a name=\"索引设计原则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>索引设计原则</h2><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高<br>效的使用索引。<br>对查询频次较高，且数据量比较大的表建立索引。<br>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑<br>选最常用、过滤效果最好的列的组合。<br>使用唯一索引，区分度越高，使用索引的效率越高。<br>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨<br>船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低<br>DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然<br>会找到一个可用的索引，但无疑提高了选择的代价。<br>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效<br>率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有<br>效的提升MySQL访问索引的I/O效率。<br>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了<br>组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p>\n<h2 id=\"h2--\"><a name=\"四、高性能的索引策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>四、高性能的索引策略</h2><h3 id=\"h3-4-1-\"><a name=\"4.1 三星系统\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 三星系统</h3><p>正确地创建和使用索引是实现高效能查询的基础。高效的选择和使用索引有很多种方式，其中有些是针对特殊案例的优化方法，有些则是针对特定行为的优化。<br>Lahdenmaki和Leach在书中介绍如何评价一个索引是否适合某个查询的==三星系统==</p>\n<ol>\n<li>索引将相关记录放在一起则获得一星</li><li>索引的数据顺序和排列顺序一致则获得二星</li><li>如果索引中的列包含了查询中的全部列则获取三星</li></ol>\n<h3 id=\"h3-4-2-\"><a name=\"4.2 什么时候要使用索引？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 什么时候要使用索引？</h3><ol>\n<li>主键自动建立主键索引</li><li>频繁作为查询条件在WHERE</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>作为排序的列要建立索引，排序字段通过索引去访问，会大大提高排序速度</li><li>高并发条件下倾向组合索引；</li><li>查询中统计或者分组的字段或者用于聚合函数的列可以建立索引，例如使用了max(column_1)或者count(column_1)时的column_1就需要建立索引</li></ol>\n<h3 id=\"h3-4-3-\"><a name=\"4.3 什么时候尽量不要建立索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 什么时候尽量不要建立索引</h3><ol>\n<li>表记录太少（全表扫描也很快，没有必要）</li><li>经常增删改的字段上不要建立索引</li><li>有大量重复且分布均匀的数据的列不建立索引</li></ol>\n<h3 id=\"h3-4-3-\"><a name=\"4.3 高性能的索引策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3 高性能的索引策略</h3><p>正确的创建和使用索引是实现高性能查询的基础。前面已经介绍了各种类型的索引及其对应的优缺点， 我们通常会看到一些查询不当的使用索引，或者使用MySQL无法使用已有的索引，高性能的索引策略就是要避免索引失效，并尽可能的发挥这些索引的优势。</p>\n<h4 id=\"h4-4-3-1-\"><a name=\"4.3.1 独立的列\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.1 独立的列</h4><p>如果查询中的列不是独立的，则MySQL就不会使用索引。独立的列指索引列不能是表达式的一部分，也不能是函数的参数<br>比如：</p>\n<pre><code class=\"lang-sql\">mysql&gt; SELECT actor_id FROM actor WHERE actor_id + 1 = 5\n</code></pre>\n<p>或者</p>\n<pre><code class=\"lang-sql\">mysql&gt; SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) &lt;= 10\n</code></pre>\n<h4 id=\"h4-4-3-2-\"><a name=\"4.3.2 前缀索引和索引选择性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.2 前缀索引和索引选择性</h4><h5 id=\"h5-4-3-2-1-\"><a name=\"4.3.2.1 前缀索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.2.1 前缀索引</h5><p>有时候需要很长的字符列，就会让索引变的大且慢。一个策略是前面提到过的Hash索引。另外一种方式就是使用前缀索引。<br>前缀索引就是指使用索引列开始的部分字符建立索引</p>\n<h5 id=\"h5-4-3-2-2-\"><a name=\"4.3.2.2 前缀索引的优缺点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.2.2 前缀索引的优缺点</h5><p>优点：这样可以大大节约索引的空间，从而提高索引的效率。<br>缺点：使用前缀索引会降低索引的选择性，而且无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描</p>\n<h5 id=\"h5-4-3-2-3-\"><a name=\"4.3.2.3 索引的选择性：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.2.3 索引的选择性：</h5><p>索引的选择性是指不重复的索引值（也成为基数）和数据表记录总数（#T）的比值，范围从1/#T到1之间，索引选择性越高，查询效率越快</p>\n<h5 id=\"h5-4-3-2-4-\"><a name=\"4.3.2.4 如何选则前缀索引长度\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.2.4 如何选则前缀索引长度</h5><p>选择前缀的索引的原则是要选择足够的长度保证索引较高的选择性，前缀索引的选择性应该接近于索引的整个列，但同时又不能太长。</p>\n<p>可以根据，前缀的基数应该接近于完整列的基数，来确定基数的长度，我们可以通过截取不同长度的字符和完整列进行比较，找到合适的长度<br>另外一个办法就是计算完整列的选择性，并使用前缀的选择性接近完整列的选择性</p>\n<pre><code class=\"lang-sql\">mysql&gt;select count(distinct left(city,3))/count(*) as sel3\n-&gt;  count(distinct left(city,4))/count(*) as sel4\n-&gt;  count(distinct left(city,5))/count(*) as sel5\n-&gt;  count(distinct left(city,6))/count(*) as sel6\n-&gt;  count(distinct left(city,7))/count(*) as sel7\n-&gt;  from city_table\n</code></pre>\n<p>比例接近完整列的选择性的，就可以使用作为前缀索引的长度<br><strong>注</strong>：只看平均选择性长度是不够的，对于数据分布很不均匀的数据，可能会有陷阱，比如平均值很接近完整列的选择性，但是由于数据的不均匀，可能对于某些数据很不友好，比如选择4个字段，平均值可能很好，但是”San”和”New”开头的选择性就特别糟糕，因此在选怎前缀索引时，要根据实际情况</p>\n<h4 id=\"h4-4-3-3-\"><a name=\"4.3.3 多列索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.3 多列索引</h4><p>多列索引指的是组合索引，组合多个列创建一个索引，很多人对多列索引理解不够，常见的就是为每一个列创建独立的索引，或者按照错误的顺序创建组合索引。<br>再多个列上建立单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新的版本引入了一种“索引合并”（index merge）的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。<br>在MySQL’更早的版本中只能使用其中某一个单列索引。但在MySQL5.0和更新的版本中，查询能够同时使用多个单列索引进行扫描，并将结果进行合并。<br>该特新主要应用于以下三种场景：<br>1、 对OR语句求并集，如查询SELECT <em> FROM TB1 WHERE c1=”xxx” OR c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作，得到最终结果<br>2、 对AND语句求交集，如查询SELECT </em> FROM TB1 WHERE c1=”xxx” AND c2=””xxx”时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作，得到最终结果<br>3、 对AND和OR组合语句求结果</p>\n<pre><code class=\"lang-sql\">mysql&gt; explain select *  from t01 where c1 = 1 or c2 = 2\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200502140229213.png\" alt=\"在这里插入图片描述\"><br>MySQL合并策略有时候是一种优化的结果，但实际上更多的时候说明了表上的索引建的很糟糕</p>\n<ul>\n<li>当出现多个索引相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引</li><li>当出现多个索引联合操作时（通常有多个OR条件），通常需要消耗大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性并不高，需要合并扫描返回大量数据的时候</li><li>更重要的是，优化器不会把这些计算到“查询成本”中，优化器只关心随机页面读取。这会使得查询成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。通常来说，还不如MySQL4.1之前，将查询改写成UNION的方式好</li></ul>\n<p>如果在<code>EXPLAIN</code>中看到索引合并，应该好好检查一下查询和表结构，看是不是已经是最优。</p>\n<h4 id=\"h4-4-3-4-\"><a name=\"4.3.4 选择合适的索引列顺序\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.4 选择合适的索引列顺序</h4><p>我们遇到最容易引起困惑的问题就是索引列的顺序，正确的顺序依赖于使用该索引的查询，并且同时满足排序和分组的需要（适用于B-Tree索引，Hash或者其他类型的索引并不会想B-Tree索引一样按照顺序存储数据）<br>在多列索引中，索引的顺序非常重要，如果索引的顺序不正确，会导致索引失效</p>\n<ol>\n<li><p>最佳左前缀法则<br>在一个多列B-Tree索引中，索引列的顺序意味着索引首先先按照最左列进行排序，其次是第二列<br>以下面查询位列</p>\n<pre><code class=\"lang-sql\"> mysql&gt;select * from payment where staff_id = 2 and customer_id = 584;\n</code></pre>\n<p> 应该如何创建索引呢？是（staff_id ，customer_id ）索引还是颠倒一下呢，我们可以泡一下查询来确定这个表中值的分布情况，来确定哪个列的查询到的数据量更小，将查询到数据量小的列放在左边</p>\n<p> 索引创建后，必须按照索引创建顺序</p>\n</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>在使用不等于&lt;&gt;或者!= 时，无法使用索引会导致全表扫描</li><li>is null和is not null无法使用索引</li><li>like以通配符%开头，索引会失效，可以使用‘<em>*</em>%’，索引不会失效（这是底层存储引擎API的限制，MySQL可以将最左前缀的LIKE比较转换为简单的比较操作）</li><li>字符串不加单引号，索引会失效</li><li>少用or，用他连接会导致索引失效</li></ol>\n<p>假设复合索引index(a,b,c)<br>|where语句|索引使用情况  |<br>|—|—|<br>| where a=3 | Y，使用到了a |<br>| where a=3 and b = 5 |Y，使用到了a,b  |<br>| where a=3 and b = 5 and c= 6 | Y，使用到了a,b ,c |<br>| where b=3或者 where b=3 and c=5|N,没有用到最左侧的索引，索引就会失效  |<br>| where a = 3 and c = 5 |Y,只使用到了a ，b索引没有被用到，只要左侧的索引没有用到，后面的索引就都会失效 |<br>| where a = 3 and b &gt; 4 and c = 5 |Y,只使用到了a 和b，b使用了范围，其后续索引失效  |<br>| where a=3 and b like ‘kk%’ and c=5 |  Y，使用到了a,b ,c|<br>| where a=3 and b like ‘%kk%’ and c=5 |Y,只是用到了a  |<br>| where a=3 and b like ‘k%kk%’ and c=5 |Y，使用到了a,b ,c  |</p>\n<p>ORDER BY 和GROUP BY使用复合索引时，也要注意顺序<br>|where语句|索引使用情况  |<br>|—|—|<br>| where a=3 order by c | 排序 Using filesort |<br>|where c1 = 2  order by c3,c2| 排序 Using filesort|<br>| where a=3 and b=4 order by c 或者where a=3 order by b,c  |排序也使用索引  |</p>\n<p>==注：where a=3 and b = 5 and c= 6 也会使用到所有的索引，因为MySQL优化器会调整顺序，但是最好还是以什么顺序创建的，就以什么顺序使用==</p>\n<h4 id=\"h4-4-3-5-\"><a name=\"4.3.5 覆盖索引\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.3.5 覆盖索引</h4><p>如果索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。覆盖索引可以使用索引直接获取列数据，这样就不再需要读取数据行<br>覆盖索引是非常有用的工具，能够极大的提高性能。</p>\n<ul>\n<li>索引条目通常远远小于数据行操作，索引如果只需要读取索引，那么MySQL就会极大的减少数据访问量</li><li>因为索引是按照列值顺序存储的（至少单个页内如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的多</li><li>一些存储引擎如MyISAM的内存中只缓存索引，数据则依赖操作系统来缓存，因此访问数据需要一次系统调用。这会导致严重的性能问题</li><li>由于InnoDB的聚簇索引，覆盖索引对于InnoDB表特别有用。由于InnoDB的二级索引在叶子结点中保存了行的主键值，如果二级主键能够覆盖查询，则可以便面对主键索引的二次查询</li></ul>\n<p>不是所有的索引都可以成为覆盖索引，覆盖索引必须要存储索引列的值，索引哈希索引、空间索引、全文索引的都不存储索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引</p>\n<p>当发起一个呗索引覆盖的查询，在<code>explain</code>的Extra列可以看到“Using index”的信息</p>\n<p>t02表（字段，c1,c2,c3,c4），创建索引（index_c12）<br>mysql查询优化器会在执行查询前判断是否有一个索引能进行覆盖，假设索引覆盖了where条件中的字段，但不是整个查询涉及的字段，mysql5.5和之前的版本也会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。<br><img src=\"https://img-blog.csdnimg.cn/2020050216291587.png\" alt=\"在这里插入图片描述\"></p>\n<p>如上图则无法使用覆盖查询，原因：<br>1.没有任何索引能够覆盖这个索引。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。<br>2.mysql不能在索引中执行LIke操作。mysql能在索引中做最左前缀匹配的like比较，但是如果是通配符开头的like查询，存储引擎就无法做比较匹配。这种情况下mysql只能提取数据行的值而不是索引值来做比较<br><img src=\"https://img-blog.csdnimg.cn/20200502163143954.png\" alt=\"在这里插入图片描述\"></p>\n<p>优化后SQL：使用了延迟关联(延迟了对列的访问)。在查询的第一阶段（join 子句中的查询），MySQL可以使用覆盖索引，在FROM子句的子查询中找到匹配的c1，然后根据c1值，在外层查询匹配获取所有的列值。</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/15.jpg', '/article/154', 48, '2020-09-26', NULL, 0, 152, 161, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (109, 'Docker入门：（九）Docker可视化工具', '/var/run/docker.sock\\uifd/ui-for-dockerportainer使用拉取镜像dockerpullportainer/portainer创建容器dockerrun-d-p9001,dockerUIshipyard（停止维护）portainerdaocloud(收费)工具使用dockerUI拉取DockerUI镜像dockerpulluifd/ui-for-docker创建容器dockerrun-d-p9000,9000\\-v/var/run/docker.sock', '##  常用工具介绍\n当Docker部署规模住键变大后，可视化监控容器环境得性能和健康状态将会变得越来越重要。Docker的图形化管理工具、提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像、创建容器等操作）、事件日志、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。\n常用工具：\n1. docker UI\n2. shipyard（停止维护）\n3. portainer\n4. daocloud(收费)\n\n## 工具使用\n#### docker UI\n1. 拉取Docker UI镜像\n	```java\n	docker pull uifd/ui-for-docker\n	```\n2. 创建容器\n	```java\n	docker run -d -p 9000:9000 --privileged \\\n	-v /var/run/docker.sock:/var/run/docker.sock \\\n	uifd/ui-for-docker\n	```\n	![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405130525633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n#### portainer使用\n1. 拉取镜像\n	```java\n	docker pull portainer/portainer\n	```\n2. 创建容器\n	```java\n	docker run -d -p 9001:9000 \\\n	-v /var/run/docker.sock:/var/run/docker.sock \\\n	portainer/portainer\n	```\n	portainer需要设置密码,相对比docker UI安全\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405130916793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n	进入之后，如果是本地，选取本地\n	![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040513103832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n	![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405131108272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n', '<h2 id=\"h2-u5E38u7528u5DE5u5177u4ECBu7ECD\"><a name=\"常用工具介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常用工具介绍</h2><p>当Docker部署规模住键变大后，可视化监控容器环境得性能和健康状态将会变得越来越重要。Docker的图形化管理工具、提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像、创建容器等操作）、事件日志、容器控制台操作、Swarm集群和服务等集中管理和操作、登录用户管理和控制等功能。<br>常用工具：</p>\n<ol>\n<li>docker UI</li><li>shipyard（停止维护）</li><li>portainer</li><li>daocloud(收费)</li></ol>\n<h2 id=\"h2-u5DE5u5177u4F7Fu7528\"><a name=\"工具使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>工具使用</h2><h4 id=\"h4-docker-ui\"><a name=\"docker UI\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>docker UI</h4><ol>\n<li>拉取Docker UI镜像<pre><code class=\"lang-java\"> docker pull uifd/ui-for-docker\n</code></pre>\n</li><li>创建容器<pre><code class=\"lang-java\"> docker run -d -p 9000:9000 --privileged \\\n -v /var/run/docker.sock:/var/run/docker.sock \\\n uifd/ui-for-docker\n</code></pre>\n <img src=\"https://img-blog.csdnimg.cn/20200405130525633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><h4 id=\"h4-portainer-\"><a name=\"portainer使用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>portainer使用</h4></li><li>拉取镜像<pre><code class=\"lang-java\"> docker pull portainer/portainer\n</code></pre>\n</li><li><p>创建容器</p>\n<pre><code class=\"lang-java\"> docker run -d -p 9001:9000 \\\n -v /var/run/docker.sock:/var/run/docker.sock \\\n portainer/portainer\n</code></pre>\n<p> portainer需要设置密码,相对比docker UI安全<br><img src=\"https://img-blog.csdnimg.cn/20200405130916793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p> 进入之后，如果是本地，选取本地<br> <img src=\"https://img-blog.csdnimg.cn/2020040513103832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br> <img src=\"https://img-blog.csdnimg.cn/20200405131108272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n</li></ol>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/17.jpg', '/article/109', 43, '2020-09-19', NULL, 0, 108, 113, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (101, 'Docker入门：（一）虚拟化技术', '例如软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化、虚拟机等虚拟化架构全虚拟化客户机操作系统不宿主机操作系统的限制,而不需要模拟硬件平台虚拟化（硬件虚拟化）无需安装宿主机操作系统,是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机', '## 什么是虚拟化\n\nhello world\n虚拟化技术即Virtualization，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。\n虚拟化使用软件的方法重新定义划分IT资源，可以实现IT资源的动态分配、灵活调度、跨域共享，提高IT资源利用率，使IT资源能够真正成为社会基础设施，服务于各行各业中灵活多变的应用需求。\n在实际生产中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老旧硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件\n虚拟化技术种类有很多，例如软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化、虚拟机等\n## 虚拟化架构\n\n### 全虚拟化\n客户机操作系统不宿主机操作系统的限制，虚拟机就是全虚拟化，需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307215118545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n### 操作系统层的虚拟化\n客户机操作系统必须要和宿主机操作系统保持一致，容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。容器利用和共享主机内核，而不需要模拟硬件\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307214637449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n### 平台虚拟化（硬件虚拟化）\n无需安装宿主机操作系统，客户机操作系统可以随意进行安装，公司购买服务器后经常使用平台虚拟化，模拟出多台服务器同时运行\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307215209611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n## Hypervisor\nHypervisor是一种运行在物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，他可以协调访问服务器上的所有的物理设备和虚拟机，也叫虚拟机监视器。Hypervisor是所有虚拟化技术的核心。当服务器启动并执行Hypervisor时，他会给每一台虚拟机分配适量的内存、CPU、网络和磁盘，并加载所有虚拟机的客户操作系统。常见的产品有Vmware、KVM、Xen等。\n', '<h2 id=\"h2-u4EC0u4E48u662Fu865Au62DFu5316\"><a name=\"什么是虚拟化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是虚拟化</h2><p>hello world<br>虚拟化技术即Virtualization，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。<br>虚拟化使用软件的方法重新定义划分IT资源，可以实现IT资源的动态分配、灵活调度、跨域共享，提高IT资源利用率，使IT资源能够真正成为社会基础设施，服务于各行各业中灵活多变的应用需求。<br>在实际生产中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老旧硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件<br>虚拟化技术种类有很多，例如软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化、虚拟机等</p>\n<h2 id=\"h2-u865Au62DFu5316u67B6u6784\"><a name=\"虚拟化架构\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>虚拟化架构</h2><h3 id=\"h3-u5168u865Au62DFu5316\"><a name=\"全虚拟化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>全虚拟化</h3><p>客户机操作系统不宿主机操作系统的限制，虚拟机就是全虚拟化，需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。<br><img src=\"https://img-blog.csdnimg.cn/20200307215118545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"h3-u64CDu4F5Cu7CFBu7EDFu5C42u7684u865Au62DFu5316\"><a name=\"操作系统层的虚拟化\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>操作系统层的虚拟化</h3><p>客户机操作系统必须要和宿主机操作系统保持一致，容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。容器利用和共享主机内核，而不需要模拟硬件<br><img src=\"https://img-blog.csdnimg.cn/20200307214637449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"h3--\"><a name=\"平台虚拟化（硬件虚拟化）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>平台虚拟化（硬件虚拟化）</h3><p>无需安装宿主机操作系统，客户机操作系统可以随意进行安装，公司购买服务器后经常使用平台虚拟化，模拟出多台服务器同时运行<br><img src=\"https://img-blog.csdnimg.cn/20200307215209611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2-hypervisor\"><a name=\"Hypervisor\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Hypervisor</h2><p>Hypervisor是一种运行在物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，他可以协调访问服务器上的所有的物理设备和虚拟机，也叫虚拟机监视器。Hypervisor是所有虚拟化技术的核心。当服务器启动并执行Hypervisor时，他会给每一台虚拟机分配适量的内存、CPU、网络和磁盘，并加载所有虚拟机的客户操作系统。常见的产品有Vmware、KVM、Xen等。</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/12.jpg', '/article/101', 43, '2020-09-19', NULL, 0, NULL, 102, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (102, 'Docker入门：（二）Docker介绍', 'docker容器是由docker镜像创建的运行实例,可以理解为静态文件）docker利用容器来运行应用,==docker的镜像概念类似虚拟机的镜像', '## Docker概念\n\n>Docker is a platform for developers and sysadmins to build, run, and share applications with containers. The use of containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.\n\n上面是[Docker官方文档](https://docs.docker.com/get-started/)中给出的定义，翻译之后就是：\nDocker是一个供开发人员和系统管理员使用容器构建、运行和共享应用程序的平台。使用容器部署应用程序称为容器化。容器并不新鲜，但它们用于轻松部署应用程序却很新鲜。\n\n因此，要了解docker是什么，首先我们要理解**容器**的概念，而理解容器，我们还要了解**容器**和**虚拟机**的区别\n\n## 容器和虚拟机\n上文中我们介绍了虚拟化技术，了解了虚拟化架构之后，我们就可以很清楚的区分**容器**和**虚拟机**的概念\n我们用的传统虚拟机如 VMware ， VisualBox 之类的是全虚拟化架构，需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。\n\n而容器技术是基于操作系统层的虚拟化技术，容器和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。\n\n容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307215606288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n容器的优点：\n\n+ **灵活**:即使是最复杂的应用程序也可以被封装。\n\n+ **轻量级**:容器利用和共享主机内核，使它们在系统资源方面比虚拟机更高效。\n\n+ **可移植性**:您可以在本地构建、部署到云，并在任何地方运行。\n\n+ **松散耦合**:容器是高度自给自足和封装的，允许您替换或升级一个容器而不破坏其他容器。\n\n+ **可伸缩**:您可以增加并自动跨数据中心分发容器副本。\n\n+ **安全**:容器对进程应用主动约束和隔离，而不需要用户进行任何配置。\n\n我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：\n|特性  |容器  | 虚拟机|\n|--|--|--|\n|启动|	秒级	|分钟级|\n|硬盘使用	|一般为MB|	一般为GB|\n|性能|	接近原生|	弱于|\n|系统支持量|	单机支持上千个容器|	一般是几十个|\n\n## Docker定位\nDocker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。\nDocker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。\n总体来说， Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。\n\nDocker相比于传统虚拟化方式具有更多的优势：\n\n+ docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动\n+ docker 需要的资源更少， docker 在操作系统级别进行虚拟化， docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化\n+ docker 更轻量， docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，  Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高\n与虚拟机相比， docker 隔离性更弱， docker 属于进程之间的隔离，虚拟机可实现系统级别隔离\n+ 安全性： docker 的安全性也更弱。 Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击\n+ 可管理性： docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力\n+ 高可用和可恢复性： docker 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性\n+ 快速创建、删除：虚拟化创建是分钟级别的， Docker 容器创建是秒级别的， Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间\n交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 Docker 在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署\n\n\n## Docker三要素\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020030822421362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n从上图我们可以看到，Docker 中包括三个基本的要素：\n1. Repository(仓库)\n2. Image(镜像)\n3. Container(容器)\n\n\n### Repository（仓库）\n仓库的概念很好理解，Docker 仓库是集中存放镜像文件的场所。如果使用了git和github就很容易理解docker的仓库概念。docker仓库概念和git类似。\n\ndocker提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像，\n\ndocker运作中使用的默认仓库是[docker hub](https://hub.docker.com/)公共仓库。\n\n仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用push命令将它上传到共有或者私有的仓库。这样下次再另外一台机器上使用这个镜像的时候只需要从仓库里面pull下来就可以了。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过<仓库名>:<标签>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。\n###  Image(镜像)和Container(容器)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200308223245737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n>Fundamentally, a container is nothing but a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers. One of the most important aspects of container isolation is that each container interacts with its own private filesystem; this filesystem is provided by a Docker image. An image includes everything needed to run an application - the code or binary, runtimes, dependencies, and any other filesystem objects required.\n容器只是一个正在运行的进程，为了使它与主机和其他容器隔离，在其上应用了一些附加的封装特性。容器隔离最重要的方面之一是每个容器都与自己的私有文件系统进行交互;此文件系统由Docker镜像提供。镜像包含运行应用程序所需的所有东西——代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。\n\n镜像是文件, 容器是进程。 容器是基于镜像创建的, 即容器中的进程依赖于镜像中的文件, 这里的文件包括进程运行所需要的可执行文件， 依赖软件， 库文件， 配置文件等等...\n相对于镜像来说容器是动态的，容器的定义和镜像几乎一样，唯一的区别是容器在启动的时候创建了一层可写层次作为最上层。（   docker create <image -id > ：为指定的镜像添加一个可读写层，构成一个新的容器；）\n==注：容器是由镜像实例化而来，这和我们学习的面向对象的概念十分相似，我们可以把镜像看作类，把容器看作类实例化后的对象。==\ndocker 的镜像概念类似虚拟机的镜像。是一个只读的模板，一个独立的文件系统，带有创建Docker容器的指令，可以用来创建新的容器。（  docker create <image -id > ：为指定的镜像添加一个可读写层，构成一个新的容器；）例如：一个镜像可以包含一个完整的ubuntu操作系统环境，里面仅安装了mysql或用户需要的其他应用程序。\ndocker镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为UnionFS( Union file system  统一文件系统)，镜像可以基于dockerfile构建，dockerfile是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。\n\ndocker提供了一个很简单的机制来创建镜像或更新现有的镜像。用户甚至可以从其他人那里下载一个已经做好的镜像直接使用。（镜像是只读的，可以理解为静态文件）\n\ndocker利用容器来运行应用：docker容器是由docker镜像创建的运行实例。docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。==可以把容器看作一个简易版的linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序==。\n\n  \n\n', '<h2 id=\"h2-docker-\"><a name=\"Docker概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker概念</h2><blockquote>\n<p>Docker is a platform for developers and sysadmins to build, run, and share applications with containers. The use of containers to deploy applications is called containerization. Containers are not new, but their use for easily deploying applications is.</p>\n</blockquote>\n<p>上面是<a href=\"https://docs.docker.com/get-started/\">Docker官方文档</a>中给出的定义，翻译之后就是：<br>Docker是一个供开发人员和系统管理员使用容器构建、运行和共享应用程序的平台。使用容器部署应用程序称为容器化。容器并不新鲜，但它们用于轻松部署应用程序却很新鲜。</p>\n<p>因此，要了解docker是什么，首先我们要理解<strong>容器</strong>的概念，而理解容器，我们还要了解<strong>容器</strong>和<strong>虚拟机</strong>的区别</p>\n<h2 id=\"h2-u5BB9u5668u548Cu865Au62DFu673A\"><a name=\"容器和虚拟机\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>容器和虚拟机</h2><p>上文中我们介绍了虚拟化技术，了解了虚拟化架构之后，我们就可以很清楚的区分<strong>容器</strong>和<strong>虚拟机</strong>的概念<br>我们用的传统虚拟机如 VMware ， VisualBox 之类的是全虚拟化架构，需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。每一台虚拟机包括应用，必要的二进制和库，以及一个完整的用户操作系统。</p>\n<p>而容器技术是基于操作系统层的虚拟化技术，容器和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。</p>\n<p>容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。通过使用容器，我们可以轻松打包应用程序的代码、配置和依赖关系，将其变成容易使用的构建块，从而实现环境一致性、运营效率、开发人员生产力和版本控制等诸多目标。容器可以帮助保证应用程序快速、可靠、一致地部署，其间不受部署环境的影响。容器还赋予我们对资源更多的精细化控制能力，让我们的基础设施效率更高。通过下面这幅图我们可以很直观的反映出这两者的区别所在<br><img src=\"https://img-blog.csdnimg.cn/20200307215606288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>容器的优点：</p>\n<ul>\n<li><p><strong>灵活</strong>:即使是最复杂的应用程序也可以被封装。</p>\n</li><li><p><strong>轻量级</strong>:容器利用和共享主机内核，使它们在系统资源方面比虚拟机更高效。</p>\n</li><li><p><strong>可移植性</strong>:您可以在本地构建、部署到云，并在任何地方运行。</p>\n</li><li><p><strong>松散耦合</strong>:容器是高度自给自足和封装的，允许您替换或升级一个容器而不破坏其他容器。</p>\n</li><li><p><strong>可伸缩</strong>:您可以增加并自动跨数据中心分发容器副本。</p>\n</li><li><p><strong>安全</strong>:容器对进程应用主动约束和隔离，而不需要用户进行任何配置。</p>\n</li></ul>\n<p>我们可以从下面这张表格很清楚地看到容器相比于传统虚拟机的特性的优势所在：<br>|特性  |容器  | 虚拟机|<br>|—|—|—|<br>|启动|    秒级    |分钟级|<br>|硬盘使用    |一般为MB|    一般为GB|<br>|性能|    接近原生|    弱于|<br>|系统支持量|    单机支持上千个容器|    一般是几十个|</p>\n<h2 id=\"h2-docker-\"><a name=\"Docker定位\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker定位</h2><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离，相当于是在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。<br>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker ，就不用担心环境问题。<br>总体来说， Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>\n<p>Docker相比于传统虚拟化方式具有更多的优势：</p>\n<ul>\n<li>docker 启动快速属于秒级别。虚拟机通常需要几分钟去启动</li><li>docker 需要的资源更少， docker 在操作系统级别进行虚拟化， docker 容器和内核交互，几乎没有性能损耗，性能优于通过 Hypervisor 层与内核层的虚拟化</li><li>docker 更轻量， docker 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境，  Docker 运行的镜像数远多于虚拟机数量，对系统的利用率非常高<br>与虚拟机相比， docker 隔离性更弱， docker 属于进程之间的隔离，虚拟机可实现系统级别隔离</li><li>安全性： docker 的安全性也更弱。 Docker 的租户 root 和宿主机 root 等同，一旦容器内的用户从普通用户权限提升为root权限，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户 root 权限和宿主机的 root 虚拟机权限是分离的，并且虚拟机利用如 Intel 的 VT-d 和 VT-x 的 ring-1 硬件隔离技术，这种隔离技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离，这使得容器容易受到攻击</li><li>可管理性： docker 的集中化管理工具还不算成熟。各种虚拟化技术都有成熟的管理工具，例如 VMware vCenter 提供完备的虚拟机管理能力</li><li>高可用和可恢复性： docker 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， VMware 可承诺虚拟机 99.999% 高可用，保证业务连续性</li><li>快速创建、删除：虚拟化创建是分钟级别的， Docker 容器创建是秒级别的， Docker 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间<br>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 Docker 在 Dockerfile 中记录了容器构建过程，可在集群中实现快速分发和快速部署</li></ul>\n<h2 id=\"h2-docker-\"><a name=\"Docker三要素\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker三要素</h2><p><img src=\"https://img-blog.csdnimg.cn/2020030822421362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>从上图我们可以看到，Docker 中包括三个基本的要素：</p>\n<ol>\n<li>Repository(仓库)</li><li>Image(镜像)</li><li>Container(容器)</li></ol>\n<h3 id=\"h3-repository-\"><a name=\"Repository（仓库）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Repository（仓库）</h3><p>仓库的概念很好理解，Docker 仓库是集中存放镜像文件的场所。如果使用了git和github就很容易理解docker的仓库概念。docker仓库概念和git类似。</p>\n<p>docker提供了一个注册服务器（register）来保存多个仓库，每个仓库又可以包含多个具备不同tag的镜像，</p>\n<p>docker运作中使用的默认仓库是<a href=\"https://hub.docker.com/\">docker hub</a>公共仓库。</p>\n<p>仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用push命令将它上传到共有或者私有的仓库。这样下次再另外一台机器上使用这个镜像的时候只需要从仓库里面pull下来就可以了。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签.。</p>\n<h3 id=\"h3-image-container-\"><a name=\"Image(镜像)和Container(容器)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Image(镜像)和Container(容器)</h3><p><img src=\"https://img-blog.csdnimg.cn/20200308223245737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>Fundamentally, a container is nothing but a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers. One of the most important aspects of container isolation is that each container interacts with its own private filesystem; this filesystem is provided by a Docker image. An image includes everything needed to run an application - the code or binary, runtimes, dependencies, and any other filesystem objects required.<br>容器只是一个正在运行的进程，为了使它与主机和其他容器隔离，在其上应用了一些附加的封装特性。容器隔离最重要的方面之一是每个容器都与自己的私有文件系统进行交互;此文件系统由Docker镜像提供。镜像包含运行应用程序所需的所有东西——代码或二进制文件、运行时、依赖项以及所需的任何其他文件系统对象。</p>\n</blockquote>\n<p>镜像是文件, 容器是进程。 容器是基于镜像创建的, 即容器中的进程依赖于镜像中的文件, 这里的文件包括进程运行所需要的可执行文件， 依赖软件， 库文件， 配置文件等等…<br>相对于镜像来说容器是动态的，容器的定义和镜像几乎一样，唯一的区别是容器在启动的时候创建了一层可写层次作为最上层。（   docker create &lt;image -id &gt; ：为指定的镜像添加一个可读写层，构成一个新的容器；）<br>==注：容器是由镜像实例化而来，这和我们学习的面向对象的概念十分相似，我们可以把镜像看作类，把容器看作类实例化后的对象。==<br>docker 的镜像概念类似虚拟机的镜像。是一个只读的模板，一个独立的文件系统，带有创建Docker容器的指令，可以用来创建新的容器。（  docker create &lt;image -id &gt; ：为指定的镜像添加一个可读写层，构成一个新的容器；）例如：一个镜像可以包含一个完整的ubuntu操作系统环境，里面仅安装了mysql或用户需要的其他应用程序。<br>docker镜像实际上是由一层一层的系统文件组成，这种层级的文件系统被称为UnionFS( Union file system  统一文件系统)，镜像可以基于dockerfile构建，dockerfile是一个描述文件，里面包含了若干条密令，每条命令都会对基础文件系统创建新的层次结构。</p>\n<p>docker提供了一个很简单的机制来创建镜像或更新现有的镜像。用户甚至可以从其他人那里下载一个已经做好的镜像直接使用。（镜像是只读的，可以理解为静态文件）</p>\n<p>docker利用容器来运行应用：docker容器是由docker镜像创建的运行实例。docker容器类似虚拟机，可以执行包含启动，停止，删除等。每个容器间是相互隔离的。容器中会运行特定的运用，包含特定应用的代码及所需的依赖文件。==可以把容器看作一个简易版的linux环境（包含root用户权限，进程空间，用户空间和网络空间等）和运行在其中的应用程序==。</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/13.jpg', '/article/102', 43, '2020-09-19', NULL, 0, 101, 103, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (103, 'Docker入门：（三）Dokcer的安装与卸载', '您可以从仓库安装和更新Docker,Docker安装Docker分为CE和EE两大版本,事务检查错误Docker卸载删除yum已经安装的安装包搜索yumlistinstalled|grepdocker删除yum-yremovedocker-ce-cli.x86_64\\&gt', '## Docker 安装\nDocker 分为 CE 和 EE 两大版本。 CE 即社区版（免费，支持周期 7 个月）， EE 即企业版，强调安全，付费使用，支持周期 24 个月。\n\n我们在安装前可以参看[官方文档](https://docs.docker.com/install/)获取最新的 Docker 支持情况。\n### 前提\nDocker 支持以下的 64 位 CentOS 版本：\n\n+ CentOS 7\n+ CentOS 8\n+ 更高版本...\n\nDocker 要求操作系统必须为64位，且centos内核版本为3.10及以上，可以使用下面命令查看\n```java\nuname -r\n```\n\n### 卸载旧版本\n```java\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n### 安装 Docker Engine-Community\n在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。\n\n#### 设置仓库\n```java\nsudo yum install -y yum-utils \\\ndevice-mapper-persistent-data \\\nlvm2\n```\n#### 使用以下命令来设置稳定的仓库。\n```java\nsudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo \n```\n==注：此处与官网不同，因为官方仓库在国外，国内下载很慢，所以我们可以使用阿里镜像仓库==\n\n#### 安装docker引擎\n```java\nsudo yum install docker-ce docker-ce-cli containerd.io\n```\n安装完成后，运行`docker version`或者`docker info`命令，验证是否安装成功，返回docker的版本相关信息，证明 docker 安装成功\n\n设置docker开机自启\n```java\nsystemctl enable docker\n```\n启动docker\n```java\nsystemctl start docker\n```\n查看docker状态\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314141533917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n安装时出现下面错误，更新一下`sudo yum update`,然后重新安装\n\n>下载的软件包保存在缓存中，直到下次成功执行事务。\n您可以通过执行 ‘dnf clean packages’ 删除软件包缓存。\n错误：事务检查错误\n\n## Docker卸载\n#### 删除yum已经安装的安装包\n 搜索\n```java\nyum list installed | grep docker\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314142043300.png)\n 删除\n```java\nyum -y remove docker-ce-cli.x86_64\\\n> yum -y remove docker-ce.x86_64\\\n> yum -y remove containerd.io.x86_64\n```\n\n#### 再删除rpm安装的安装包\n 搜索\n```java\nrpm -qa | grep docker\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314143722507.png)\n删除\n```java\nrpm -e docker-ce-cli-19.03.8-3.el7.x86_64\\\n> docker-ce-19.03.8-3.el7.x86_64\n```\n#### 删除Docker镜像\n```java\nrm -rf /var/lib/docker\n```\n', '<h2 id=\"h2-docker-\"><a name=\"Docker 安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker 安装</h2><p>Docker 分为 CE 和 EE 两大版本。 CE 即社区版（免费，支持周期 7 个月）， EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>\n<p>我们在安装前可以参看<a href=\"https://docs.docker.com/install/\">官方文档</a>获取最新的 Docker 支持情况。</p>\n<h3 id=\"h3-u524Du63D0\"><a name=\"前提\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>前提</h3><p>Docker 支持以下的 64 位 CentOS 版本：</p>\n<ul>\n<li>CentOS 7</li><li>CentOS 8</li><li>更高版本…</li></ul>\n<p>Docker 要求操作系统必须为64位，且centos内核版本为3.10及以上，可以使用下面命令查看</p>\n<pre><code class=\"lang-java\">uname -r\n</code></pre>\n<h3 id=\"h3-u5378u8F7Du65E7u7248u672C\"><a name=\"卸载旧版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>卸载旧版本</h3><pre><code class=\"lang-java\">sudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n</code></pre>\n<h3 id=\"h3--docker-engine-community\"><a name=\"安装 Docker Engine-Community\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装 Docker Engine-Community</h3><p>在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。</p>\n<h4 id=\"h4-u8BBEu7F6Eu4ED3u5E93\"><a name=\"设置仓库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设置仓库</h4><pre><code class=\"lang-java\">sudo yum install -y yum-utils \\\ndevice-mapper-persistent-data \\\nlvm2\n</code></pre>\n<h4 id=\"h4--\"><a name=\"使用以下命令来设置稳定的仓库。\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>使用以下命令来设置稳定的仓库。</h4><pre><code class=\"lang-java\">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n</code></pre>\n<p>==注：此处与官网不同，因为官方仓库在国外，国内下载很慢，所以我们可以使用阿里镜像仓库==</p>\n<h4 id=\"h4--docker-\"><a name=\"安装docker引擎\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装docker引擎</h4><pre><code class=\"lang-java\">sudo yum install docker-ce docker-ce-cli containerd.io\n</code></pre>\n<p>安装完成后，运行<code>docker version</code>或者<code>docker info</code>命令，验证是否安装成功，返回docker的版本相关信息，证明 docker 安装成功</p>\n<p>设置docker开机自启</p>\n<pre><code class=\"lang-java\">systemctl enable docker\n</code></pre>\n<p>启动docker</p>\n<pre><code class=\"lang-java\">systemctl start docker\n</code></pre>\n<p>查看docker状态<br><img src=\"https://img-blog.csdnimg.cn/20200314141533917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>安装时出现下面错误，更新一下<code>sudo yum update</code>,然后重新安装</p>\n<blockquote>\n<p>下载的软件包保存在缓存中，直到下次成功执行事务。<br>您可以通过执行 ‘dnf clean packages’ 删除软件包缓存。<br>错误：事务检查错误</p>\n</blockquote>\n<h2 id=\"h2-docker-\"><a name=\"Docker卸载\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker卸载</h2><h4 id=\"h4--yum-\"><a name=\"删除yum已经安装的安装包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除yum已经安装的安装包</h4><p> 搜索</p>\n<pre><code class=\"lang-java\">yum list installed | grep docker\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200314142043300.png\" alt=\"在这里插入图片描述\"><br> 删除</p>\n<pre><code class=\"lang-java\">yum -y remove docker-ce-cli.x86_64\\\n&gt; yum -y remove docker-ce.x86_64\\\n&gt; yum -y remove containerd.io.x86_64\n</code></pre>\n<h4 id=\"h4--rpm-\"><a name=\"再删除rpm安装的安装包\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>再删除rpm安装的安装包</h4><p> 搜索</p>\n<pre><code class=\"lang-java\">rpm -qa | grep docker\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200314143722507.png\" alt=\"在这里插入图片描述\"><br>删除</p>\n<pre><code class=\"lang-java\">rpm -e docker-ce-cli-19.03.8-3.el7.x86_64\\\n&gt; docker-ce-19.03.8-3.el7.x86_64\n</code></pre>\n<h4 id=\"h4--docker-\"><a name=\"删除Docker镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除Docker镜像</h4><pre><code class=\"lang-java\">rm -rf /var/lib/docker\n</code></pre>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/1.jpg', '/article/103', 43, '2020-09-19', NULL, 0, 102, 104, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (104, 'Docker入门：（四）Dokcer常用命令', 'dockerkill[OPTIONS]CONTAINER[CONTAINER…]删除容器命令,启动并进入容器重启容器dockerrestart[OPTIONS]CONTAINER[CONTAINER…]停止容器停止容器命令,帮助命令查看docker版本信息命令', '## 帮助命令\n### 查看docker版本信息\n命令：docker version\n\n### 查看docker运行信息\n命令：docker info\n\n### 帮助命令\n含义: docker [Command] --help （如果不写命令，查询出所有命令信息）\n\n## 镜像命令\n### 镜像列表\n命令：docker images [OPTIONS] [REPOSITORY[:TAG]]\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020031416324528.png)\n+ REPOSITORY：表示镜像的仓库源\n+ TAG：标签（版本）\n+ IMAGE ID：镜像ID\n+ CREATED：镜像创建时间\n+ SIZE：镜像大小\n\nOPTIONS：（可以使用docker --help images查看详细内容）\n+  -a：显示所有镜像（docker默认隐藏中间镜像）\n+  -q：只显示镜像id\n+  -\\-digests ：显示摘要信息\n+  -\\-no-trunc：不要截断输出 \n\n### 查询镜像 \n命令：docker search [OPTIONS] TERM\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314165239531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n+ NAME：镜像名称\n+ DESCRIPTION：镜像描述\n+ STARS：星\n+ OFFICIAL：官方版\n+ AUTOMATED：自动构建的\n\n常用的过滤命令：\ndocker search -s 30 mysql 可以查询starts 30以上的镜像\n\n### 拉取镜像\n命令：docker pull [OPTIONS] NAME[:TAG|@DIGEST] （不写版本号默认是最新的版本:latest）\n\nOPTIONS：\n + -a：下载存储库中所有标记的图像\n  + -q：不在控制台输出下载信息\n   +  -\\-disable-content-trust   跳过图像验证(默认为true)\n\n### 删除镜像\n含义：docker rmi [OPTIONS] IMAGE [IMAGE...]\n\nOPTIONS：\n + -f：强制删除\n \n扩展：\n + 删除多个\n docker rmi -f 镜像1 镜像2 ...\n  + 删除全部\n docker rmi -f $(docker images -qa)\n ==docker images -qa 表示查询所有镜像id，将查询的id返回给rmi命令==\n\n## 容器命令\n### 新建并启动容器\n命令：docker run [OPTIONS] IMAGE [COMMAND] [ARG...]\nOPTIONS（常用）：\n + -d：启动守护式容器（后台运行，并返回容器id）\n + -i：启动交护式容器（通常与-t同时使用）\n + -t：为docker分配一个伪终端工具操作容器（tty终端，通常与-i同时使用）\n +  -\\-name：指定容器名称（唯一）\n\n注意：docker创建守护式容器时要注意，docker有个机制，当docker容器后台运行时，必须有一个前台进行与它交互，否则，docker后台进程会自动回收\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314214245742.png)\n如上图所示，启动后台进程容器后，查看容器，却并没有，我们可以使用shell脚本，保持进程与前台仅从交互，如下图所示，这样就可以保持容器在后台进行\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314214702799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n### 容器列表\n命令： docker ps [OPTIONS]\n\nOPTIONS（常用）：\n + -a：列出当前所有正在运行的容器+历史上运行的容器\n + -l：显示最近创建的容器\n + -n num：显示最近n个创建的容器\n +  -q：静默模式，只返回容器id\n +  -\\-no-trunc：不截断输出\n\n### 退出容器\n#### 退出并停止容器\n命令：exit\n#### 退出不停止容器\n命令：Ctrl+P+Q\n### 启动容器\n命令：docker start [OPTIONS] CONTAINER [CONTAINER...]\nOptions:\n\n+  -i：启动并进入容器\n\n### 重启容器\n docker restart [OPTIONS] CONTAINER [CONTAINER...]\n### 停止容器\n#### 停止容器\n命令：docker stop [OPTIONS] CONTAINER [CONTAINER...]\nOptions:\n+   -t num：num秒之后停止容器（默认10)\n\n#### 强制停止\n命令：docker kill [OPTIONS] CONTAINER [CONTAINER...]\n### 删除容器\n命令：docker rm [OPTIONS] CONTAINER [CONTAINER...]\nOptions:\n+ -f：强制移除正在运行的容器\n\n+ -l：删除指定的链接\n\n+ -v：删除与容器关联的匿名卷\n\n删除所有容器 docker rm -f  $(docker ps -qa)  或者 docker ps -qa | xages docker rm\n\n\n上面新建命令我们可以知道，如果我们想创建一个守护式容器，可以使用命令：\n```java\n$ docker run -d image\n```\n### 查看容器日志\n命令：docker logs [OPTIONS] CONTAINER\nOptions:\n+ -t：显示时间\n+ -f：跟踪日志输出（动态显示）\n+    -\\-details ：显示提供给日志的额外细节\n+  -\\-tail num：从日志末尾显示的行数\n\n### 查看容器内运行情况\n命令:  docker top CONTAINER [ps OPTIONS]\n\n### 查看容器内部细节\n命令：docker inspect [OPTIONS] NAME|ID [NAME|ID...]\n\n==以Json串的形式返回容器内部细节==\n\n### 进入正在运行的容器进行交互\n命令：docker attach [OPTIONS] CONTAINER\n命令：docker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n\n区别：attach 直接进入容器\n`exec -it CONTAINER /bin/bash`可以直接进入容器，相当于attach\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314212213502.png)\nexec也可以不进入容器而只执行命令，相当于在容器内执行命令并将命令返回到宿主机\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314211927778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n### 从容器内拷贝文件到宿主机\n docker cp [OPTIONS] CONTAINER:文件路径 目标路径\n        \n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314213546469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n', '<h2 id=\"h2-u5E2Eu52A9u547Du4EE4\"><a name=\"帮助命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>帮助命令</h2><h3 id=\"h3--docker-\"><a name=\"查看docker版本信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看docker版本信息</h3><p>命令：docker version</p>\n<h3 id=\"h3--docker-\"><a name=\"查看docker运行信息\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看docker运行信息</h3><p>命令：docker info</p>\n<h3 id=\"h3-u5E2Eu52A9u547Du4EE4\"><a name=\"帮助命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>帮助命令</h3><p>含义: docker [Command] —help （如果不写命令，查询出所有命令信息）</p>\n<h2 id=\"h2-u955Cu50CFu547Du4EE4\"><a name=\"镜像命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>镜像命令</h2><h3 id=\"h3-u955Cu50CFu5217u8868\"><a name=\"镜像列表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>镜像列表</h3><p>命令：docker images [OPTIONS] [REPOSITORY[:TAG]]<br><img src=\"https://img-blog.csdnimg.cn/2020031416324528.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>REPOSITORY：表示镜像的仓库源</li><li>TAG：标签（版本）</li><li>IMAGE ID：镜像ID</li><li>CREATED：镜像创建时间</li><li>SIZE：镜像大小</li></ul>\n<p>OPTIONS：（可以使用docker —help images查看详细内容）</p>\n<ul>\n<li>-a：显示所有镜像（docker默认隐藏中间镜像）</li><li>-q：只显示镜像id</li><li>--digests ：显示摘要信息</li><li>--no-trunc：不要截断输出 </li></ul>\n<h3 id=\"h3-u67E5u8BE2u955Cu50CF\"><a name=\"查询镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查询镜像</h3><p>命令：docker search [OPTIONS] TERM<br><img src=\"https://img-blog.csdnimg.cn/20200314165239531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>NAME：镜像名称</li><li>DESCRIPTION：镜像描述</li><li>STARS：星</li><li>OFFICIAL：官方版</li><li>AUTOMATED：自动构建的</li></ul>\n<p>常用的过滤命令：<br>docker search -s 30 mysql 可以查询starts 30以上的镜像</p>\n<h3 id=\"h3-u62C9u53D6u955Cu50CF\"><a name=\"拉取镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>拉取镜像</h3><p>命令：docker pull [OPTIONS] NAME[:TAG|<a href=\"https://github.com/DIGEST\" title=\"&#64;DIGEST\" class=\"at-link\">@DIGEST</a>] （不写版本号默认是最新的版本:latest）</p>\n<p>OPTIONS：</p>\n<ul>\n<li>-a：下载存储库中所有标记的图像<ul>\n<li>-q：不在控制台输出下载信息</li><li>--disable-content-trust   跳过图像验证(默认为true)</li></ul>\n</li></ul>\n<h3 id=\"h3-u5220u9664u955Cu50CF\"><a name=\"删除镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除镜像</h3><p>含义：docker rmi [OPTIONS] IMAGE [IMAGE…]</p>\n<p>OPTIONS：</p>\n<ul>\n<li>-f：强制删除</li></ul>\n<p>扩展：</p>\n<ul>\n<li>删除多个<br>docker rmi -f 镜像1 镜像2 …<ul>\n<li>删除全部<br>docker rmi -f $(docker images -qa)<br>==docker images -qa 表示查询所有镜像id，将查询的id返回给rmi命令==</li></ul>\n</li></ul>\n<h2 id=\"h2-u5BB9u5668u547Du4EE4\"><a name=\"容器命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>容器命令</h2><h3 id=\"h3-u65B0u5EFAu5E76u542Fu52A8u5BB9u5668\"><a name=\"新建并启动容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>新建并启动容器</h3><p>命令：docker run [OPTIONS] IMAGE [COMMAND] [ARG…]<br>OPTIONS（常用）：</p>\n<ul>\n<li>-d：启动守护式容器（后台运行，并返回容器id）</li><li>-i：启动交护式容器（通常与-t同时使用）</li><li>-t：为docker分配一个伪终端工具操作容器（tty终端，通常与-i同时使用）</li><li>--name：指定容器名称（唯一）</li></ul>\n<p>注意：docker创建守护式容器时要注意，docker有个机制，当docker容器后台运行时，必须有一个前台进行与它交互，否则，docker后台进程会自动回收<br><img src=\"https://img-blog.csdnimg.cn/20200314214245742.png\" alt=\"在这里插入图片描述\"><br>如上图所示，启动后台进程容器后，查看容器，却并没有，我们可以使用shell脚本，保持进程与前台仅从交互，如下图所示，这样就可以保持容器在后台进行<br><img src=\"https://img-blog.csdnimg.cn/20200314214702799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"h3-u5BB9u5668u5217u8868\"><a name=\"容器列表\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>容器列表</h3><p>命令： docker ps [OPTIONS]</p>\n<p>OPTIONS（常用）：</p>\n<ul>\n<li>-a：列出当前所有正在运行的容器+历史上运行的容器</li><li>-l：显示最近创建的容器</li><li>-n num：显示最近n个创建的容器</li><li>-q：静默模式，只返回容器id</li><li>--no-trunc：不截断输出</li></ul>\n<h3 id=\"h3-u9000u51FAu5BB9u5668\"><a name=\"退出容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>退出容器</h3><h4 id=\"h4-u9000u51FAu5E76u505Cu6B62u5BB9u5668\"><a name=\"退出并停止容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>退出并停止容器</h4><p>命令：exit</p>\n<h4 id=\"h4-u9000u51FAu4E0Du505Cu6B62u5BB9u5668\"><a name=\"退出不停止容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>退出不停止容器</h4><p>命令：Ctrl+P+Q</p>\n<h3 id=\"h3-u542Fu52A8u5BB9u5668\"><a name=\"启动容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动容器</h3><p>命令：docker start [OPTIONS] CONTAINER [CONTAINER…]<br>Options:</p>\n<ul>\n<li>-i：启动并进入容器</li></ul>\n<h3 id=\"h3-u91CDu542Fu5BB9u5668\"><a name=\"重启容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>重启容器</h3><p> docker restart [OPTIONS] CONTAINER [CONTAINER…]</p>\n<h3 id=\"h3-u505Cu6B62u5BB9u5668\"><a name=\"停止容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止容器</h3><h4 id=\"h4-u505Cu6B62u5BB9u5668\"><a name=\"停止容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>停止容器</h4><p>命令：docker stop [OPTIONS] CONTAINER [CONTAINER…]<br>Options:</p>\n<ul>\n<li>-t num：num秒之后停止容器（默认10)</li></ul>\n<h4 id=\"h4-u5F3Au5236u505Cu6B62\"><a name=\"强制停止\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>强制停止</h4><p>命令：docker kill [OPTIONS] CONTAINER [CONTAINER…]</p>\n<h3 id=\"h3-u5220u9664u5BB9u5668\"><a name=\"删除容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>删除容器</h3><p>命令：docker rm [OPTIONS] CONTAINER [CONTAINER…]<br>Options:</p>\n<ul>\n<li><p>-f：强制移除正在运行的容器</p>\n</li><li><p>-l：删除指定的链接</p>\n</li><li><p>-v：删除与容器关联的匿名卷</p>\n</li></ul>\n<p>删除所有容器 docker rm -f  $(docker ps -qa)  或者 docker ps -qa | xages docker rm</p>\n<p>上面新建命令我们可以知道，如果我们想创建一个守护式容器，可以使用命令：</p>\n<pre><code class=\"lang-java\">$ docker run -d image\n</code></pre>\n<h3 id=\"h3-u67E5u770Bu5BB9u5668u65E5u5FD7\"><a name=\"查看容器日志\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看容器日志</h3><p>命令：docker logs [OPTIONS] CONTAINER<br>Options:</p>\n<ul>\n<li>-t：显示时间</li><li>-f：跟踪日志输出（动态显示）</li><li>--details ：显示提供给日志的额外细节</li><li>--tail num：从日志末尾显示的行数</li></ul>\n<h3 id=\"h3-u67E5u770Bu5BB9u5668u5185u8FD0u884Cu60C5u51B5\"><a name=\"查看容器内运行情况\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看容器内运行情况</h3><p>命令:  docker top CONTAINER [ps OPTIONS]</p>\n<h3 id=\"h3-u67E5u770Bu5BB9u5668u5185u90E8u7EC6u8282\"><a name=\"查看容器内部细节\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看容器内部细节</h3><p>命令：docker inspect [OPTIONS] NAME|ID [NAME|ID…]</p>\n<p>==以Json串的形式返回容器内部细节==</p>\n<h3 id=\"h3-u8FDBu5165u6B63u5728u8FD0u884Cu7684u5BB9u5668u8FDBu884Cu4EA4u4E92\"><a name=\"进入正在运行的容器进行交互\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>进入正在运行的容器进行交互</h3><p>命令：docker attach [OPTIONS] CONTAINER<br>命令：docker exec [OPTIONS] CONTAINER COMMAND [ARG…]</p>\n<p>区别：attach 直接进入容器<br><code>exec -it CONTAINER /bin/bash</code>可以直接进入容器，相当于attach<br><img src=\"https://img-blog.csdnimg.cn/20200314212213502.png\" alt=\"在这里插入图片描述\"><br>exec也可以不进入容器而只执行命令，相当于在容器内执行命令并将命令返回到宿主机<br><img src=\"https://img-blog.csdnimg.cn/20200314211927778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"h3-u4ECEu5BB9u5668u5185u62F7u8D1Du6587u4EF6u5230u5BBFu4E3Bu673A\"><a name=\"从容器内拷贝文件到宿主机\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>从容器内拷贝文件到宿主机</h3><p> docker cp [OPTIONS] CONTAINER:文件路径 目标路径</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200314213546469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/15.jpg', '/article/104', 43, '2020-09-19', NULL, 0, 103, 105, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (105, 'Docker入门：（五）容器数据券', '子容器中创建的文件也能共享到父容器中,我在父容器中创建的文件出现在了容器2中,容器数据券添加命令添加创建数据券$dockerrun-it-v/宿主机目录', '## 概念\nDocker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为数据卷（Data Volume）。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。\n\nDocker的理念将运行的环境打包形成容器运行，运行可以伴随容器，但是我们对数据的要求是希望持久化，容器之间可以共享数据，Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据作为容器的一部分保存下来，那么当容器被删除之后，数据也就没了，为了能够保存数据，在docker容器中使用卷。\n\n数据卷呈现给Docker容器的形式就是一个目录，支持多个容器间共享，不属于联合文件系统，修改也不会影响镜像。使用Docker的数据卷，类似在系统中使用 mount 挂载一个文件系统。\n\n卷的设计目的就是数据的持久化，完全独立与容器的生命周期，因此Docker不会在容器删除时删除其挂载的数据卷。\n特点：\n  \n 1.  数据卷可以在容器之间共享和重用数据。\n 2. 卷的更改可以直接生效。\n 3. 数据卷的更改不会包含在镜像的更新中。\n 4. 数据卷的生命周期一直持续到没有容器使用它为止。\n\n## 容器数据券添加\n\n### 命令添加\n\n#### 创建数据券\n> $ docker run -it -v /宿主机目录:/容器目录 镜像名\n\n执行命令后，在宿主机和容器创建数据券目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200325204229159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n使用命令 `docker inspect 6946198b2e8c`查看数据券是否挂载成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020032520460583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n挂载成功后，就可以实现容器和宿主机之间的数据共享，在容器内操作的数据会同步到宿主机，在宿主机操作的数据也会同步到容器\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200325204904691.png)\n#### 数据券权限\n> $ docker run -it -v /宿主机目录:/容器目录:ro 镜像名\n\n在容器目录后加:ro（readonly），是创建只读数据券，这样只允许宿主机单向操作数据券，而容器内不能操作数据券\n\n### DockerFile添加\n出于可移植和分享的考虑，用-v主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能保证在所有的宿主机上都存在这样的特定目录\nDockerFile可以使用VOLUME指令给镜像添加一个或者多个数据券\n\n#### 1.DockerFile的构建\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326213140465.png)\n该DockerFile表示基于centos，创建两个数据卷，并打印“start my docker image...”，然后执行/bin/bash\n\n该DokcerFile含义类似于==docker run -it -v /host1:/dataVolumeContainer1 -v /host2:/dataVolumeContainer2 centos /bin/bash==\n\n#### 2.build后生成镜像\n命令：docker build [OPTIONS] PATH | URL | -\n\nOptions:\n-f 后缀dockerfile文件路径\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326214426852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n执行build命令，创建镜像，可以看到，控制台打印了“start my docker image...”\n如图创建镜像成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326214520594.png)\n#### 3. 使用镜像运行容器\n创建镜像之后，我们就可以使用`docker run`来运行容器\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326214655512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n运行之后，查看目录，发现容器券创建成功，但是这时候有个问题，我们在命令添加数据券的时候指定了宿主机的目录，可以和容器内数据券目录共享，但是用dockerfile执行因为没有指定宿主机目录，那容器数据券如何共享呢？实际上docker给我们创建了默认的宿主机目录\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200326215744605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n**注**： 如果碰到Dokcer挂载主机目录Docker访问出现cannot opendirectory ..Permission denied 在挂载目录后加上 --privileged=true参数即可\n\n## 数据卷容器\n\n命名的容器挂载数据卷，其他容器通过挂载这个容器（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器\n数据卷共享命令：--volumes-from\n创建第一个容器，容器内创建容器数据卷，在数据卷内创建一个文件，这个容器就是数据卷容器\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200331212533863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n我们以第一个容器作为父容器，创建二个容器\n```java\ndocker run -it --name container02 --volumes-from container01 wmx/centos\ndocker run -it --name container03 --volumes-from container01 wmx/centos\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200331213945442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n从上图我们可以看出，我在父容器中创建的文件出现在了容器2中，容器2中创建的文件也出现在了容器3中，我们在容器3（子容器）中创建的文件，也出现在了容器1中，可见，并不是只有父容器可以向子容器共享文件，子容器中创建的文件也能共享到父容器中。而且即使我们删除父容器，因为数据已经共享到子容器，也不会影响数据\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200331214344227.png)\n', '<h2 id=\"h2-u6982u5FF5\"><a name=\"概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>概念</h2><p>Docker中的数据可以存储在类似于虚拟机磁盘的介质中，在Docker中称为数据卷（Data Volume）。数据卷可以用来存储Docker应用的数据，也可以用来在Docker容器间进行数据共享。</p>\n<p>Docker的理念将运行的环境打包形成容器运行，运行可以伴随容器，但是我们对数据的要求是希望持久化，容器之间可以共享数据，Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据作为容器的一部分保存下来，那么当容器被删除之后，数据也就没了，为了能够保存数据，在docker容器中使用卷。</p>\n<p>数据卷呈现给Docker容器的形式就是一个目录，支持多个容器间共享，不属于联合文件系统，修改也不会影响镜像。使用Docker的数据卷，类似在系统中使用 mount 挂载一个文件系统。</p>\n<p>卷的设计目的就是数据的持久化，完全独立与容器的生命周期，因此Docker不会在容器删除时删除其挂载的数据卷。<br>特点：\n  </p>\n<ol>\n<li>数据卷可以在容器之间共享和重用数据。</li><li>卷的更改可以直接生效。</li><li>数据卷的更改不会包含在镜像的更新中。</li><li>数据卷的生命周期一直持续到没有容器使用它为止。</li></ol>\n<h2 id=\"h2-u5BB9u5668u6570u636Eu5238u6DFBu52A0\"><a name=\"容器数据券添加\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>容器数据券添加</h2><h3 id=\"h3-u547Du4EE4u6DFBu52A0\"><a name=\"命令添加\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>命令添加</h3><h4 id=\"h4-u521Bu5EFAu6570u636Eu5238\"><a name=\"创建数据券\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建数据券</h4><blockquote>\n<p>$ docker run -it -v /宿主机目录:/容器目录 镜像名</p>\n</blockquote>\n<p>执行命令后，在宿主机和容器创建数据券目录<br><img src=\"https://img-blog.csdnimg.cn/20200325204229159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>使用命令 <code>docker inspect 6946198b2e8c</code>查看数据券是否挂载成功<br><img src=\"https://img-blog.csdnimg.cn/2020032520460583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>挂载成功后，就可以实现容器和宿主机之间的数据共享，在容器内操作的数据会同步到宿主机，在宿主机操作的数据也会同步到容器<br><img src=\"https://img-blog.csdnimg.cn/20200325204904691.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"h4-u6570u636Eu5238u6743u9650\"><a name=\"数据券权限\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据券权限</h4><blockquote>\n<p>$ docker run -it -v /宿主机目录:/容器目录:ro 镜像名</p>\n</blockquote>\n<p>在容器目录后加:ro（readonly），是创建只读数据券，这样只允许宿主机单向操作数据券，而容器内不能操作数据券</p>\n<h3 id=\"h3-dockerfile-\"><a name=\"DockerFile添加\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>DockerFile添加</h3><p>出于可移植和分享的考虑，用-v主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能保证在所有的宿主机上都存在这样的特定目录<br>DockerFile可以使用VOLUME指令给镜像添加一个或者多个数据券</p>\n<h4 id=\"h4-1-dockerfile-\"><a name=\"1.DockerFile的构建\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.DockerFile的构建</h4><p><img src=\"https://img-blog.csdnimg.cn/20200326213140465.png\" alt=\"在这里插入图片描述\"><br>该DockerFile表示基于centos，创建两个数据卷，并打印“start my docker image…”，然后执行/bin/bash</p>\n<p>该DokcerFile含义类似于==docker run -it -v /host1:/dataVolumeContainer1 -v /host2:/dataVolumeContainer2 centos /bin/bash==</p>\n<h4 id=\"h4-2-build-\"><a name=\"2.build后生成镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.build后生成镜像</h4><p>命令：docker build [OPTIONS] PATH | URL | -</p>\n<p>Options:<br>-f 后缀dockerfile文件路径<br><img src=\"https://img-blog.csdnimg.cn/20200326214426852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>执行build命令，创建镜像，可以看到，控制台打印了“start my docker image…”<br>如图创建镜像成功<br><img src=\"https://img-blog.csdnimg.cn/20200326214520594.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"h4-3-\"><a name=\"3. 使用镜像运行容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3. 使用镜像运行容器</h4><p>创建镜像之后，我们就可以使用<code>docker run</code>来运行容器<br><img src=\"https://img-blog.csdnimg.cn/20200326214655512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>运行之后，查看目录，发现容器券创建成功，但是这时候有个问题，我们在命令添加数据券的时候指定了宿主机的目录，可以和容器内数据券目录共享，但是用dockerfile执行因为没有指定宿主机目录，那容器数据券如何共享呢？实际上docker给我们创建了默认的宿主机目录<br><img src=\"https://img-blog.csdnimg.cn/20200326215744605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><strong>注</strong>： 如果碰到Dokcer挂载主机目录Docker访问出现cannot opendirectory ..Permission denied 在挂载目录后加上 —privileged=true参数即可</p>\n<h2 id=\"h2-u6570u636Eu5377u5BB9u5668\"><a name=\"数据卷容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据卷容器</h2><p>命名的容器挂载数据卷，其他容器通过挂载这个容器（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器<br>数据卷共享命令：—volumes-from<br>创建第一个容器，容器内创建容器数据卷，在数据卷内创建一个文件，这个容器就是数据卷容器<br><img src=\"https://img-blog.csdnimg.cn/20200331212533863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>我们以第一个容器作为父容器，创建二个容器</p>\n<pre><code class=\"lang-java\">docker run -it --name container02 --volumes-from container01 wmx/centos\ndocker run -it --name container03 --volumes-from container01 wmx/centos\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200331213945442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>从上图我们可以看出，我在父容器中创建的文件出现在了容器2中，容器2中创建的文件也出现在了容器3中，我们在容器3（子容器）中创建的文件，也出现在了容器1中，可见，并不是只有父容器可以向子容器共享文件，子容器中创建的文件也能共享到父容器中。而且即使我们删除父容器，因为数据已经共享到子容器，也不会影响数据<br><img src=\"https://img-blog.csdnimg.cn/20200331214344227.png\" alt=\"在这里插入图片描述\"></p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/14.jpg', '/article/105', 43, '2020-09-19', NULL, 0, 104, 106, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (106, 'Docker入门：（六）Dockerfile', 'Tomcat的Dockerfile中最后一行命令CMD[&quot,指定一个容器启动时要执行的命令DockerFile中可以有多个CMD命令,指定一个容器启动时要执行的命令目的和CMD一样', '## Dockerfile\n### 什么是Dockerfile\nDockerfile是用来构建Docker镜像的构建文件，是由一系列参数构成的脚本\n使用命令build来创建新的image，默认是当前目录下名为Dockerfile的文件，可以使用`-f 路径`来指定具体位置的文件 `-t 名称:target` 指定镜像名称和版本\n```java\n  docker build -f /dockerfiles/Dockerfile -t mycentos:1.0 .\n```\n\n### Dockerfile语法规则\n1. 每条保留字指令都必须是大写，且后面要跟随至少一个参数\n2. 指令按照从上到下顺序执行\n3. \\# 表示注释\n4. 每条指令都会创建一个新的镜像，并进行提交\n\n### Dockerfile保留字指令\n+ FROM：基础镜像，当前新镜像是基于哪个镜像，如果不以任何镜像为基础，那么写法为：FROM scratch。\n+ MAINTAINER：镜像维护者的姓名和邮箱\n+ RUN：容器构建的时候需要的命令\n+ EXPOSE：当前容器对外暴露出的端口号\n+ WORKDIR：指定在创建容器后，终端默认登录的进来工作目录，一个落脚点（创建容器后，进入容器终端的目录，不指定默认是根目录）\n+ ENV：用来在构建镜像的过程中设置环境变量\n+ ADD：将宿主机目录下的文件拷贝进镜像，且ADD命令会自动处理URL或者解压tar压缩包\n+ COPY：将从构建上下文的目录中<源路径>的文件/目录复制到新的一层镜像内的<目标路径>位置\n+ VOLUME：容器数据券，用于数据保存和持久化工作\n+ CMD：指定一个容器启动时要执行的命令\nDockerFile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换\n+ ENTRYPOINT：指定一个容器启动时要执行的命令\n目的和CMD一样，都是在指定容器启动程序及参数，不同的是docker run之后的参数是在ENTRYPOINT之后追加\n+ ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后，父镜像的onbuild被触发\n\n## Dockerfile构建案例\n### 自定义centos\n![](https://img-blog.csdnimg.cn/20200331181557662.png)\n需求：我们运行官方的centos之后，默认的路径是根目录，且不支持vim命令和ifconfig命令，我们可以使用Dockerfile自定义一个centos镜像，默认路径是/usr/local，且支持vim命令和ifconfig命令\n\nDockerfile编写\n```java\nFROM centos\nMAINTAINER wmx<1130@qq.com>\n\n#定义环境变量\nENV MYPATH /usr/local\n#定义默认的工作目录\nWORKDIR $MYPATH\n\n#运行命令 安装vim和net-tools\nRUN yum -y install vim\nRUN yum -y install net-tools\n\n#对外暴露的端口号\nEXPOSE 80\n\nCMD echo $MYPATH\nCMD echo \"my centos run sunccess ......\"\nCMD /bin/bash\n\n```\n使用build命令创建镜像\n```java\ndocker build -t mycentos:1.0 .\n```\n![](https://img-blog.csdnimg.cn/2020033118430819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\nmycentos镜像创建成功，运行mycentos\n```java\ndocker run -it mycentos:1.0 .\n```\n默认目录在/usr/local，并且可以使用vim和ifconfig命令\n![](https://img-blog.csdnimg.cn/20200331184555751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n###  CMD和ENTRYPOINT\n\n我们从上面保留字介绍中可以知道，DockerFile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换，我们来进行一下测试\n\n\n我们使用Tomcat做一下测试，Tomcat的Dockerfile中最后一行命令\n```java\nCMD [\"catalina.sh\", \"run\"]\n```\n我们启动Tomcat时，最后执行了Tomcat的启动命令，所以当我们运行Tomcat容器后，可以直接访问Tomcat\n![](https://img-blog.csdnimg.cn/20200331215644583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![](https://img-blog.csdnimg.cn/20200331215721401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n但是如果我们在启动Tomcat容器时，加上其他命令，就会导致启动Tomcat命令被覆盖而失效\n如下，比如我们加上ls -l命令，命令正确执行，列出了Tomcat目录下的文件，但是访问Tomcat发现无法访问，Tomcat被没有成功的启动\n![](https://img-blog.csdnimg.cn/20200331215852468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![](https://img-blog.csdnimg.cn/20200331220059954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n###  自定义Tomcat\n创建Dockerfile文件\n```java\nFROM centos\nMAINTAINER wangmx<1130@qq.com>\n#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下\nCOPY c.txt /usr/local/cincontainer.txt\n#把java与tomcat添加到容器中\nADD jdk-8u241-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-8.5.53.tar.gz /usr/local/\n# 安装vim编辑器\nRUN yum -y install vim\n# 设置工作访问时候的WORKDIR路径，登录落脚点\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\n#配置java和tomcat环境变量\nENV JAVA_HOME /usr/local/jdk1.8.0_241\nENV CLASSPATH $JAVA_HOME/lib/dt,jar:$JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.33\nENV CATALINA_BASE /usr/local/apache-tomcat-9.0.33\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:CATALINA_HOME/bin\n#容器运行时监听的端口\nEXPOSE 8080\n#启东时运行Tomcat\nCMD /usr/local/apache-tomcat-9.0.33/bin/startup.sh && tail -F /usr/local/apache-tomcat-9.0.33/bin/logs/catalina.out\n```\n![](https://img-blog.csdnimg.cn/20200405103905887.png)\n准备好这几个文件,使用build命令，创建镜像\n```\ndocker build -t mytomcat .\n```\n![](https://img-blog.csdnimg.cn/2020040420194693.png)\n运行自定义tomcat镜像\n```java\ndocker run -d -p 8090:8080 --name mytomcat \\\n-v /usr/local/docker/tomcat9/webapps:/usr/local/apache-tomcat-9.0.33/webapps \\\n-v /usr/local/docker/tomcat9/logs/:/usr/local/apache-tomcat-9.0.33/logs \\\n--privileged=true \\\nmytomcat\n```\n\n在/usr/local/docker/tomcat9/webapps目录下创建ROOT文件夹，在ROOT中创建index.jsp\n重启tomcat\n```java\ndocker restart mytomcat\n```\n\n![](https://img-blog.csdnimg.cn/20200405111235780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n访问成功\n', '<h2 id=\"h2-dockerfile\"><a name=\"Dockerfile\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dockerfile</h2><h3 id=\"h3--dockerfile\"><a name=\"什么是Dockerfile\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>什么是Dockerfile</h3><p>Dockerfile是用来构建Docker镜像的构建文件，是由一系列参数构成的脚本<br>使用命令build来创建新的image，默认是当前目录下名为Dockerfile的文件，可以使用<code>-f 路径</code>来指定具体位置的文件 <code>-t 名称:target</code> 指定镜像名称和版本</p>\n<pre><code class=\"lang-java\">  docker build -f /dockerfiles/Dockerfile -t mycentos:1.0 .\n</code></pre>\n<h3 id=\"h3-dockerfile-\"><a name=\"Dockerfile语法规则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dockerfile语法规则</h3><ol>\n<li>每条保留字指令都必须是大写，且后面要跟随至少一个参数</li><li>指令按照从上到下顺序执行</li><li># 表示注释</li><li>每条指令都会创建一个新的镜像，并进行提交</li></ol>\n<h3 id=\"h3-dockerfile-\"><a name=\"Dockerfile保留字指令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dockerfile保留字指令</h3><ul>\n<li>FROM：基础镜像，当前新镜像是基于哪个镜像，如果不以任何镜像为基础，那么写法为：FROM scratch。</li><li>MAINTAINER：镜像维护者的姓名和邮箱</li><li>RUN：容器构建的时候需要的命令</li><li>EXPOSE：当前容器对外暴露出的端口号</li><li>WORKDIR：指定在创建容器后，终端默认登录的进来工作目录，一个落脚点（创建容器后，进入容器终端的目录，不指定默认是根目录）</li><li>ENV：用来在构建镜像的过程中设置环境变量</li><li>ADD：将宿主机目录下的文件拷贝进镜像，且ADD命令会自动处理URL或者解压tar压缩包</li><li>COPY：将从构建上下文的目录中&lt;源路径&gt;的文件/目录复制到新的一层镜像内的&lt;目标路径&gt;位置</li><li>VOLUME：容器数据券，用于数据保存和持久化工作</li><li>CMD：指定一个容器启动时要执行的命令<br>DockerFile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换</li><li>ENTRYPOINT：指定一个容器启动时要执行的命令<br>目的和CMD一样，都是在指定容器启动程序及参数，不同的是docker run之后的参数是在ENTRYPOINT之后追加</li><li>ONBUILD：当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后，父镜像的onbuild被触发</li></ul>\n<h2 id=\"h2-dockerfile-\"><a name=\"Dockerfile构建案例\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Dockerfile构建案例</h2><h3 id=\"h3--centos\"><a name=\"自定义centos\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>自定义centos</h3><p><img src=\"https://img-blog.csdnimg.cn/20200331181557662.png\" alt=\"\"><br>需求：我们运行官方的centos之后，默认的路径是根目录，且不支持vim命令和ifconfig命令，我们可以使用Dockerfile自定义一个centos镜像，默认路径是/usr/local，且支持vim命令和ifconfig命令</p>\n<p>Dockerfile编写</p>\n<pre><code class=\"lang-java\">FROM centos\nMAINTAINER wmx&lt;1130@qq.com&gt;\n\n#定义环境变量\nENV MYPATH /usr/local\n#定义默认的工作目录\nWORKDIR $MYPATH\n\n#运行命令 安装vim和net-tools\nRUN yum -y install vim\nRUN yum -y install net-tools\n\n#对外暴露的端口号\nEXPOSE 80\n\nCMD echo $MYPATH\nCMD echo &quot;my centos run sunccess ......&quot;\nCMD /bin/bash\n</code></pre>\n<p>使用build命令创建镜像</p>\n<pre><code class=\"lang-java\">docker build -t mycentos:1.0 .\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2020033118430819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"><br>mycentos镜像创建成功，运行mycentos</p>\n<pre><code class=\"lang-java\">docker run -it mycentos:1.0 .\n</code></pre>\n<p>默认目录在/usr/local，并且可以使用vim和ifconfig命令<br><img src=\"https://img-blog.csdnimg.cn/20200331184555751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h3 id=\"h3-cmd-entrypoint\"><a name=\"CMD和ENTRYPOINT\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CMD和ENTRYPOINT</h3><p>我们从上面保留字介绍中可以知道，DockerFile中可以有多个CMD命令，但只有最后一个生效，CMD会被docker run之后的参数替换，我们来进行一下测试</p>\n<p>我们使用Tomcat做一下测试，Tomcat的Dockerfile中最后一行命令</p>\n<pre><code class=\"lang-java\">CMD [&quot;catalina.sh&quot;, &quot;run&quot;]\n</code></pre>\n<p>我们启动Tomcat时，最后执行了Tomcat的启动命令，所以当我们运行Tomcat容器后，可以直接访问Tomcat<br><img src=\"https://img-blog.csdnimg.cn/20200331215644583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20200331215721401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"><br>但是如果我们在启动Tomcat容器时，加上其他命令，就会导致启动Tomcat命令被覆盖而失效<br>如下，比如我们加上ls -l命令，命令正确执行，列出了Tomcat目录下的文件，但是访问Tomcat发现无法访问，Tomcat被没有成功的启动<br><img src=\"https://img-blog.csdnimg.cn/20200331215852468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20200331220059954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h3 id=\"h3--tomcat\"><a name=\"自定义Tomcat\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>自定义Tomcat</h3><p>创建Dockerfile文件</p>\n<pre><code class=\"lang-java\">FROM centos\nMAINTAINER wangmx&lt;1130@qq.com&gt;\n#把宿主机当前上下文的c.txt拷贝到容器/usr/local/路径下\nCOPY c.txt /usr/local/cincontainer.txt\n#把java与tomcat添加到容器中\nADD jdk-8u241-linux-x64.tar.gz /usr/local/\nADD apache-tomcat-8.5.53.tar.gz /usr/local/\n# 安装vim编辑器\nRUN yum -y install vim\n# 设置工作访问时候的WORKDIR路径，登录落脚点\nENV MYPATH /usr/local\nWORKDIR $MYPATH\n\n#配置java和tomcat环境变量\nENV JAVA_HOME /usr/local/jdk1.8.0_241\nENV CLASSPATH $JAVA_HOME/lib/dt,jar:$JAVA_HOME/lib/tools.jar\nENV CATALINA_HOME /usr/local/apache-tomcat-9.0.33\nENV CATALINA_BASE /usr/local/apache-tomcat-9.0.33\nENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:CATALINA_HOME/bin\n#容器运行时监听的端口\nEXPOSE 8080\n#启东时运行Tomcat\nCMD /usr/local/apache-tomcat-9.0.33/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.33/bin/logs/catalina.out\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200405103905887.png\" alt=\"\"><br>准备好这几个文件,使用build命令，创建镜像</p>\n<pre><code>docker build -t mytomcat .\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/2020040420194693.png\" alt=\"\"><br>运行自定义tomcat镜像</p>\n<pre><code class=\"lang-java\">docker run -d -p 8090:8080 --name mytomcat \\\n-v /usr/local/docker/tomcat9/webapps:/usr/local/apache-tomcat-9.0.33/webapps \\\n-v /usr/local/docker/tomcat9/logs/:/usr/local/apache-tomcat-9.0.33/logs \\\n--privileged=true \\\nmytomcat\n</code></pre>\n<p>在/usr/local/docker/tomcat9/webapps目录下创建ROOT文件夹，在ROOT中创建index.jsp<br>重启tomcat</p>\n<pre><code class=\"lang-java\">docker restart mytomcat\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200405111235780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>访问成功</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/2.jpg', '/article/106', 43, '2020-09-19', NULL, 0, 105, 107, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (107, 'Docker入门：（七）Docker安装Mysql', 'mysql8安装后默认表名区分大小写==容器运行成功Navicat连接Mysql使用Navicat连接Mysql,0rowsaffected(0.05sec)查看用户的验证器是否修改连接成功Docker启动时自动启动容器在运行docker容器时可以加如下参数来保证每次docker服务重启后容器也自动重启,因为在mysql5.8从开始将caching_sha2_password作为默认的身份验证插件', '## Docker安装Mysql\n1. 从Docker Hub拉取镜像\n	```java\n	docker pull mysql\n	```\n2. 运行容器\n	```java\n		docker run -p 3306:3306 --name mysql \\\n		-v /usr/local/docker/mysql/data:/var/lib/mysql \\\n		-v /usr/local/docker/mysql/conf/my.cnf:/etc/mysql/conf.d \\\n		-v /usr/local/docker/mysql/logs:/logs \\\n		-e MYSQL_ROOT_PASSWORD=123456 \\\n		-d mysql \\\n		--lower_case_table_names=1\n注：	==-\\-lower_case_table_names=1\n表示表名忽略大小写，如果不加这个，mysql8安装后默认表名区分大小写==\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200404171417657.png)\n容器运行成功\n\n## Navicat连接Mysql\n使用Navicat连接Mysql，我们会发现连接不上，因为在mysql5.8从开始将caching_sha2_password作为默认的身份验证插件，而在MySQL 5.7中，默认的身份验证插件是 mysql_native_password！这个时候可以修改 user 表中的密码规则，回到mysql5.7的密码验证格式。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200404171502988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200404171706572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\nroot 用户的验证器插件为 caching_sha2_password\n\n#### 修改身份验证类型(修改密码)\n```\nmysql> ALTER USER \'root\'@\'%\' IDENTIFIED WITH mysql_native_password BY \'123456\';\nQuery OK, 0 rows affected (0.35 sec)\n\nmysql> ALTER USER \'root\'@\'localhost\' IDENTIFIED WITH mysql_native_password BY \'123456\';\nQuery OK, 0 rows affected (0.40 sec)\n```\n#### 刷新权限\n```\nmysql> FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.05 sec)\n\n```\n#### 查看用户的验证器是否修改\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200404191836910.png)\n#### 连接成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200404171939938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n## Docker启动时自动启动容器\n在运行docker容器时可以加如下参数来保证每次docker服务重启后容器也自动重启：\n```java\ndocker run --restart=always\n```\n如果已经启动了则可以使用如下命令：\n```java\ndocker update --restart=always <CONTAINER ID>\n```\n', '<h2 id=\"h2-docker-mysql\"><a name=\"Docker安装Mysql\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker安装Mysql</h2><ol>\n<li>从Docker Hub拉取镜像<pre><code class=\"lang-java\"> docker pull mysql\n</code></pre>\n</li><li>运行容器<br> ```java<pre><code> docker run -p 3306:3306 --name mysql \\\n -v /usr/local/docker/mysql/data:/var/lib/mysql \\\n -v /usr/local/docker/mysql/conf/my.cnf:/etc/mysql/conf.d \\\n -v /usr/local/docker/mysql/logs:/logs \\\n -e MYSQL_ROOT_PASSWORD=123456 \\\n -d mysql \\\n --lower_case_table_names=1\n</code></pre>注：    ==--lower_case_table_names=1<br>表示表名忽略大小写，如果不加这个，mysql8安装后默认表名区分大小写==</li></ol>\n<p><img src=\"https://img-blog.csdnimg.cn/20200404171417657.png\" alt=\"在这里插入图片描述\"><br>容器运行成功</p>\n<h2 id=\"h2-navicat-mysql\"><a name=\"Navicat连接Mysql\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Navicat连接Mysql</h2><p>使用Navicat连接Mysql，我们会发现连接不上，因为在mysql5.8从开始将caching_sha2_password作为默认的身份验证插件，而在MySQL 5.7中，默认的身份验证插件是 mysql_native_password！这个时候可以修改 user 表中的密码规则，回到mysql5.7的密码验证格式。<br><img src=\"https://img-blog.csdnimg.cn/20200404171502988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200404171706572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>root 用户的验证器插件为 caching_sha2_password</p>\n<h4 id=\"h4--\"><a name=\"修改身份验证类型(修改密码)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>修改身份验证类型(修改密码)</h4><pre><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;\nQuery OK, 0 rows affected (0.35 sec)\n\nmysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;\nQuery OK, 0 rows affected (0.40 sec)\n</code></pre><h4 id=\"h4-u5237u65B0u6743u9650\"><a name=\"刷新权限\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>刷新权限</h4><pre><code>mysql&gt; FLUSH PRIVILEGES;\nQuery OK, 0 rows affected (0.05 sec)\n</code></pre><h4 id=\"h4-u67E5u770Bu7528u6237u7684u9A8Cu8BC1u5668u662Fu5426u4FEEu6539\"><a name=\"查看用户的验证器是否修改\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看用户的验证器是否修改</h4><p><img src=\"https://img-blog.csdnimg.cn/20200404191836910.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"h4-u8FDEu63A5u6210u529F\"><a name=\"连接成功\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>连接成功</h4><p><img src=\"https://img-blog.csdnimg.cn/20200404171939938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2-docker-\"><a name=\"Docker启动时自动启动容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker启动时自动启动容器</h2><p>在运行docker容器时可以加如下参数来保证每次docker服务重启后容器也自动重启：</p>\n<pre><code class=\"lang-java\">docker run --restart=always\n</code></pre>\n<p>如果已经启动了则可以使用如下命令：</p>\n<pre><code class=\"lang-java\">docker update --restart=always &lt;CONTAINER ID&gt;\n</code></pre>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/0.jpg', '/article/107', 43, '2020-09-19', NULL, 0, 106, 108, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (108, 'Docker入门：（八）本地镜像发布到阿里云', '[镜像版本号]将镜像推送到Registry$sudodockerlogin--username=***registry.cn-hangzhou.aliyuncs.com$sudodockertag[ImageId]registry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx,[镜像版本号]$sudodockerpushregistry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx,请使用registry-vpc.cn-hangzhou.aliyuncs.com作为Registry的域名登录', '## 创建阿里云仓库\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405114553431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405114615829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405114724859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405114730452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405114859773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405114924936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n## 阿里云操作指南\n1. 登录阿里云Docker Registry\n	```java\n	$ sudo docker login --username=*** registry.cn-hangzhou.aliyuncs.com\n	```\n	用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。\n\n	您可以在访问凭证页面修改凭证密码。\n\n2. 从Registry中拉取镜像\n	```java\n	$ sudo docker pull registry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx:[镜像版本号]\n	```\n3. 将镜像推送到Registry\n	```java\n	$ sudo docker login --username=*** registry.cn-hangzhou.aliyuncs.com\n	$ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx:[镜像版本号]\n	$ sudo docker push registry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx:[镜像版本号]\n	```\n	请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。\n\n4. 选择合适的镜像仓库地址\n从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。\n\n	如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录，并作为镜像命名空间前缀。\n\n## 将本地镜像上传阿里云\n我们以自定义得centos为例\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405120542810.png)\n#### commit获得一个新的版本镜像\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405121120800.png)\n根据上面阿里云操作指南，将mycentos:1.0提交到阿里云\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405123326100.png)\n上传成功\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405123245427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n从阿里云拉去镜像到本地\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200405123210888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n', '<h2 id=\"h2-u521Bu5EFAu963Fu91CCu4E91u4ED3u5E93\"><a name=\"创建阿里云仓库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建阿里云仓库</h2><p><img src=\"https://img-blog.csdnimg.cn/20200405114553431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20200405114615829.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20200405114724859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20200405114730452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20200405114859773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br><img src=\"https://img-blog.csdnimg.cn/20200405114924936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"h2-u963Fu91CCu4E91u64CDu4F5Cu6307u5357\"><a name=\"阿里云操作指南\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>阿里云操作指南</h2><ol>\n<li><p>登录阿里云Docker Registry</p>\n<pre><code class=\"lang-java\"> $ sudo docker login --username=*** registry.cn-hangzhou.aliyuncs.com\n</code></pre>\n<p> 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>\n<p> 您可以在访问凭证页面修改凭证密码。</p>\n</li><li><p>从Registry中拉取镜像</p>\n<pre><code class=\"lang-java\"> $ sudo docker pull registry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx:[镜像版本号]\n</code></pre>\n</li><li><p>将镜像推送到Registry</p>\n<pre><code class=\"lang-java\"> $ sudo docker login --username=*** registry.cn-hangzhou.aliyuncs.com\n $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx:[镜像版本号]\n $ sudo docker push registry.cn-hangzhou.aliyuncs.com/wangmx_s/wangmx:[镜像版本号]\n</code></pre>\n<p> 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p>\n</li><li><p>选择合适的镜像仓库地址<br>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p>\n<p> 如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录，并作为镜像命名空间前缀。</p>\n</li></ol>\n<h2 id=\"h2-u5C06u672Cu5730u955Cu50CFu4E0Au4F20u963Fu91CCu4E91\"><a name=\"将本地镜像上传阿里云\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>将本地镜像上传阿里云</h2><p>我们以自定义得centos为例<br><img src=\"https://img-blog.csdnimg.cn/20200405120542810.png\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"h4-commit-\"><a name=\"commit获得一个新的版本镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>commit获得一个新的版本镜像</h4><p><img src=\"https://img-blog.csdnimg.cn/20200405121120800.png\" alt=\"在这里插入图片描述\"><br>根据上面阿里云操作指南，将mycentos:1.0提交到阿里云<br><img src=\"https://img-blog.csdnimg.cn/20200405123326100.png\" alt=\"在这里插入图片描述\"><br>上传成功<br><img src=\"https://img-blog.csdnimg.cn/20200405123245427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>从阿里云拉去镜像到本地<br><img src=\"https://img-blog.csdnimg.cn/20200405123210888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/4.jpg', '/article/108', 43, '2020-09-19', NULL, 0, 107, 109, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (152, 'Nginx入门', '#设置代理服务器（nginx）保存用户头信息的缓冲区大小#设置从被代理服务器读取的第一部分应答的缓冲区大小,#}#在需要使用负载均衡的server中增加proxy_passhttp,#}#3、fair（第三方）#按后端服务器的响应时间来分配请求', '# 1、什么是Nginx\nNginx (\"engine x\") 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器特点是占有内存少，并发能力强。。\n\nNginx是一款轻量级的Web服务器/反向代理服务器以及电子邮件代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师lgor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。\n\nNginx相较于Apache\\lighttpd具有占有内存少，稳定性高等优势，并且依靠并发能力强，丰富的模块库以及友好灵活的配置而闻名。在Linux操作系统下，nginx使用epoll事件模型,得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于Epoll的高效事件模型kqueue.\n\n# 2、正向代理和反向代理\n\n## 2.1 正向代理\n　　我们常说的代理也就是只正向代理，正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理\n![](/images/151/160109821815200001.jpg)\n## 2.2 反向代理\n　　反向代理客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。\n![](/images/151/160109825660100002.jpg)\n\n## 2.3 正向代理和反向代理的区别\n两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，正向代理隐藏真实客户端，服务端不知道实际发起请求的客户端。反向代理代理的对象是服务端，反向代理隐藏真实服务端，客户端不知道实际提供服务的服务端\n\n\n# 3、Nginx安装\n\n## 3.1 Linux安装Nginx\n\n### （1）安装nginx相关依赖\n安装命令：\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel pcre-devel\n```\n所需依赖的作用：\n+ gcc、gcc-c++  # 主要用来进行编译相关使用，安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境\n+ zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。\n+ OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。\nnginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。\n+ PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库\n\n（2）创建nginx目录，并进入目录\n```shell\nmkdir /usr/local/nginx\ncd /usr/local/nginx\n```\n\n### （3）下载并解压nginx\n\n```shell\nwget https://nginx.org/download/nginx-1.14.2.tar.gz \ntar -zxvf nginx-1.14.2.tar.gz   \n```\n\n### （4）进入安装包目录\n```shell\ncd nginx-1.14.2\n```\n### （5）编译安装nginx，默认安装到 /usr/local/nginx中\n```shell\n./configure\nmake && make install\n```\n至此，Nginx安装成功\n\n## 3.2 启动Nginx并访问\n### （1）启动Nginx\n```shell\ncd /usr/local/nginx/sbin\n./nginx   # 启动命令\n```\n### （2）查看nginx进程\n\n```shell\nps -ef | grep nginx\n```\n\n### （3）访问Nginx\n输入ip地址，可以访问到下图所示页面\n![](https://img-blog.csdnimg.cn/20200703101610268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n\n\n# 4、Nginx常用命令和配置文件\n## 4.1 Nginx常用命令\n\n以下所有命令，都要在/usr/local/nginx/sbin目录下执行\n### （1）启动命令\n```shell\n./nginx  \n```\n### （2）停止命令\n```shell\n./nginx -s stop # 快速停止命令，不管有没有正在处理的请求\n./nginx -s quit # 正常停止命令，在退出前完成已经接受的连接请求。\n```\n### （3）重启命令\n```shell\n./nginx -s reload\n```\n### （4）查看版本\n```shell\n./nginx -v\n```\n### （5）查看 Nginx 配置语法的正确性\n```shell\n./nginx -v\n```\n## 4.2 配置文件\n\nnginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改。\n{% qnimg Nginx/000004.png %}\n根据上图，我们可以很明显的将 nginx.conf 配置文件分为三部分：\n\n### （1）全局块\n\n从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\n比如图中的\n```\nworker_processes   1\n```\n这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约\n\n\n### （2）events 块\n\nevents 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。\n```\nworker_connections  1024;\n```\n上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。\n\n### （3）http 块\n\n这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。\n\n需要注意的是：http块也可以包括http全局块和server块。\n\n#### 1） http 全局块\n\nhttp 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\n\n#### 2） http server块\n\n这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局server块，以及可以同时包含多个locaton块。\n\n**① 全局server块**\n最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。\n**② location块**\n一个 server 块可以配置多个 location 块。\n这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。\n\n### 详细配置文件介绍\n\n```conf\n#定义Nginx运行的用户和用户组\nuser www www; \n\n#nginx进程数，通常设置成和cpu的数量相等\nworker_processes 4; \n\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n\n#进程pid文件\n#pid        logs/nginx.pid;\n\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n\nevents {\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\n    #补充说明：\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\n    #A）标准事件模型\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\n    #B）高效事件模型\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\n    use epoll\n    \n    \n    #单个进程最大连接数（最大连接数=连接数+进程数）\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\n    worker_connections  1024;\n    \n    #keepalive 超时时间\n    keepalive_timeout 60;\n    \n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\n    #分页大小可以用命令getconf PAGESIZE 取得。\n    #[root@web001 ~]# getconf PAGESIZE\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\n    client_header_buffer_size 4k;\n    \n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n    \n    \n    #这个是指多长时间检查一次缓存的有效信息。\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\n    open_file_cache_valid 80s;\n    \n    \n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\n    open_file_cache_min_uses 1;\n    \n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\n    open_file_cache_errors on;\n}\n\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n    \n    #默认文件类型\n    default_type application/octet-stream;\n    \n    #默认编码\n    charset utf-8;\n    \n    #服务器名字的hash表大小\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\n    server_names_hash_bucket_size 128;\n    \n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\n    client_header_buffer_size 32k;\n    \n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\n    large_client_header_buffers 4 64k;\n    \n    #设定通过nginx上传文件的大小\n    client_max_body_size 8m;\n    \n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\n    sendfile on;\n    \n     #开启目录列表访问，合适下载服务器，默认关闭。\n    autoindex on;\n    \n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n     \n    tcp_nodelay on;\n    \n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n    \n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n    \n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;     #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n    \n    \n    #负载均衡配置\n    upstream piao.jd.com {\n     \n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n    \n    \n    #虚拟主机的配置\n    server {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.jd.com jd.com;\n        #默认入口文件名称\n        index index.html index.htm index.php;\n        root /data/www/jd;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n         \n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n         \n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n         \n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n        \'$status $body_bytes_sent \"$http_referer\" \'\n        \'\"$http_user_agent\" $http_x_forwarded_for\';\n         \n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n         \n        #对 \"/connect-controller\" 启用反向代理\n        location /connect-controller {\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n             \n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n             \n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n        \n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n    }\n}\n```\n### 总结\nNginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。\n\nmain 部分设置的指令影响其他所有部分的设置；\n\nserver 部分的指令主要用于制定虚拟主机域名、IP 和端口号；\n\nupstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；\n\nlocation 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。\n\n他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。\n\n# 5、Nginx配置实例-反向代理\n\n## 5.1 反向代理实例一\n\n### （1）实现效果\n使用 nginx 反向代理，访问nginx地址直接跳转到Tomcat服务器\n> 访问 ip 192.168.31.202 直接跳转到Tomcat 192.168.31.202:8080\n### （2）实现过程\n\n1.在Linx下安装并启动Tomcat服务器，访问Tomcat服务器\n![](https://img-blog.csdnimg.cn/20200703221126739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n2.配置Nginx反向代理，通过Nginx访问Tomcat服务器\n![](https://img-blog.csdnimg.cn/20200703221958786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n3.修改配置文件，通过访问Nginx监听的80端口，访问到Tomcat服务器的8080端口\n![](https://img-blog.csdnimg.cn/20200703222203503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n\n## 5.2 反向代理实例一\n\n### （1）实现效果\n使用nginx反向代理，根据访问的路径跳转到不同端口的服务中\n> 访问 http://192.168.31.202:9001/edu/index.html 直接跳转到 192.168.31.202:8081/edu/index.html    \n> 访问 http://192.168.31.202:9001/vod/index.html 直接跳转到 192.168.31.202:8082/edu/index.html\n### （2）实现过程\n\n1.在Tomcat的webapps目录下新增edu文件夹，添加index.html文件，内容如下\n```html\n<h1>8080</h1>\n```\n![](https://img-blog.csdnimg.cn/20200703222804206.png)\n\n2.重新启动一个Tomcat，端口为8081，并在webapps目录下新增vod文件夹，同样添加index.html\n```html\n<h1>8081</h1>\n```\n![](https://img-blog.csdnimg.cn/20200703222758402.png)\n\n3.修改 nginx 的配置文件，新增一个server，实现访问http://192.168.31.202:9001/edu/  直接跳转到8080服务，访问 http://192.168.31.202:9001/vod/ 直接跳转到8081服务\n```conf\n    server {\n          listen       80;\n          server_name  192.168.31.202;\n  \n          location ~ /edu/ {\n              proxy_pass  http://192.168.31.202:8080;\n          }\n\n          location ~ /vod/ {\n              proxy_pass  http://192.168.31.202:8081;\n          }\n  \n      }\n```\n4.访问9001端口\n\n![](https://img-blog.csdnimg.cn/20200703223501830.png)\n![](https://img-blog.csdnimg.cn/20200703223425541.png)\n\n## 5.3 location指令说明：\n\n该指令用于匹配 URL。语法如下：\n\n1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。\n\n2、~：用于表示 uri 包含正则表达式，并且区分大小写。\n\n3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。\n\n4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。\n\n**注意**：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。\n\n# 6、Nginx配置实例-负载均衡\n\n## 6.1 负载均衡\n客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。\n\n这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？\n\n我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？\n\n上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡\n![](https://img-blog.csdnimg.cn/20200706220045249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n## 6.2 Nginx配置负载均衡\n\n部署两台Tomcat服务器，通过Nginx实现负载均衡，将访问平均到两台服务器上。\n\n（1）部署服务器\n\n![](https://img-blog.csdnimg.cn/2020070420591942.png)\n![](https://img-blog.csdnimg.cn/20200704205945446.png)\n\n（2）修改配置文件\n```conf\n    upstream myservers{\n        server 192.168.31.202:8080;\n        server 192.168.31.202:8081;\n    }\n\n    server {\n        listen       80;\n        server_name  192.168.31.202;\n\n        location / {\n            proxy_pass    http://myservers;\n            root   html;\n            index  index.html index.htm;\n        }\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n\n```\n\n## 6.3 Nginx分配服务器策略\n\n第一种 轮询（默认）\n\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。\n```conf\nupstream backserver { \n    server 192.168.31.202:8080; \n    server 192.168.31.202:8081; \n} \n```\n\n第二种 weight\nweight的值越大分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。\n权重越高，在被访问的概率越大，如下例，分别是20%，80%。\n```conf\nupstream backserver { \n    server 192.168.31.202:8080  weight=8; \n    server 192.168.31.202:8081  weight=2; \n} \n```\n第三种 ip_hash\n\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，==并且可以有效解决动态网页存在的session共享问题==\n```conf\nupstream backserver { \n    ip_hash; \n    server 192.168.31.202:8080; \n    server 192.168.31.202:8081; \n} \n```\n\n第四种 fair（(第三方插件)）\n+ 必须安装upstream_fair模块。\n\n+ 对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。哪个服务器的响应速度快，就将请求分配到那个服务器上。\n	```conf\n	upstream backserver { \n	    server 192.168.31.202:8080; \n	    server 192.168.31.202:8081; \n	    fair; \n	} \n	```\n\n\n# 7、 Nginx配置实例-动静分离\n\n\n## 7.1 动静分离\n为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。\n![](https://img-blog.csdnimg.cn/20200704212243623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n## 7.2 动静分离配置\n通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。\n\n在Linux data目录下放置静态资源\n![](https://img-blog.csdnimg.cn/20200704213722173.png)\n\n修改配置文件\n![](https://img-blog.csdnimg.cn/20200704214717163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n```  \nserver {\n    listen       80;\n    server_name  192.168.31.202;\n\n    location / {\n        proxy_pass    http://myservers;\n        root   html;\n        index  index.html index.htm;\n    }\n    location /www/ {\n        root   /data/;\n        expires 3d;\n        index  index.html index.htm;\n    }\n    location /images/ {\n        root   /data/;\n        index  index.html index.htm;\n        autoindex    on;\n        expires 3h;\n    }\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   html;\n    }\n}\n        \n```\n访问静态资源，如果设置autoindex on可以展示静态资源列表\n![v](https://img-blog.csdnimg.cn/20200704214818297.png)\n![](https://img-blog.csdnimg.cn/20200704215216347.png)\n设置`autoindex  on`可以访问静态资源路径展示列表，如图一所示\n\n# 8、Nginx高可用集群\n\n## 8.1 Keepalived+Nginx 高可用集群（主从模式）\n![](https://img-blog.csdnimg.cn/20200704222334774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n\n## 8.2 配置高可用集群\n\n### （1）部署两台 nginx 服务器，并安装keepalived\n\n安装keepalived\n```shell\nyum install keepalived –y\n```\n\n### （2）安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf\n\n![](https://img-blog.csdnimg.cn/20200704222848610.png)\n\n### （3）修改/etc/keepalived/keepalivec.conf 配置文件\n\n```json\nglobal_defs {\n   notification_email {\n     acassen@firewall.loc\n     failover@firewall.loc\n     sysadmin@firewall.loc\n   }\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 192.168.31.202\n   smtp_connect_timeout 30\n   router_id LVS_DEVEL\n   vrrp_skip_check_adv_addr\n   vrrp_strict\n   vrrp_garp_interval 0\n   vrrp_gna_interval 0\n}\nvrrp_script chk_http_port {\n    script \"/usr/local/src/nginx_check.sh\" #检测脚本\n    interval 2  #（检测脚本执行的间隔）\n    weight 2\n}\nvrrp_instance VI_1 {\n    state MASTER         #备份服务器上改为BACKUP\n    interface enp7s0     #网卡\n    virtual_router_id 51 #主机备机的virtual_router_id必须相同\n    priority 100         #主机备机去不同的优先级，主机优先级较大\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    virtual_ipaddress {\n        192.168.17.50\n    }\n}\n\n```\n\n### （4）在/usr/local/src 添加检测脚本nginx_check.sh\n```bash\n#!/bin/bash\nA=`ps -C nginx –no-header |wc -l`\nif [ $A -eq 0 ];\n    then /usr/local/nginx/sbin/nginx\n    sleep 2\n    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];\n    	then killall keepalived\n    fi\nfi\n```\n\n### （5）把两台服务器上 nginx 和 keepalived 启动\n\n启动 nginx：\n```\n./nginx\n```\n启动 keepalived：\n```\nsystemctl start keepalived.service\n```\n### （6）最终测试\n\n在浏览器地址栏输入虚拟地址ip 192.168.17.50\n把主服务器nginx和keepalived停止，再次输入192.168.17.50\n\n\n## Nginx原理解析\n1、master和worker\n![](https://img-blog.csdnimg.cn/20200706155224454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n2、worker如何进行工作的\n![](https://img-blog.csdnimg.cn/20200706155234294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70)\n\n3、一个master和多个woker的好处\n(1) 可以使用nginx -s reload热部署。\n\n首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次,采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker.上的所有请求失败，不过不会影响到所有请求，所以降低了风险。\n\n4、设置多少个woker合适\n\nNginx同redis类似都采用了io多路复用机制，每个worker都是一个独立的进程， 但每个进\n程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是 千上万个请求也不在话\n下。每个worker的线程可以把一个cpu的性能发挥到极致。所以worker数和服务器的cpu\n数相等是最为适宜的。设少了会浪费cpu,设多了会造成cpu频繁切换上下文带来的损耗。\n\n设置worker数量\n```shell\nworker.processes 4 \n\n# work绑定cpu(4work绑定4cpu)\nworker_cpu_affinity 0001 0010 0100 1000\n\n# work绑定cpu (4work绑定8cpu中的4个)\nworker_cpu_affinity 00000001 00000010 00000100 00001000\n\n```\n5、连接数worker_ connection\n这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx 能建立的最大连接数，应该是worker.connections * worker processes。当然，这里说的是最大连接数，对于HTTP 请求本地资源来说，能够支持的最大并发数量是worker.connections * worker processes,如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是: worker.connections * worker.processes / 2, 而如果是HTTP作为反向代理来说，最大并发数量应该是worker.connections * worker_proceses/4. 因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接.\n第一个: 发送请求，占用了woker的几个连接数?\n答案: 2或者4个。\n\n第二个: nginx有一个master,有四个woker,每个woker支持最大的连接数1024,支持的最大并发数是多少?\n答案：普通的静态访问最大并发数是: worker connections * worker processes /2，\n而如果是HTTP作为反向代理来说，最大并发数量应该是worker connections * worker processes/4\n', '<h1 id=\"h1-1-nginx\"><a name=\"1、什么是Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1、什么是Nginx</h1><p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器特点是占有内存少，并发能力强。。</p>\n<p>Nginx是一款轻量级的Web服务器/反向代理服务器以及电子邮件代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师lgor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p>\n<p>Nginx相较于Apache\\lighttpd具有占有内存少，稳定性高等优势，并且依靠并发能力强，丰富的模块库以及友好灵活的配置而闻名。在Linux操作系统下，nginx使用epoll事件模型,得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于Epoll的高效事件模型kqueue.</p>\n<h1 id=\"h1-2-\"><a name=\"2、正向代理和反向代理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2、正向代理和反向代理</h1><h2 id=\"h2-2-1-\"><a name=\"2.1 正向代理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.1 正向代理</h2><p>　　我们常说的代理也就是只正向代理，正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理<br><img src=\"/images/151/160109821815200001.jpg\" alt=\"\"></p>\n<h2 id=\"h2-2-2-\"><a name=\"2.2 反向代理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.2 反向代理</h2><p>　　反向代理客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。<br><img src=\"/images/151/160109825660100002.jpg\" alt=\"\"></p>\n<h2 id=\"h2-2-3-\"><a name=\"2.3 正向代理和反向代理的区别\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2.3 正向代理和反向代理的区别</h2><p>两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，正向代理隐藏真实客户端，服务端不知道实际发起请求的客户端。反向代理代理的对象是服务端，反向代理隐藏真实服务端，客户端不知道实际提供服务的服务端</p>\n<h1 id=\"h1-3-nginx-\"><a name=\"3、Nginx安装\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3、Nginx安装</h1><h2 id=\"h2-3-1-linux-nginx\"><a name=\"3.1 Linux安装Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.1 Linux安装Nginx</h2><h3 id=\"h3--1-nginx-\"><a name=\"（1）安装nginx相关依赖\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（1）安装nginx相关依赖</h3><p>安装命令：</p>\n<pre><code class=\"lang-shell\">yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel pcre-devel\n</code></pre>\n<p>所需依赖的作用：</p>\n<ul>\n<li>gcc、gcc-c++  # 主要用来进行编译相关使用，安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境</li><li>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</li><li>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</li><li>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库</li></ul>\n<p>（2）创建nginx目录，并进入目录</p>\n<pre><code class=\"lang-shell\">mkdir /usr/local/nginx\ncd /usr/local/nginx\n</code></pre>\n<h3 id=\"h3--3-nginx\"><a name=\"（3）下载并解压nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（3）下载并解压nginx</h3><pre><code class=\"lang-shell\">wget https://nginx.org/download/nginx-1.14.2.tar.gz \ntar -zxvf nginx-1.14.2.tar.gz\n</code></pre>\n<h3 id=\"h3--4-\"><a name=\"（4）进入安装包目录\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（4）进入安装包目录</h3><pre><code class=\"lang-shell\">cd nginx-1.14.2\n</code></pre>\n<h3 id=\"h3--5-nginx-usr-local-nginx-\"><a name=\"（5）编译安装nginx，默认安装到 /usr/local/nginx中\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（5）编译安装nginx，默认安装到 /usr/local/nginx中</h3><pre><code class=\"lang-shell\">./configure\nmake &amp;&amp; make install\n</code></pre>\n<p>至此，Nginx安装成功</p>\n<h2 id=\"h2-3-2-nginx-\"><a name=\"3.2 启动Nginx并访问\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>3.2 启动Nginx并访问</h2><h3 id=\"h3--1-nginx\"><a name=\"（1）启动Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（1）启动Nginx</h3><pre><code class=\"lang-shell\">cd /usr/local/nginx/sbin\n./nginx   # 启动命令\n</code></pre>\n<h3 id=\"h3--2-nginx-\"><a name=\"（2）查看nginx进程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（2）查看nginx进程</h3><pre><code class=\"lang-shell\">ps -ef | grep nginx\n</code></pre>\n<h3 id=\"h3--3-nginx\"><a name=\"（3）访问Nginx\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（3）访问Nginx</h3><p>输入ip地址，可以访问到下图所示页面<br><img src=\"https://img-blog.csdnimg.cn/20200703101610268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h1 id=\"h1-4-nginx-\"><a name=\"4、Nginx常用命令和配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4、Nginx常用命令和配置文件</h1><h2 id=\"h2-4-1-nginx-\"><a name=\"4.1 Nginx常用命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.1 Nginx常用命令</h2><p>以下所有命令，都要在/usr/local/nginx/sbin目录下执行</p>\n<h3 id=\"h3--1-\"><a name=\"（1）启动命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（1）启动命令</h3><pre><code class=\"lang-shell\">./nginx\n</code></pre>\n<h3 id=\"h3--2-\"><a name=\"（2）停止命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（2）停止命令</h3><pre><code class=\"lang-shell\">./nginx -s stop # 快速停止命令，不管有没有正在处理的请求\n./nginx -s quit # 正常停止命令，在退出前完成已经接受的连接请求。\n</code></pre>\n<h3 id=\"h3--3-\"><a name=\"（3）重启命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（3）重启命令</h3><pre><code class=\"lang-shell\">./nginx -s reload\n</code></pre>\n<h3 id=\"h3--4-\"><a name=\"（4）查看版本\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（4）查看版本</h3><pre><code class=\"lang-shell\">./nginx -v\n</code></pre>\n<h3 id=\"h3--5-nginx-\"><a name=\"（5）查看 Nginx 配置语法的正确性\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（5）查看 Nginx 配置语法的正确性</h3><pre><code class=\"lang-shell\">./nginx -v\n</code></pre>\n<h2 id=\"h2-4-2-\"><a name=\"4.2 配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>4.2 配置文件</h2><p>nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改。<br>{% qnimg Nginx/000004.png %}<br>根据上图，我们可以很明显的将 nginx.conf 配置文件分为三部分：</p>\n<h3 id=\"h3--1-\"><a name=\"（1）全局块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（1）全局块</h3><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。<br>比如图中的</p>\n<pre><code>worker_processes   1\n</code></pre><p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约</p>\n<h3 id=\"h3--2-events-\"><a name=\"（2）events 块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（2）events 块</h3><p>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</p>\n<pre><code>worker_connections  1024;\n</code></pre><p>上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p>\n<h3 id=\"h3--3-http-\"><a name=\"（3）http 块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（3）http 块</h3><p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>\n<p>需要注意的是：http块也可以包括http全局块和server块。</p>\n<h4 id=\"h4-1-http-\"><a name=\"1） http 全局块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1） http 全局块</h4><p>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>\n<h4 id=\"h4-2-http-server-\"><a name=\"2） http server块\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>2） http server块</h4><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局server块，以及可以同时包含多个locaton块。</p>\n<p><strong>① 全局server块</strong><br>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。<br><strong>② location块</strong><br>一个 server 块可以配置多个 location 块。<br>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>\n<h3 id=\"h3-u8BE6u7EC6u914Du7F6Eu6587u4EF6u4ECBu7ECD\"><a name=\"详细配置文件介绍\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>详细配置文件介绍</h3><pre><code class=\"lang-conf\">#定义Nginx运行的用户和用户组\nuser www www; \n\n#nginx进程数，通常设置成和cpu的数量相等\nworker_processes 4; \n\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n\n#进程pid文件\n#pid        logs/nginx.pid;\n\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n\nevents {\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。\n    #补充说明：\n    #与apache相类，nginx针对不同的操作系统，有不同的事件模型\n    #A）标准事件模型\n    #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll\n    #B）高效事件模型\n    #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。\n    #Epoll：使用于Linux内核2.6版本及以后的系统。\n    #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。\n    #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。\n    use epoll\n\n\n    #单个进程最大连接数（最大连接数=连接数+进程数）\n    #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cup跑到100%就行。\n    worker_connections  1024;\n\n    #keepalive 超时时间\n    keepalive_timeout 60;\n\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。\n    #分页大小可以用命令getconf PAGESIZE 取得。\n    #[root@web001 ~]# getconf PAGESIZE\n    #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。\n    client_header_buffer_size 4k;\n\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n\n\n    #这个是指多长时间检查一次缓存的有效信息。\n    #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.\n    open_file_cache_valid 80s;\n\n\n    #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.\n    open_file_cache_min_uses 1;\n\n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\n    open_file_cache_errors on;\n}\n\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n\n    #默认文件类型\n    default_type application/octet-stream;\n\n    #默认编码\n    charset utf-8;\n\n    #服务器名字的hash表大小\n    #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.\n    server_names_hash_bucket_size 128;\n\n    #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。\n    client_header_buffer_size 32k;\n\n    #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。\n    large_client_header_buffers 4 64k;\n\n    #设定通过nginx上传文件的大小\n    client_max_body_size 8m;\n\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。\n    sendfile on;\n\n     #开启目录列表访问，合适下载服务器，默认关闭。\n    autoindex on;\n\n      #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n\n    tcp_nodelay on;\n\n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n\n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;     #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n\n\n    #负载均衡配置\n    upstream piao.jd.com {\n\n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n\n\n    #虚拟主机的配置\n    server {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name www.jd.com jd.com;\n        #默认入口文件名称\n        index index.html index.htm index.php;\n        root /data/www/jd;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n\n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n\n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n\n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n        &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;\n\n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n\n        #对 &quot;/connect-controller&quot; 启用反向代理\n        location /connect-controller {\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n\n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n    }\n}\n</code></pre>\n<h3 id=\"h3-u603Bu7ED3\"><a name=\"总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>总结</h3><p>Nginx 配置文件主要分成四部分：main（全局设置）、server（主机设置）、upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置）。</p>\n<p>main 部分设置的指令影响其他所有部分的设置；</p>\n<p>server 部分的指令主要用于制定虚拟主机域名、IP 和端口号；</p>\n<p>upstream 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；</p>\n<p>location 部分用于匹配网页位置（比如，根目录“/”，“/images”，等等）。</p>\n<p>他们之间的关系：server 继承 main，location 继承 server；upstream 既不会继承指令也不会被继承。</p>\n<h1 id=\"h1-5-nginx-\"><a name=\"5、Nginx配置实例-反向代理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5、Nginx配置实例-反向代理</h1><h2 id=\"h2-5-1-\"><a name=\"5.1 反向代理实例一\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.1 反向代理实例一</h2><h3 id=\"h3--1-\"><a name=\"（1）实现效果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（1）实现效果</h3><p>使用 nginx 反向代理，访问nginx地址直接跳转到Tomcat服务器</p>\n<blockquote>\n<p>访问 ip 192.168.31.202 直接跳转到Tomcat 192.168.31.202:8080</p>\n<h3 id=\"h3--2-\"><a name=\"（2）实现过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（2）实现过程</h3></blockquote>\n<p>1.在Linx下安装并启动Tomcat服务器，访问Tomcat服务器<br><img src=\"https://img-blog.csdnimg.cn/20200703221126739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>2.配置Nginx反向代理，通过Nginx访问Tomcat服务器<br><img src=\"https://img-blog.csdnimg.cn/20200703221958786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"><br>3.修改配置文件，通过访问Nginx监听的80端口，访问到Tomcat服务器的8080端口<br><img src=\"https://img-blog.csdnimg.cn/20200703222203503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h2 id=\"h2-5-2-\"><a name=\"5.2 反向代理实例一\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.2 反向代理实例一</h2><h3 id=\"h3--1-\"><a name=\"（1）实现效果\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（1）实现效果</h3><p>使用nginx反向代理，根据访问的路径跳转到不同端口的服务中</p>\n<blockquote>\n<p>访问 <a href=\"http://192.168.31.202:9001/edu/index.html\">http://192.168.31.202:9001/edu/index.html</a> 直接跳转到 192.168.31.202:8081/edu/index.html<br>访问 <a href=\"http://192.168.31.202:9001/vod/index.html\">http://192.168.31.202:9001/vod/index.html</a> 直接跳转到 192.168.31.202:8082/edu/index.html</p>\n<h3 id=\"h3--2-\"><a name=\"（2）实现过程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（2）实现过程</h3></blockquote>\n<p>1.在Tomcat的webapps目录下新增edu文件夹，添加index.html文件，内容如下</p>\n<pre><code class=\"lang-html\">&lt;h1&gt;8080&lt;/h1&gt;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200703222804206.png\" alt=\"\"></p>\n<p>2.重新启动一个Tomcat，端口为8081，并在webapps目录下新增vod文件夹，同样添加index.html</p>\n<pre><code class=\"lang-html\">&lt;h1&gt;8081&lt;/h1&gt;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20200703222758402.png\" alt=\"\"></p>\n<p>3.修改 nginx 的配置文件，新增一个server，实现访问<a href=\"http://192.168.31.202:9001/edu/\">http://192.168.31.202:9001/edu/</a>  直接跳转到8080服务，访问 <a href=\"http://192.168.31.202:9001/vod/\">http://192.168.31.202:9001/vod/</a> 直接跳转到8081服务</p>\n<pre><code class=\"lang-conf\">    server {\n          listen       80;\n          server_name  192.168.31.202;\n\n          location ~ /edu/ {\n              proxy_pass  http://192.168.31.202:8080;\n          }\n\n          location ~ /vod/ {\n              proxy_pass  http://192.168.31.202:8081;\n          }\n\n      }\n</code></pre>\n<p>4.访问9001端口</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200703223501830.png\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20200703223425541.png\" alt=\"\"></p>\n<h2 id=\"h2-5-3-location-\"><a name=\"5.3 location指令说明：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>5.3 location指令说明：</h2><p>该指令用于匹配 URL。语法如下：</p>\n<p>1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</p>\n<p>2、~：用于表示 uri 包含正则表达式，并且区分大小写。</p>\n<p>3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。</p>\n<p>4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</p>\n<p><strong>注意</strong>：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</p>\n<h1 id=\"h1-6-nginx-\"><a name=\"6、Nginx配置实例-负载均衡\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6、Nginx配置实例-负载均衡</h1><h2 id=\"h2-6-1-\"><a name=\"6.1 负载均衡\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.1 负载均衡</h2><p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。</p>\n<p>这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？</p>\n<p>我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？</p>\n<p>上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡<br><img src=\"https://img-blog.csdnimg.cn/20200706220045249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h2 id=\"h2-6-2-nginx-\"><a name=\"6.2 Nginx配置负载均衡\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.2 Nginx配置负载均衡</h2><p>部署两台Tomcat服务器，通过Nginx实现负载均衡，将访问平均到两台服务器上。</p>\n<p>（1）部署服务器</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2020070420591942.png\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20200704205945446.png\" alt=\"\"></p>\n<p>（2）修改配置文件</p>\n<pre><code class=\"lang-conf\">    upstream myservers{\n        server 192.168.31.202:8080;\n        server 192.168.31.202:8081;\n    }\n\n    server {\n        listen       80;\n        server_name  192.168.31.202;\n\n        location / {\n            proxy_pass    http://myservers;\n            root   html;\n            index  index.html index.htm;\n        }\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n</code></pre>\n<h2 id=\"h2-6-3-nginx-\"><a name=\"6.3 Nginx分配服务器策略\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>6.3 Nginx分配服务器策略</h2><p>第一种 轮询（默认）</p>\n<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p>\n<pre><code class=\"lang-conf\">upstream backserver { \n    server 192.168.31.202:8080; \n    server 192.168.31.202:8081; \n}\n</code></pre>\n<p>第二种 weight<br>weight的值越大分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。<br>权重越高，在被访问的概率越大，如下例，分别是20%，80%。</p>\n<pre><code class=\"lang-conf\">upstream backserver { \n    server 192.168.31.202:8080  weight=8; \n    server 192.168.31.202:8081  weight=2; \n}\n</code></pre>\n<p>第三种 ip_hash</p>\n<p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，==并且可以有效解决动态网页存在的session共享问题==</p>\n<pre><code class=\"lang-conf\">upstream backserver { \n    ip_hash; \n    server 192.168.31.202:8080; \n    server 192.168.31.202:8081; \n}\n</code></pre>\n<p>第四种 fair（(第三方插件)）</p>\n<ul>\n<li><p>必须安装upstream_fair模块。</p>\n</li><li><p>对比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。哪个服务器的响应速度快，就将请求分配到那个服务器上。</p>\n<pre><code class=\"lang-conf\">  upstream backserver { \n      server 192.168.31.202:8080; \n      server 192.168.31.202:8081; \n      fair; \n  }\n</code></pre>\n</li></ul>\n<h1 id=\"h1-7-nginx-\"><a name=\"7、 Nginx配置实例-动静分离\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7、 Nginx配置实例-动静分离</h1><h2 id=\"h2-7-1-\"><a name=\"7.1 动静分离\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.1 动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。<br><img src=\"https://img-blog.csdnimg.cn/20200704212243623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h2 id=\"h2-7-2-\"><a name=\"7.2 动静分离配置\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>7.2 动静分离配置</h2><p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>\n<p>在Linux data目录下放置静态资源<br><img src=\"https://img-blog.csdnimg.cn/20200704213722173.png\" alt=\"\"></p>\n<p>修改配置文件<br><img src=\"https://img-blog.csdnimg.cn/20200704214717163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<pre><code>server {\n    listen       80;\n    server_name  192.168.31.202;\n\n    location / {\n        proxy_pass    http://myservers;\n        root   html;\n        index  index.html index.htm;\n    }\n    location /www/ {\n        root   /data/;\n        expires 3d;\n        index  index.html index.htm;\n    }\n    location /images/ {\n        root   /data/;\n        index  index.html index.htm;\n        autoindex    on;\n        expires 3h;\n    }\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   html;\n    }\n}\n</code></pre><p>访问静态资源，如果设置autoindex on可以展示静态资源列表<br><img src=\"https://img-blog.csdnimg.cn/20200704214818297.png\" alt=\"v\"><br><img src=\"https://img-blog.csdnimg.cn/20200704215216347.png\" alt=\"\"><br>设置<code>autoindex  on</code>可以访问静态资源路径展示列表，如图一所示</p>\n<h1 id=\"h1-8-nginx-\"><a name=\"8、Nginx高可用集群\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8、Nginx高可用集群</h1><h2 id=\"h2-8-1-keepalived-nginx-\"><a name=\"8.1 Keepalived+Nginx 高可用集群（主从模式）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.1 Keepalived+Nginx 高可用集群（主从模式）</h2><p><img src=\"https://img-blog.csdnimg.cn/20200704222334774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<h2 id=\"h2-8-2-\"><a name=\"8.2 配置高可用集群\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>8.2 配置高可用集群</h2><h3 id=\"h3--1-nginx-keepalived\"><a name=\"（1）部署两台 nginx 服务器，并安装keepalived\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（1）部署两台 nginx 服务器，并安装keepalived</h3><p>安装keepalived</p>\n<pre><code class=\"lang-shell\">yum install keepalived –y\n</code></pre>\n<h3 id=\"h3--2-etc-keepalived-keepalived-conf\"><a name=\"（2）安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（2）安装之后，在 etc 里面生成目录 keepalived，有文件 keepalived.conf</h3><p><img src=\"https://img-blog.csdnimg.cn/20200704222848610.png\" alt=\"\"></p>\n<h3 id=\"h3--3-etc-keepalived-keepalivec-conf-\"><a name=\"（3）修改/etc/keepalived/keepalivec.conf 配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（3）修改/etc/keepalived/keepalivec.conf 配置文件</h3><pre><code class=\"lang-json\">global_defs {\n   notification_email {\n     acassen@firewall.loc\n     failover@firewall.loc\n     sysadmin@firewall.loc\n   }\n   notification_email_from Alexandre.Cassen@firewall.loc\n   smtp_server 192.168.31.202\n   smtp_connect_timeout 30\n   router_id LVS_DEVEL\n   vrrp_skip_check_adv_addr\n   vrrp_strict\n   vrrp_garp_interval 0\n   vrrp_gna_interval 0\n}\nvrrp_script chk_http_port {\n    script &quot;/usr/local/src/nginx_check.sh&quot; #检测脚本\n    interval 2  #（检测脚本执行的间隔）\n    weight 2\n}\nvrrp_instance VI_1 {\n    state MASTER         #备份服务器上改为BACKUP\n    interface enp7s0     #网卡\n    virtual_router_id 51 #主机备机的virtual_router_id必须相同\n    priority 100         #主机备机去不同的优先级，主机优先级较大\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass 1111\n    }\n    virtual_ipaddress {\n        192.168.17.50\n    }\n}\n</code></pre>\n<h3 id=\"h3--4-usr-local-src-nginx_check-sh\"><a name=\"（4）在/usr/local/src 添加检测脚本nginx_check.sh\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（4）在/usr/local/src 添加检测脚本nginx_check.sh</h3><pre><code class=\"lang-bash\">#!/bin/bash\nA=`ps -C nginx –no-header |wc -l`\nif [ $A -eq 0 ];\n    then /usr/local/nginx/sbin/nginx\n    sleep 2\n    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];\n        then killall keepalived\n    fi\nfi\n</code></pre>\n<h3 id=\"h3--5-nginx-keepalived-\"><a name=\"（5）把两台服务器上 nginx 和 keepalived 启动\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（5）把两台服务器上 nginx 和 keepalived 启动</h3><p>启动 nginx：</p>\n<pre><code>./nginx\n</code></pre><p>启动 keepalived：</p>\n<pre><code>systemctl start keepalived.service\n</code></pre><h3 id=\"h3--6-\"><a name=\"（6）最终测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>（6）最终测试</h3><p>在浏览器地址栏输入虚拟地址ip 192.168.17.50<br>把主服务器nginx和keepalived停止，再次输入192.168.17.50</p>\n<h2 id=\"h2-nginx-\"><a name=\"Nginx原理解析\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Nginx原理解析</h2><p>1、master和worker<br><img src=\"https://img-blog.csdnimg.cn/20200706155224454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>2、worker如何进行工作的<br><img src=\"https://img-blog.csdnimg.cn/20200706155234294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70\" alt=\"\"></p>\n<p>3、一个master和多个woker的好处<br>(1) 可以使用nginx -s reload热部署。</p>\n<p>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次,采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker.上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p>\n<p>4、设置多少个woker合适</p>\n<p>Nginx同redis类似都采用了io多路复用机制，每个worker都是一个独立的进程， 但每个进<br>程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是 千上万个请求也不在话<br>下。每个worker的线程可以把一个cpu的性能发挥到极致。所以worker数和服务器的cpu<br>数相等是最为适宜的。设少了会浪费cpu,设多了会造成cpu频繁切换上下文带来的损耗。</p>\n<p>设置worker数量</p>\n<pre><code class=\"lang-shell\">worker.processes 4 \n\n# work绑定cpu(4work绑定4cpu)\nworker_cpu_affinity 0001 0010 0100 1000\n\n# work绑定cpu (4work绑定8cpu中的4个)\nworker_cpu_affinity 00000001 00000010 00000100 00001000\n</code></pre>\n<p>5、连接数worker_ connection<br>这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx 能建立的最大连接数，应该是worker.connections <em> worker processes。当然，这里说的是最大连接数，对于HTTP 请求本地资源来说，能够支持的最大并发数量是worker.connections </em> worker processes,如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是: worker.connections <em> worker.processes / 2, 而如果是HTTP作为反向代理来说，最大并发数量应该是worker.connections </em> worker_proceses/4. 因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接.<br>第一个: 发送请求，占用了woker的几个连接数?<br>答案: 2或者4个。</p>\n<p>第二个: nginx有一个master,有四个woker,每个woker支持最大的连接数1024,支持的最大并发数是多少?<br>答案：普通的静态访问最大并发数是: worker connections <em> worker processes /2，<br>而如果是HTTP作为反向代理来说，最大并发数量应该是worker connections </em> worker processes/4</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/7.jpg', '/article/152', 44, '2020-09-26', NULL, 0, 130, 154, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (178, 'Redis学习笔记：（二）使用Linux和Docker安装Redis', '文章目录Linux安装Redis下载Redis安装Redis启动Redis关闭Redis联通测试Docker安装Redis获取Redis镜像查看本地镜像Redis配置文件下载配置文件创建文件夹,新建配置文件贴入从官网下载的配置文件并修改修改启动默认配置(从上至下依次)：运行Redis容器查看Redis运行查看运行容器查看运行日志进入', '## Linux安装Redis\n### 获取Redis\n1.下载获得redis-6.0.6.tar.gz后将它放入我们的Linux目录/opt\n```shell\nhttp://download.redis.io/releases/redis-6.0.6.tar.gz\n```\n![](https://img-blog.csdnimg.cn/20201012205510992.png#pic_center)\n\n2.解压Redis\n/opt目录下，解压redis-6.0.6.tar.gz\n```shell\ntar -zxvf redis-6.0.6.tar.gz\n```\n![](https://img-blog.csdnimg.cn/20201012210205607.png#pic_center)\n\n3.进入Redis目录 \n```\ncd redis-6.0.6.tar.gz\n```\n![](https://img-blog.csdnimg.cn/20201012210251806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n### 安装Redis\n\n1.在redis-6.0.6目录下执行make命令\n```\nmake\n```\n如果出现如下图所示报错，可能是缺少gcc解析器\n![](https://img-blog.csdnimg.cn/20201012211835623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n解决make报错问题，安装gcc套装：\n\n```\nyum install cpp\nyum install binutils\nyum install glibc\nyum install glibc-kernheaders\nyum install glibc-common\nyum install glibc-devel\nyum install gcc\nyum install make\n```\n升级gcc\n```shell\nyum -y install centos-release-scl\n\nyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils\n\nscl enable devtoolset-9 bash\n```\n设置永久升级：\n```shell\necho \"source /opt/rh/devtoolset-9/enable\" >>/etc/profile\n```\n2.再次执行make，执行成功\n![](https://img-blog.csdnimg.cn/20201012212127441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n\n3.make完成后继续执行make install\n```\nmake install\n```\n![](https://img-blog.csdnimg.cn/20201012211706399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n4.查看默认安装目录：usr/local/bin\n```\nll usr/local/bin\n```\n![](https://img-blog.csdnimg.cn/20201012212309786.png#pic_center)\n\n+ Redis-benchmark:性能测试工具（服务启动起来后执行），可以查看服务器性能如何\n+ Redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲\n+ Redis-check-dump：修复有问题的dump.rdb文件\n+ Redis-cli：客户端，操作入口\n+ Redis-sentinel：redis集群使用\n+ Redis-server：redis服务器启动命令\n\n### 启动Redis\n1.修改redis.conf文件将里面的daemonize no 改成 yes，让服务在后台启动\n![](https://img-blog.csdnimg.cn/20201012212758476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n![](https://img-blog.csdnimg.cn/20201012212908562.png#pic_center)\n\n2./usr/local/bin目录下运行redis-server，可以指定运行redis.conf文件的位置，并使用`ps-ef | grep redis`查看redis运行\n```\nredis-server /opt/redis-6.0.6/redis.conf\n```\n![](https://img-blog.csdnimg.cn/20201012213259894.png#pic_center)\n### 关闭Redis\n```\nredis-cli shutdown\n```\n![](https://img-blog.csdnimg.cn/2020101221364356.png#pic_center)\n\n### 联通测试\n![](https://img-blog.csdnimg.cn/20201012213442315.png#pic_center)\n\n\n## Docker安装Redis\n\n### 获取Redis镜像\n```shell\ndocker pull redis\n```\n![](https://img-blog.csdnimg.cn/20201012201610844.png#pic_center)\n\n### 查看本地镜像\n```shell\ndocker images\n```\n![](https://img-blog.csdnimg.cn/20201012201538999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n### Redis配置文件\n#### 下载配置文件\n从官网直接下载 [redis.conf](http://download.redis.io/redis-stable/redis.conf) 配置文件\n\nLinux获取 redis.conf 配置文件\n ```shell\nwget http://download.redis.io/redis-stable/redis.conf\n```\n\n#### 创建文件夹,新建配置文件贴入从官网下载的配置文件并修改\n```shell\nmkdir /usr/local/docker/redis\n\nvim /usr/local/docker/redis/redis.conf\n```\n#### 修改启动默认配置(从上至下依次)：\n\n+ bind 127.0.0.1  #注释掉这部分，这是限制redis只能本地访问\n+ protected-mode no  #默认yes，开启保护模式，限制为本地访问\n+ daemonize no #默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程（可选），改为yes会使配置文件方式启动redis失败\n+ dir  ./  #输入本地redis数据库存放文件夹（可选）\n+ appendonly yes  #redis持久化（可选）\n\n### 运行Redis容器\n```shell\ndocker run -p 6379:6379 --name redis -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n```\n命令解释说明：\n\n- -p 6379:6379 端口映射，“：”前表示主机部分 “：”后表示容器部分。\n\n+ \\--name redis  指定该容器名称，查看和进行操作都比较方便。\n\n+ -v 挂载目录，规则与端口映射相同。\n\n	为什么需要挂载目录：个人认为docker是个沙箱隔离级别的容器，这个是它的特点及安全机制，不能随便访问外部（主机）资源目录，所以需要这个挂载目录机制。\n\n+ -d redis 表示后台启动redis\n\n+ redis-server /etc/redis/redis.conf  以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/docker/redis/redis.conf\n\n+ --appendonly yes  开启redis 持久化\n\n### 查看Redis运行\n#### 查看运行容器\n```shell\ndocker ps\n```\n![](https://img-blog.csdnimg.cn/20201012203814739.png#pic_center)\n\n#### 查看运行日志\n```shell\ndocker logs redis (容器名称)\n或者\ndocker logs b0ef3346c263 (容器id)\n```\n![](https://img-blog.csdnimg.cn/20201012204045624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n### 进入Redis容器并连接Redis\n![](https://img-blog.csdnimg.cn/20201012204356977.png#pic_center)\n', '<h2 id=\"h2-linux-redis\"><a name=\"Linux安装Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Linux安装Redis</h2><h3 id=\"h3--redis\"><a name=\"获取Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>获取Redis</h3><p>1.下载获得redis-6.0.6.tar.gz后将它放入我们的Linux目录/opt</p>\n<pre><code class=\"lang-shell\">http://download.redis.io/releases/redis-6.0.6.tar.gz\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201012205510992.png#pic_center\" alt=\"\"></p>\n<p>2.解压Redis<br>/opt目录下，解压redis-6.0.6.tar.gz</p>\n<pre><code class=\"lang-shell\">tar -zxvf redis-6.0.6.tar.gz\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201012210205607.png#pic_center\" alt=\"\"></p>\n<p>3.进入Redis目录 </p>\n<pre><code>cd redis-6.0.6.tar.gz\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/20201012210251806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h3 id=\"h3--redis\"><a name=\"安装Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>安装Redis</h3><p>1.在redis-6.0.6目录下执行make命令</p>\n<pre><code>make\n</code></pre><p>如果出现如下图所示报错，可能是缺少gcc解析器<br><img src=\"https://img-blog.csdnimg.cn/20201012211835623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<p>解决make报错问题，安装gcc套装：</p>\n<pre><code>yum install cpp\nyum install binutils\nyum install glibc\nyum install glibc-kernheaders\nyum install glibc-common\nyum install glibc-devel\nyum install gcc\nyum install make\n</code></pre><p>升级gcc</p>\n<pre><code class=\"lang-shell\">yum -y install centos-release-scl\n\nyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils\n\nscl enable devtoolset-9 bash\n</code></pre>\n<p>设置永久升级：</p>\n<pre><code class=\"lang-shell\">echo &quot;source /opt/rh/devtoolset-9/enable&quot; &gt;&gt;/etc/profile\n</code></pre>\n<p>2.再次执行make，执行成功<br><img src=\"https://img-blog.csdnimg.cn/20201012212127441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<p>3.make完成后继续执行make install</p>\n<pre><code>make install\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/20201012211706399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<p>4.查看默认安装目录：usr/local/bin</p>\n<pre><code>ll usr/local/bin\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/20201012212309786.png#pic_center\" alt=\"\"></p>\n<ul>\n<li>Redis-benchmark:性能测试工具（服务启动起来后执行），可以查看服务器性能如何</li><li>Redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</li><li>Redis-check-dump：修复有问题的dump.rdb文件</li><li>Redis-cli：客户端，操作入口</li><li>Redis-sentinel：redis集群使用</li><li>Redis-server：redis服务器启动命令</li></ul>\n<h3 id=\"h3--redis\"><a name=\"启动Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>启动Redis</h3><p>1.修改redis.conf文件将里面的daemonize no 改成 yes，让服务在后台启动<br><img src=\"https://img-blog.csdnimg.cn/20201012212758476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20201012212908562.png#pic_center\" alt=\"\"></p>\n<p>2./usr/local/bin目录下运行redis-server，可以指定运行redis.conf文件的位置，并使用<code>ps-ef | grep redis</code>查看redis运行</p>\n<pre><code>redis-server /opt/redis-6.0.6/redis.conf\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/20201012213259894.png#pic_center\" alt=\"\"></p>\n<h3 id=\"h3--redis\"><a name=\"关闭Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>关闭Redis</h3><pre><code>redis-cli shutdown\n</code></pre><p><img src=\"https://img-blog.csdnimg.cn/2020101221364356.png#pic_center\" alt=\"\"></p>\n<h3 id=\"h3-u8054u901Au6D4Bu8BD5\"><a name=\"联通测试\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>联通测试</h3><p><img src=\"https://img-blog.csdnimg.cn/20201012213442315.png#pic_center\" alt=\"\"></p>\n<h2 id=\"h2-docker-redis\"><a name=\"Docker安装Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Docker安装Redis</h2><h3 id=\"h3--redis-\"><a name=\"获取Redis镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>获取Redis镜像</h3><pre><code class=\"lang-shell\">docker pull redis\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201012201610844.png#pic_center\" alt=\"\"></p>\n<h3 id=\"h3-u67E5u770Bu672Cu5730u955Cu50CF\"><a name=\"查看本地镜像\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看本地镜像</h3><pre><code class=\"lang-shell\">docker images\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201012201538999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h3 id=\"h3-redis-\"><a name=\"Redis配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Redis配置文件</h3><h4 id=\"h4-u4E0Bu8F7Du914Du7F6Eu6587u4EF6\"><a name=\"下载配置文件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>下载配置文件</h4><p>从官网直接下载 <a href=\"http://download.redis.io/redis-stable/redis.conf\">redis.conf</a> 配置文件</p>\n<p>Linux获取 redis.conf 配置文件</p>\n<pre><code class=\"lang-shell\">wget http://download.redis.io/redis-stable/redis.conf\n</code></pre>\n<h4 id=\"h4--\"><a name=\"创建文件夹,新建配置文件贴入从官网下载的配置文件并修改\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>创建文件夹,新建配置文件贴入从官网下载的配置文件并修改</h4><pre><code class=\"lang-shell\">mkdir /usr/local/docker/redis\n\nvim /usr/local/docker/redis/redis.conf\n</code></pre>\n<h4 id=\"h4--\"><a name=\"修改启动默认配置(从上至下依次)：\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>修改启动默认配置(从上至下依次)：</h4><ul>\n<li>bind 127.0.0.1  #注释掉这部分，这是限制redis只能本地访问</li><li>protected-mode no  #默认yes，开启保护模式，限制为本地访问</li><li>daemonize no #默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程（可选），改为yes会使配置文件方式启动redis失败</li><li>dir  ./  #输入本地redis数据库存放文件夹（可选）</li><li>appendonly yes  #redis持久化（可选）</li></ul>\n<h3 id=\"h3--redis-\"><a name=\"运行Redis容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>运行Redis容器</h3><pre><code class=\"lang-shell\">docker run -p 6379:6379 --name redis -v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf -v /usr/local/docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\n</code></pre>\n<p>命令解释说明：</p>\n<ul>\n<li>-p 6379:6379 端口映射，“：”前表示主机部分 “：”后表示容器部分。</li></ul>\n<ul>\n<li><p>--name redis  指定该容器名称，查看和进行操作都比较方便。</p>\n</li><li><p>-v 挂载目录，规则与端口映射相同。</p>\n<p>  为什么需要挂载目录：个人认为docker是个沙箱隔离级别的容器，这个是它的特点及安全机制，不能随便访问外部（主机）资源目录，所以需要这个挂载目录机制。</p>\n</li><li><p>-d redis 表示后台启动redis</p>\n</li><li><p>redis-server /etc/redis/redis.conf  以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/docker/redis/redis.conf</p>\n</li><li><p>—appendonly yes  开启redis 持久化</p>\n</li></ul>\n<h3 id=\"h3--redis-\"><a name=\"查看Redis运行\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看Redis运行</h3><h4 id=\"h4-u67E5u770Bu8FD0u884Cu5BB9u5668\"><a name=\"查看运行容器\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看运行容器</h4><pre><code class=\"lang-shell\">docker ps\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201012203814739.png#pic_center\" alt=\"\"></p>\n<h4 id=\"h4-u67E5u770Bu8FD0u884Cu65E5u5FD7\"><a name=\"查看运行日志\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>查看运行日志</h4><pre><code class=\"lang-shell\">docker logs redis (容器名称)\n或者\ndocker logs b0ef3346c263 (容器id)\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20201012204045624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h3 id=\"h3--redis-redis\"><a name=\"进入Redis容器并连接Redis\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>进入Redis容器并连接Redis</h3><p><img src=\"https://img-blog.csdnimg.cn/20201012204356977.png#pic_center\" alt=\"\"></p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/15.jpg', '/article/178', 49, '2020-10-12', NULL, 0, 171, 183, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (183, 'Redis学习笔记：（三）Redis入门', 'PERSISTkey字符串命令设置指定key的值SETkeyvalue[EXseconds][PXmilliseconds][NX|XX]#key不存在时设置key的值,而这个命令则可以返回给定的有序集合键key中,对于一个所有成员的分值都相同的有序集合键key来说', '## Redis简介\nRedis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。\n\n## Redis的优缺点\n\n优点：\n\n读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。\n支持数据持久化，支持AOF和RDB两种持久化方式。\n支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。\n数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。\n支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。\n缺点：\n\n数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。\nRedis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。\n主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。\nRedis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。\n\n## Redis常用五大数据类型简介\n### String（字符串）\nstring是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。\nstring类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。\nstring类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M\n\n### Hash\nRedis Hash是一个键值对集合。\nRedis Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map<String,Object>\n### List（列表）\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表\n### Set（集合）\nRedis的Set是string类型的无序集合。它是通过HashTable实现实现的\n\n### Zset(sorted set：有序集合)\nRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\n\n\n## Redis常用命令\n只记录常用命令的简单用法，详细用法请参考[Redis API 文档](http://redisdoc.com/)\n\n### 数据库命令\n1. 检查给定 `key` 是否存在。\n	```shell\n	EXISTS key\n	```\n2. 返回 key 所储存的值的类型。\n	```shell\n	TYPE key\n	```\n3. 将 `key` 改名为 `newkey`\n	```shell\n	#当且仅当 `newkey` 存在时，将覆盖旧值 \n	RENAME key newkey\n	#当且仅当 `newkey` 不存在时，将 `key` 改名为 `newkey` \n	RENAMENX key newkey\n	```\n4. 将当前数据库的  `key ` 移动到给定的数据库  `db ` 当中。\n	```shell\n	MOVE key db\n	```\n5. 返回当前数据库的  `key ` 的数量。\n	```shell\n	DBSIZE\n	```\n6. 查找所有符合给定模式  `pattern ` 的  `key  `， 比如说：（`KEYS *`或者`KEYS h?llo` ）\n	```shell\n	KEYS pattern\n	```\n7. 清空数据库中的所有  `key `。\n	```shell\n	#清空当前数据库中的key\n	FLUSHDB  \n	#清空所有数据库中的key \n	FLUSHALL   \n	```\n8. 切换到指定的数据库，数据库索引号  `index  `用数字值指定，以 0 作为起始索引值。默认使用 0 号数据库。（Redis默认有16个数据库，可以在配置文件中设置）\n	```shell\n	SELECT\n	```\n9. 删除给定的一个或多个 ` key ` 。不存在的  `key ` 会被忽略。\n	```redis\n	DEL key [key …]\n	```\n10. 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。\n	```shell\n	# 以秒为单位给key设置生存时间\n	EXPIRE key seconds\n	# 以秒为单位设置 key 的过期 unix 时间戳\n	EXPIREAT key timestamp\n	# 以毫秒为单位给key设置生存时间\n	PEXPIRE key milliseconds\n	# 以毫秒为单位设置 key 的过期 unix 时间戳\n	PEXPIREAT key milliseconds-timestamp\n	```\n11. 返回给定 key 的剩余生存时间(TTL, time to live)。\n	```shell\n	# 以秒为单位返回 key 的剩余生存时间\n	TTL key\n	# 以毫秒为单位返回 key 的剩余生存时间\n	PTTL key\n	```\n12. 移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。\n	```shell\n	PERSIST key\n	```\n\n### 字符串命令\n\n1. 设置指定 key 的值\n	```shell\n	SET key value [EX seconds] [PX milliseconds] [NX|XX]\n	# key不存在时设置key的值,相当于 SET key value NX\n	SETNX key	\n	# 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟，SET key value EX seconds。\n	SETEX key seconds value\n	# 这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 key 的生存时间，相当于 SET key value PX milliseconds 。\n	PSETEX key milliseconds value\n	```\n	从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：\n +  EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。\n + PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。\n\n + NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。\n + XX ： 只在键已经存在时， 才对键进行设置操作。\n\n2. 获取指定 key 的值。\n	```redis\n	GET key	\n	```\n\n3. 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值（旧值不存在时返回`nil`）。\n	```redis\n	GETSET key value\n	```\n4. 将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值（旧值不存在时返回`nil`）。\n	```redis\n	STRLEN key\n	```\n\n5. 如果键 `key` 已经存在并且它的值是一个字符串， APPEND 命令将把 `value `追加到键 `key` 现有值的末尾。\n\n	```redis\n	APPEND key value\n	```\n	如果 `key` 不存在， APPEND 就简单地将键 `key` 的值设为` value` ， 就像执行 `SET key value` 一样。\n\n6. 获取存储在 `key`上的值的子字符\n	```redis\n	GETRANGE key start end\n	```\n	负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。\n7. 从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。（不存在的键 key 当作空白字符串处理。）\n	```redis\n	SETRANGE key offset value\n	```\n	\n8. 为键 key 储存的数字值加上某个值。\n	```shell\n	# 为键 key 储存的数字值加上1\n	INCR key  \n	# 为键 key 储存的数字值加上增量 increment\n	INCRBY key increment\n	# 为键 key 储存的值加上浮点数增量 increment 。\n	INCRBYFLOAT key increment\n	```\n	如果键` key `不存在， 那么它的值会先被初始化为 0 ， 然后再执行 `INCR` 命令。\n\n	如果键` key` 储存的值不能被解释为数字， 那么 `INCR` 命令将返回一个错误。\n	\n9. 为键 key 储存的数字值减去某个值。\n	```shell\n	# 为键 key 储存的数字值加上1\n	DECR key  \n	# 为键 key 储存的数字值加上增量 increment\n	DECRBY key increment\n	```\n10. 同时为多个键设置值。\n	```shell\n	MSET key value [key value …]\n	# 当且仅当所有给定键都不存在时， 为所有给定键设置值。\n	MSETNX key value [key value …]\n	```\n	`MSET` 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。\n11. 返回给定的一个或多个字符串键的值。\n	```shell\n	MGET key [key …]\n	```\n	如果给定的字符串键里面， 有某个键不存在， 那么这个键的值将以特殊值 `nil `表示。\n\n\n### 哈希命令\n1. 将哈希表 hash 中域 field 的值设置为 value 。\n	```shell\n	# 如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。\n	HSET hash field value\n	# 当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value\n	HSETNX hash field value\n	```\n	\n	如果域 `field `已经存在于哈希表中， 那么它的旧值将被新值 `value `覆盖。\n\n2.  返回哈希表中给定域的值。\n	```shell\n	HGET hash field\n	```\n3. 检查给定域 field 是否存在于哈希表 hash 当中。\n	```shell\n	HEXISTS hash field\n	```\n4. 删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。\n	```shell\n	HDEL key field [field …]\n	```\n5. 获取哈希表 key 中域的数量。\n	```shell\n	HLEN key\n	```\n6. 返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。\n	```shell\n	HSTRLEN key field\n	```\n7. 为哈希表 key 中的域 field 的值加上增量 increment 。\n	```shell\n	HINCRBY key field increment\n	# 为哈希表 key 中的域 field 加上浮点数增量 increment\n	HINCRBYFLOAT key field increment\n	```\n	增量也可以为负数，相当于对给定域进行减法操作。\n\n	如果 `key` 不存在，一个新的哈希表被创建并执行命令。\n	\n	如果域 `field `不存在，那么在执行命令前，域的值被初始化为 0 。\n	\n	对一个储存字符串值的域 `field `执行命令将造成一个错误。\n	\n	本操作的值被限制在 64 位(bit)有符号数字表示之内。\n8. 同时将多个 field-value (域-值)对设置到哈希表 key 中。\n	```shell\n	HMSET key field value [field value …]\n	```\n	此命令会覆盖哈希表中已存在的域。\n\n	如果` key` 不存在，一个空哈希表被创建并执行 HMSET 操作。\n9. 返回哈希表 key 中，一个或多个给定域的值。\n	```shell\n	HMGET key field [field …]\n	```\n10. 返回哈希表 key 中的所有域。\n	```shell\n	HKEYS key\n	```\n11. 返回哈希表 key 中所有域的值。\n	```shell\n	HVALS key\n	```\n12. 返回哈希表 key 中，所有的域和值。\n	```shell\n	HGETALL key\n	```\n13. 迭代哈希表中的键值对。\n	```shell\n	HSCAN key cursor [MATCH pattern] [COUNT count]\n	```\n\n### 列表命令\n\n1. 将一个或多个值 value 插入到列表 `key` 中。\n\n	```shell\n	# 将一个或多个值 value 插入到列表 key 的表头\n	LPUSH key value [value …]\n	# 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。\n	LPUSHX key value\n	# 将一个或多个值 value 插入到列表 key 的表尾(最右边)。\n	RPUSH key value [value …]\n	# 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。\n	RPUSHX key value\n	```\n2. 移除并返回列表 key 的元素。\n	```shell\n	# 移除并返回列表 key 的头元素\n	LPOP key\n	# 移除并返回列表 key 的尾元素。\n	RPOP key\n	```\n4. 将列表 `list1`中的最后一个元素(尾元素)弹出，并返回给客户端。将 `list1`弹出的元素插入到列表 `list2`，作为 `list2`列表的的头元素。\n	```shell\n	RPOPLPUSH list1 list2\n	```\n5. 根据参数 count 的值，移除列表中与参数 value 相等的元素。\n	```shell\n	LREM key count value\n	```\n	`count `的值可以是以下几种：\n\n	`count` > 0 : 从表头开始向表尾搜索，移除与` value `相等的元素，数量为 `count `。\n	\n	`count` < 0 : 从表尾开始向表头搜索，移除与 `value `相等的元素，数量为 `count `的绝对值。\n	\n	`count `= 0 : 移除表中所有与 `value `相等的值。\n6. 返回列表 key 的长度。\n	```shell\n	LLEN key\n	```\n7. 返回列表 key 中，下标为 index 的元素。\n	```shell\n	LINDEX key index\n	```\n	`index`可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。\n8. 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。\n	```shell\n	LINSERT key BEFORE|AFTER pivot value\n	```\n	当 pivot 不存在于列表 key 时，不执行任何操作。\n	\n	当 key 不存在时， key 被视为空列表，不执行任何操作。\n	\n	如果 key 不是列表类型，返回一个错误。\n9. 将列表 key 下标为 index 的元素的值设置为 value 。\n	```shell\n	LSET key index value\n	```\n	当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。\n10. 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。\n	```shell\n	LRANGE key start stop\n	```\n	`stop`也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。\n\n11. 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。\n	```shell\n	LTRIM key start stop\n	```\n12. 阻塞式(blocking)弹出命令。\n	```shell\n	# LPOP命令的阻塞版本，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n	BLPOP key [key …] timeout\n	# RPOP命令的阻塞版本，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n	BRPOP key [key …] timeout\n	# RPOPLPUSH命令的阻塞版本，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n	BRPOPLPUSH source destination timeout\n	```\n\n### 集合命令\n\n1. 将一个或多个 member 元素加入到集合 key 当中。\n	```shell\n	SADD key member [member …]\n	```\n	已经存在于集合的 `member` 元素将被忽略。\n	\n	假如 `key` 不存在，则创建一个只包含 `member` 元素作成员的集合。\n	\n	当 `key` 不是集合类型时，返回一个错误。\n\n2. 判断 member 元素是否集合 key 的成员。\n	```shell\n	SISMEMBER key member\n	```\n3. 返回集合中的随机元素。\n	```shell\n	# 删除并返回集合中的一个随机元素。\n	SPOP key\n	# 返回单不删除集合中的count个元素。\n	# 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。\n	# 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。\n	# 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。\n	SRANDMEMBER key [count]\n	```\n4. 移除集合 key 中的一个或多个 member 元素。\n	```shell\n	SREM key member [member …]\n	```\n5. 将 `member `元素从` set1` 集合移动到 `set2`集合。\n	```shell\n	SMOVE set1 set2 member\n	```\n	SMOVE 是原子性操作。\n\n	如果 `set1` 集合不存在或不包含指定的 `member` 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。\n	\n	当 `set2`集合已经包含 member 元素时， SMOVE 命令只是简单地将 `set1`集合中的 `member` 元素删除。\n	\n	当 `set1`或 `set2`不是集合类型时，返回一个错误。\n6. 返回集合中元素的数量。\n	```shell\n	SCARD key\n	```\n7. 返回集合 key 中的所有成员。\n	```shell\n	SMEMBERS key\n	```\n8. 返回给定集合的成员。\n	```shell\n	# 返回是所有给定集合的交集。\n	SINTER key [key …]\n	# 类似于 SINTER key [key …]，但它将结果保存到 destination 集合，而不是简单地返回。\n	SINTERSTORE destination key [key …]\n	# 返回是所有给定集合的并集。\n	SUNION key [key …]\n	# 类似于 SUNION key [key …]，但它将结果保存到 destination 集合，而不是简单地返回。\n	SUNIONSTORE destination key [key …]\n	# 返回是所有给定集合的差集。\n	SDIFF key [key …]\n	# 类似于 SDIFF key [key …]，但它将结果保存到 destination 集合，而不是简单地返回。\n	SDIFFSTORE destination key [key …]\n	\n	```\n9. 迭代集合中的值。\n	```shell\n	SSCAN key cursor [MATCH pattern] [COUNT count]\n	```\n\n\n### 有序集合命令\n\n1. 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。\n	```shell\n	ZADD key score member [[score member] [score member] …]\n	```\n	\n	如果某个 `member` 已经是有序集的成员，那么更新这个 `member` 的 `score` 值，并通过重新插入这个 `member` 元素，来保证该 `member` 在正确的位置上。\n	\n	`score` 值可以是整数值或双精度浮点数。\n	\n	如果` key` 不存在，则创建一个空的有序集并执行 `ZADD` 操作。\n	\n	当 `key` 存在但不是有序集类型时，返回一个错误。\n2. 返回有序集 key 中，成员 member 的 score 值。\n	```shell\n	ZSCORE key member\n	```\n3. 为有序集 key 的成员 member 的 score 值加上增量 increment 。\n	```shelll\n	ZINCRBY key increment member\n	```\n	可以通过传递一个负数值 `increment `，让 `score` 减去相应的值，比如 `ZINCRBY key -5 member`  。\n	\n	当 `key `不存在，或` member` 不是 `key` 的成员时，` ZINCRBY key increment member `等同于 `ZADD key increment member` 。\n4. 返回有序集 key 元素的数量。\n	```shell\n	ZCARD key\n	```\n\n5. 返回有序集 key 中，指定索引区间内的成员。\n	```shell\n	# 其中成员的位置按 score 值递增(从小到大)来排序。\n	ZRANGE key start stop [WITHSCORES]\n	# 成员的位置按 score 值递减(从大到小)来排列。\n	ZREVRANGE key start stop [WITHSCORES]\n	```\n	下标参数 `start` 和 `stop` 都以 0 为底，也就是说，以 `0 `表示有序集第一个成员，以 `1 `表示有序集第二个成员，以此类推。 你也可以使用负数下标，以` -1` 表示最后一个成员， `-2` 表示倒数第二个成员，以此类推。\n\n	具有相同` score` 值的成员按字典序(lexicographical order )来排列。\n	\n	超出范围的下标并不会引起错误。 比如说，当 `start `的值比有序集的最大下标还要大，或是` start > stop` 时， `ZRANGE` 命令只是简单地返回一个空列表。 另一方面，假如 `stop `参数的值比有序集的最大下标还要大，那么 Redis 将 `stop` 当作最大下标来处理。\n	\n	可以通过使用 `WITHSCORES` 选项，来让成员和它的 score 值一并返回，返回列表以 `value1,score1, ..., valueN,scoreN` 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。\n\n6. 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。\n	```shell\n	ZCOUNT key min max\n	```\n	`min` 和 `max` 可以是 `-inf `和 `+inf` ，这样一来，你就可以在不知道有序集的最低和最高 `score `值的情况下，使用 `ZRANGEBYSCORE `这类命令。\n	\n	默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 `( `符号来使用可选的开区间 (小于或大于)。\n\n7. 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。\n	```shell\n	# 其中成员的位置按 score 值递增(从小到大)来排序。\n	ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\n	# 其中成员的位置按 score 值递增(从大到小)来排序。\n	ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\n	```\n	可选的 `LIMIT` 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 `offset` 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。\n8. 返回有序集 key 中成员 member 的排名。\n	```shell\n	# 按 score 值递增(从小到大)顺序排列。\n	ZRANK key member\n	# 按 score 值递增(从大到小)顺序排列。\n	ZREVRANK key member\n	```\n	排名以` 0 `为底，也就是说，` score `值最小的成员排名为` 0 `。\n\n9. 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。\n	```shell\n	# 移除指定的 member\n	ZREM key member [member …]\n	# 移除指定排名(rank)介于start和stop区间内的所有成员。\n	ZREMRANGEBYRANK key start stop\n	# 移除score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。\n	ZREMRANGEBYSCORE key min max\n	```\n10. 当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。\n	```shell\n	ZRANGEBYLEX key min max [LIMIT offset count]\n	```\n	合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。\n\n	特殊值` + `和` - `在` min `参数以及 `max` 参数中具有特殊的意义， 其中` + `表示正无限， 而 `- `表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 `ZRANGEBYLEX <zset> - +` ， 命令将返回有序集合中的所有元素。\n	 示类代码：\n	 ```shell\n	redis> ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g\n	(integer) 7\n	\n	redis> ZRANGEBYLEX myzset - [c\n	1) \"a\"\n	2) \"b\"\n	3) \"c\"\n	\n	redis> ZRANGEBYLEX myzset - (c\n	1) \"a\"\n	2) \"b\"\n	\n	redis> ZRANGEBYLEX myzset [aaa (g\n	1) \"b\"\n	2) \"c\"\n	3) \"d\"\n	4) \"e\"\n	5) \"f\"\n	```\n\n11. 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。\n	```shell\n	ZLEXCOUNT key min max\n	```\n12. 对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。\n	```shell\n	ZREMRANGEBYLEX key min max\n	```\n13. 计算给定的一个或多个有序集的结果集，并将该结果集储存到 destination 。\n	```shell\n	# 计算给定的一个或多个有序集的并集，并将该并集(结果集)储存到 destination 。\n	ZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]\n	# 计算给定的一个或多个有序集的交集，并将该交集(结果集)储存到 destination 。\n	ZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]\n	```\n	其中给定 key 的数量必须以 numkeys 参数指定。\n	\n	使用 `WEIGHTS` 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 `WEIGHTS` 选项，乘法因子默认设置为 1 。\n	\n	使用 `AGGREGATE` 选项，你可以指定并集的结果集的聚合方式。默认使用的参数 `SUM` ，可以将所有集合中某个成员的`score `值之 和 作为结果集中该成员的 `score `值；使用参数 `MIN` ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数` MAX `则是将所有集合中某个成员的 最大` score` 值作为结果集中该成员的` score` 值。\n14. 迭代有序集合中的元素（包括元素成员和元素分值）\n	```shell\n	ZSCAN key cursor [MATCH pattern] [COUNT count]\n	```', '<h2 id=\"h2-redis-\"><a name=\"Redis简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Redis简介</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>\n<h2 id=\"h2-redis-\"><a name=\"Redis的优缺点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Redis的优缺点</h2><p>优点：</p>\n<p>读写性能优异， Redis能读的速度是110000次/s，写的速度是81000次/s。<br>支持数据持久化，支持AOF和RDB两种持久化方式。<br>支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。<br>数据结构丰富，除了支持string类型的value外还支持hash、set、zset、list等数据结构。<br>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。<br>缺点：</p>\n<p>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。<br>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。<br>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。<br>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</p>\n<h2 id=\"h2-redis-\"><a name=\"Redis常用五大数据类型简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Redis常用五大数据类型简介</h2><h3 id=\"h3-string-\"><a name=\"String（字符串）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>String（字符串）</h3><p>string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。<br>string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。<br>string类型是Redis最基本的数据类型，一个redis中字符串value最多可以是512M</p>\n<h3 id=\"h3-hash\"><a name=\"Hash\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Hash</h3><p>Redis Hash是一个键值对集合。<br>Redis Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。类似Java里面的Map&lt;String,Object&gt;</p>\n<h3 id=\"h3-list-\"><a name=\"List（列表）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>List（列表）</h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个链表</p>\n<h3 id=\"h3-set-\"><a name=\"Set（集合）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Set（集合）</h3><p>Redis的Set是string类型的无序集合。它是通过HashTable实现实现的</p>\n<h3 id=\"h3-zset-sorted-set-\"><a name=\"Zset(sorted set：有序集合)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Zset(sorted set：有序集合)</h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。<br>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。<br>zset的成员是唯一的,但分数(score)却可以重复。</p>\n<h2 id=\"h2-redis-\"><a name=\"Redis常用命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Redis常用命令</h2><p>只记录常用命令的简单用法，详细用法请参考<a href=\"http://redisdoc.com/\">Redis API 文档</a></p>\n<h3 id=\"h3-u6570u636Eu5E93u547Du4EE4\"><a name=\"数据库命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>数据库命令</h3><ol>\n<li>检查给定 <code>key</code> 是否存在。<pre><code class=\"lang-shell\"> EXISTS key\n</code></pre>\n</li><li>返回 key 所储存的值的类型。<pre><code class=\"lang-shell\"> TYPE key\n</code></pre>\n</li><li>将 <code>key</code> 改名为 <code>newkey</code><pre><code class=\"lang-shell\"> #当且仅当 `newkey` 存在时，将覆盖旧值 \n RENAME key newkey\n #当且仅当 `newkey` 不存在时，将 `key` 改名为 `newkey` \n RENAMENX key newkey\n</code></pre>\n</li><li>将当前数据库的  <code>key</code> 移动到给定的数据库  <code>db</code> 当中。<pre><code class=\"lang-shell\"> MOVE key db\n</code></pre>\n</li><li>返回当前数据库的  <code>key</code> 的数量。<pre><code class=\"lang-shell\"> DBSIZE\n</code></pre>\n</li><li>查找所有符合给定模式  <code>pattern</code> 的  <code>key</code>， 比如说：（<code>KEYS *</code>或者<code>KEYS h?llo</code> ）<pre><code class=\"lang-shell\"> KEYS pattern\n</code></pre>\n</li><li>清空数据库中的所有  <code>key</code>。<pre><code class=\"lang-shell\"> #清空当前数据库中的key\n FLUSHDB  \n #清空所有数据库中的key \n FLUSHALL\n</code></pre>\n</li><li>切换到指定的数据库，数据库索引号  <code>index</code>用数字值指定，以 0 作为起始索引值。默认使用 0 号数据库。（Redis默认有16个数据库，可以在配置文件中设置）<pre><code class=\"lang-shell\"> SELECT\n</code></pre>\n</li><li>删除给定的一个或多个 <code>key</code> 。不存在的  <code>key</code> 会被忽略。<pre><code class=\"lang-redis\"> DEL key [key …]\n</code></pre>\n</li><li>为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。<pre><code class=\"lang-shell\"># 以秒为单位给key设置生存时间\nEXPIRE key seconds\n# 以秒为单位设置 key 的过期 unix 时间戳\nEXPIREAT key timestamp\n# 以毫秒为单位给key设置生存时间\nPEXPIRE key milliseconds\n# 以毫秒为单位设置 key 的过期 unix 时间戳\nPEXPIREAT key milliseconds-timestamp\n</code></pre>\n</li><li>返回给定 key 的剩余生存时间(TTL, time to live)。<pre><code class=\"lang-shell\"># 以秒为单位返回 key 的剩余生存时间\nTTL key\n# 以毫秒为单位返回 key 的剩余生存时间\nPTTL key\n</code></pre>\n</li><li>移除给定 key 的生存时间，将这个 key 从“易失的”(带生存时间 key )转换成“持久的”(一个不带生存时间、永不过期的 key )。<pre><code class=\"lang-shell\">PERSIST key\n</code></pre>\n</li></ol>\n<h3 id=\"h3-u5B57u7B26u4E32u547Du4EE4\"><a name=\"字符串命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>字符串命令</h3><ol>\n<li><p>设置指定 key 的值</p>\n<pre><code class=\"lang-shell\"> SET key value [EX seconds] [PX milliseconds] [NX|XX]\n # key不存在时设置key的值,相当于 SET key value NX\n SETNX key    \n # 将键 key 的值设置为 value ， 并将键 key 的生存时间设置为 seconds 秒钟，SET key value EX seconds。\n SETEX key seconds value\n # 这个命令和 SETEX 命令相似， 但它以毫秒为单位设置 key 的生存时间，相当于 SET key value PX milliseconds 。\n PSETEX key milliseconds value\n</code></pre>\n<p> 从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p>\n<ul>\n<li>EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。</li><li><p>PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。</p>\n</li><li><p>NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。</p>\n</li><li>XX ： 只在键已经存在时， 才对键进行设置操作。</li></ul>\n</li><li><p>获取指定 key 的值。</p>\n<pre><code class=\"lang-redis\"> GET key\n</code></pre>\n</li><li><p>将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值（旧值不存在时返回<code>nil</code>）。</p>\n<pre><code class=\"lang-redis\"> GETSET key value\n</code></pre>\n</li><li><p>将键 key 的值设为 value ， 并返回键 key 在被设置之前的旧值（旧值不存在时返回<code>nil</code>）。</p>\n<pre><code class=\"lang-redis\"> STRLEN key\n</code></pre>\n</li><li><p>如果键 <code>key</code> 已经存在并且它的值是一个字符串， APPEND 命令将把 <code>value</code>追加到键 <code>key</code> 现有值的末尾。</p>\n<pre><code class=\"lang-redis\"> APPEND key value\n</code></pre>\n<p> 如果 <code>key</code> 不存在， APPEND 就简单地将键 <code>key</code> 的值设为<code>value</code> ， 就像执行 <code>SET key value</code> 一样。</p>\n</li><li><p>获取存储在 <code>key</code>上的值的子字符</p>\n<pre><code class=\"lang-redis\"> GETRANGE key start end\n</code></pre>\n<p> 负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。</p>\n</li><li><p>从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。（不存在的键 key 当作空白字符串处理。）</p>\n<pre><code class=\"lang-redis\"> SETRANGE key offset value\n</code></pre>\n</li><li><p>为键 key 储存的数字值加上某个值。</p>\n<pre><code class=\"lang-shell\"> # 为键 key 储存的数字值加上1\n INCR key  \n # 为键 key 储存的数字值加上增量 increment\n INCRBY key increment\n # 为键 key 储存的值加上浮点数增量 increment 。\n INCRBYFLOAT key increment\n</code></pre>\n<p> 如果键<code>key</code>不存在， 那么它的值会先被初始化为 0 ， 然后再执行 <code>INCR</code> 命令。</p>\n<p> 如果键<code>key</code> 储存的值不能被解释为数字， 那么 <code>INCR</code> 命令将返回一个错误。</p>\n</li><li><p>为键 key 储存的数字值减去某个值。</p>\n<pre><code class=\"lang-shell\"> # 为键 key 储存的数字值加上1\n DECR key  \n # 为键 key 储存的数字值加上增量 increment\n DECRBY key increment\n</code></pre>\n</li><li>同时为多个键设置值。<pre><code class=\"lang-shell\">MSET key value [key value …]\n# 当且仅当所有给定键都不存在时， 为所有给定键设置值。\nMSETNX key value [key value …]\n</code></pre>\n<code>MSET</code> 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。</li><li>返回给定的一个或多个字符串键的值。<pre><code class=\"lang-shell\">MGET key [key …]\n</code></pre>\n如果给定的字符串键里面， 有某个键不存在， 那么这个键的值将以特殊值 <code>nil</code>表示。</li></ol>\n<h3 id=\"h3-u54C8u5E0Cu547Du4EE4\"><a name=\"哈希命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>哈希命令</h3><ol>\n<li><p>将哈希表 hash 中域 field 的值设置为 value 。</p>\n<pre><code class=\"lang-shell\"> # 如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。\n HSET hash field value\n # 当且仅当域 field 尚未存在于哈希表的情况下， 将它的值设置为 value\n HSETNX hash field value\n</code></pre>\n<p> 如果域 <code>field</code>已经存在于哈希表中， 那么它的旧值将被新值 <code>value</code>覆盖。</p>\n</li><li><p>返回哈希表中给定域的值。</p>\n<pre><code class=\"lang-shell\">HGET hash field\n</code></pre>\n</li><li>检查给定域 field 是否存在于哈希表 hash 当中。<pre><code class=\"lang-shell\"> HEXISTS hash field\n</code></pre>\n</li><li>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。<pre><code class=\"lang-shell\"> HDEL key field [field …]\n</code></pre>\n</li><li>获取哈希表 key 中域的数量。<pre><code class=\"lang-shell\"> HLEN key\n</code></pre>\n</li><li>返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。<pre><code class=\"lang-shell\"> HSTRLEN key field\n</code></pre>\n</li><li><p>为哈希表 key 中的域 field 的值加上增量 increment 。</p>\n<pre><code class=\"lang-shell\"> HINCRBY key field increment\n # 为哈希表 key 中的域 field 加上浮点数增量 increment\n HINCRBYFLOAT key field increment\n</code></pre>\n<p> 增量也可以为负数，相当于对给定域进行减法操作。</p>\n<p> 如果 <code>key</code> 不存在，一个新的哈希表被创建并执行命令。</p>\n<p> 如果域 <code>field</code>不存在，那么在执行命令前，域的值被初始化为 0 。</p>\n<p> 对一个储存字符串值的域 <code>field</code>执行命令将造成一个错误。</p>\n<p> 本操作的值被限制在 64 位(bit)有符号数字表示之内。</p>\n</li><li><p>同时将多个 field-value (域-值)对设置到哈希表 key 中。</p>\n<pre><code class=\"lang-shell\"> HMSET key field value [field value …]\n</code></pre>\n<p> 此命令会覆盖哈希表中已存在的域。</p>\n<p> 如果<code>key</code> 不存在，一个空哈希表被创建并执行 HMSET 操作。</p>\n</li><li>返回哈希表 key 中，一个或多个给定域的值。<pre><code class=\"lang-shell\"> HMGET key field [field …]\n</code></pre>\n</li><li>返回哈希表 key 中的所有域。<pre><code class=\"lang-shell\">HKEYS key\n</code></pre>\n</li><li>返回哈希表 key 中所有域的值。<pre><code class=\"lang-shell\">HVALS key\n</code></pre>\n</li><li>返回哈希表 key 中，所有的域和值。<pre><code class=\"lang-shell\">HGETALL key\n</code></pre>\n</li><li>迭代哈希表中的键值对。<pre><code class=\"lang-shell\">HSCAN key cursor [MATCH pattern] [COUNT count]\n</code></pre>\n</li></ol>\n<h3 id=\"h3-u5217u8868u547Du4EE4\"><a name=\"列表命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>列表命令</h3><ol>\n<li><p>将一个或多个值 value 插入到列表 <code>key</code> 中。</p>\n<pre><code class=\"lang-shell\"> # 将一个或多个值 value 插入到列表 key 的表头\n LPUSH key value [value …]\n # 将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。\n LPUSHX key value\n # 将一个或多个值 value 插入到列表 key 的表尾(最右边)。\n RPUSH key value [value …]\n # 将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。\n RPUSHX key value\n</code></pre>\n</li><li>移除并返回列表 key 的元素。<pre><code class=\"lang-shell\"> # 移除并返回列表 key 的头元素\n LPOP key\n # 移除并返回列表 key 的尾元素。\n RPOP key\n</code></pre>\n</li><li>将列表 <code>list1</code>中的最后一个元素(尾元素)弹出，并返回给客户端。将 <code>list1</code>弹出的元素插入到列表 <code>list2</code>，作为 <code>list2</code>列表的的头元素。<pre><code class=\"lang-shell\"> RPOPLPUSH list1 list2\n</code></pre>\n</li><li><p>根据参数 count 的值，移除列表中与参数 value 相等的元素。</p>\n<pre><code class=\"lang-shell\"> LREM key count value\n</code></pre>\n<p> <code>count</code>的值可以是以下几种：</p>\n<p> <code>count</code> &gt; 0 : 从表头开始向表尾搜索，移除与<code>value</code>相等的元素，数量为 <code>count</code>。</p>\n<p> <code>count</code> &lt; 0 : 从表尾开始向表头搜索，移除与 <code>value</code>相等的元素，数量为 <code>count</code>的绝对值。</p>\n<p> <code>count</code>= 0 : 移除表中所有与 <code>value</code>相等的值。</p>\n</li><li>返回列表 key 的长度。<pre><code class=\"lang-shell\"> LLEN key\n</code></pre>\n</li><li>返回列表 key 中，下标为 index 的元素。<pre><code class=\"lang-shell\"> LINDEX key index\n</code></pre>\n <code>index</code>可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</li><li><p>将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。</p>\n<pre><code class=\"lang-shell\"> LINSERT key BEFORE|AFTER pivot value\n</code></pre>\n<p> 当 pivot 不存在于列表 key 时，不执行任何操作。</p>\n<p> 当 key 不存在时， key 被视为空列表，不执行任何操作。</p>\n<p> 如果 key 不是列表类型，返回一个错误。</p>\n</li><li>将列表 key 下标为 index 的元素的值设置为 value 。<pre><code class=\"lang-shell\"> LSET key index value\n</code></pre>\n 当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</li><li><p>返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。</p>\n<pre><code class=\"lang-shell\">LRANGE key start stop\n</code></pre>\n<p><code>stop</code>也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>\n</li><li><p>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p>\n<pre><code class=\"lang-shell\">LTRIM key start stop\n</code></pre>\n</li><li>阻塞式(blocking)弹出命令。<pre><code class=\"lang-shell\"># LPOP命令的阻塞版本，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nBLPOP key [key …] timeout\n# RPOP命令的阻塞版本，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nBRPOP key [key …] timeout\n# RPOPLPUSH命令的阻塞版本，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nBRPOPLPUSH source destination timeout\n</code></pre>\n</li></ol>\n<h3 id=\"h3-u96C6u5408u547Du4EE4\"><a name=\"集合命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>集合命令</h3><ol>\n<li><p>将一个或多个 member 元素加入到集合 key 当中。</p>\n<pre><code class=\"lang-shell\"> SADD key member [member …]\n</code></pre>\n<p> 已经存在于集合的 <code>member</code> 元素将被忽略。</p>\n<p> 假如 <code>key</code> 不存在，则创建一个只包含 <code>member</code> 元素作成员的集合。</p>\n<p> 当 <code>key</code> 不是集合类型时，返回一个错误。</p>\n</li><li><p>判断 member 元素是否集合 key 的成员。</p>\n<pre><code class=\"lang-shell\"> SISMEMBER key member\n</code></pre>\n</li><li>返回集合中的随机元素。<pre><code class=\"lang-shell\"> # 删除并返回集合中的一个随机元素。\n SPOP key\n # 返回单不删除集合中的count个元素。\n # 如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。\n # 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。\n # 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。\n SRANDMEMBER key [count]\n</code></pre>\n</li><li>移除集合 key 中的一个或多个 member 元素。<pre><code class=\"lang-shell\"> SREM key member [member …]\n</code></pre>\n</li><li><p>将 <code>member</code>元素从<code>set1</code> 集合移动到 <code>set2</code>集合。</p>\n<pre><code class=\"lang-shell\"> SMOVE set1 set2 member\n</code></pre>\n<p> SMOVE 是原子性操作。</p>\n<p> 如果 <code>set1</code> 集合不存在或不包含指定的 <code>member</code> 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。</p>\n<p> 当 <code>set2</code>集合已经包含 member 元素时， SMOVE 命令只是简单地将 <code>set1</code>集合中的 <code>member</code> 元素删除。</p>\n<p> 当 <code>set1</code>或 <code>set2</code>不是集合类型时，返回一个错误。</p>\n</li><li>返回集合中元素的数量。<pre><code class=\"lang-shell\"> SCARD key\n</code></pre>\n</li><li>返回集合 key 中的所有成员。<pre><code class=\"lang-shell\"> SMEMBERS key\n</code></pre>\n</li><li><p>返回给定集合的成员。</p>\n<pre><code class=\"lang-shell\"> # 返回是所有给定集合的交集。\n SINTER key [key …]\n # 类似于 SINTER key [key …]，但它将结果保存到 destination 集合，而不是简单地返回。\n SINTERSTORE destination key [key …]\n # 返回是所有给定集合的并集。\n SUNION key [key …]\n # 类似于 SUNION key [key …]，但它将结果保存到 destination 集合，而不是简单地返回。\n SUNIONSTORE destination key [key …]\n # 返回是所有给定集合的差集。\n SDIFF key [key …]\n # 类似于 SDIFF key [key …]，但它将结果保存到 destination 集合，而不是简单地返回。\n SDIFFSTORE destination key [key …]\n</code></pre>\n</li><li>迭代集合中的值。<pre><code class=\"lang-shell\"> SSCAN key cursor [MATCH pattern] [COUNT count]\n</code></pre>\n</li></ol>\n<h3 id=\"h3-u6709u5E8Fu96C6u5408u547Du4EE4\"><a name=\"有序集合命令\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>有序集合命令</h3><ol>\n<li><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p>\n<pre><code class=\"lang-shell\"> ZADD key score member [[score member] [score member] …]\n</code></pre>\n<p> 如果某个 <code>member</code> 已经是有序集的成员，那么更新这个 <code>member</code> 的 <code>score</code> 值，并通过重新插入这个 <code>member</code> 元素，来保证该 <code>member</code> 在正确的位置上。</p>\n<p> <code>score</code> 值可以是整数值或双精度浮点数。</p>\n<p> 如果<code>key</code> 不存在，则创建一个空的有序集并执行 <code>ZADD</code> 操作。</p>\n<p> 当 <code>key</code> 存在但不是有序集类型时，返回一个错误。</p>\n</li><li>返回有序集 key 中，成员 member 的 score 值。<pre><code class=\"lang-shell\"> ZSCORE key member\n</code></pre>\n</li><li><p>为有序集 key 的成员 member 的 score 值加上增量 increment 。</p>\n<pre><code class=\"lang-shelll\"> ZINCRBY key increment member\n</code></pre>\n<p> 可以通过传递一个负数值 <code>increment</code>，让 <code>score</code> 减去相应的值，比如 <code>ZINCRBY key -5 member</code>  。</p>\n<p> 当 <code>key</code>不存在，或<code>member</code> 不是 <code>key</code> 的成员时，<code>ZINCRBY key increment member</code>等同于 <code>ZADD key increment member</code> 。</p>\n</li><li><p>返回有序集 key 元素的数量。</p>\n<pre><code class=\"lang-shell\"> ZCARD key\n</code></pre>\n</li><li><p>返回有序集 key 中，指定索引区间内的成员。</p>\n<pre><code class=\"lang-shell\"> # 其中成员的位置按 score 值递增(从小到大)来排序。\n ZRANGE key start stop [WITHSCORES]\n # 成员的位置按 score 值递减(从大到小)来排列。\n ZREVRANGE key start stop [WITHSCORES]\n</code></pre>\n<p> 下标参数 <code>start</code> 和 <code>stop</code> 都以 0 为底，也就是说，以 <code>0</code>表示有序集第一个成员，以 <code>1</code>表示有序集第二个成员，以此类推。 你也可以使用负数下标，以<code>-1</code> 表示最后一个成员， <code>-2</code> 表示倒数第二个成员，以此类推。</p>\n<p> 具有相同<code>score</code> 值的成员按字典序(lexicographical order )来排列。</p>\n<p> 超出范围的下标并不会引起错误。 比如说，当 <code>start</code>的值比有序集的最大下标还要大，或是<code>start &gt; stop</code> 时， <code>ZRANGE</code> 命令只是简单地返回一个空列表。 另一方面，假如 <code>stop</code>参数的值比有序集的最大下标还要大，那么 Redis 将 <code>stop</code> 当作最大下标来处理。</p>\n<p> 可以通过使用 <code>WITHSCORES</code> 选项，来让成员和它的 score 值一并返回，返回列表以 <code>value1,score1, ..., valueN,scoreN</code> 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</p>\n</li><li><p>返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</p>\n<pre><code class=\"lang-shell\"> ZCOUNT key min max\n</code></pre>\n<p> <code>min</code> 和 <code>max</code> 可以是 <code>-inf</code>和 <code>+inf</code> ，这样一来，你就可以在不知道有序集的最低和最高 <code>score</code>值的情况下，使用 <code>ZRANGEBYSCORE</code>这类命令。</p>\n<p> 默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 <code>(</code>符号来使用可选的开区间 (小于或大于)。</p>\n</li><li><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。</p>\n<pre><code class=\"lang-shell\"> # 其中成员的位置按 score 值递增(从小到大)来排序。\n ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\n # 其中成员的位置按 score 值递增(从大到小)来排序。\n ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\n</code></pre>\n<p> 可选的 <code>LIMIT</code> 参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 <code>offset</code> 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。</p>\n</li><li><p>返回有序集 key 中成员 member 的排名。</p>\n<pre><code class=\"lang-shell\"> # 按 score 值递增(从小到大)顺序排列。\n ZRANK key member\n # 按 score 值递增(从大到小)顺序排列。\n ZREVRANK key member\n</code></pre>\n<p> 排名以<code>0</code>为底，也就是说，<code>score</code>值最小的成员排名为<code>0</code>。</p>\n</li><li><p>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p>\n<pre><code class=\"lang-shell\"> # 移除指定的 member\n ZREM key member [member …]\n # 移除指定排名(rank)介于start和stop区间内的所有成员。\n ZREMRANGEBYRANK key start stop\n # 移除score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。\n ZREMRANGEBYSCORE key min max\n</code></pre>\n</li><li><p>当有序集合的所有成员都具有相同的分值时， 有序集合的元素会根据成员的字典序（lexicographical ordering）来进行排序， 而这个命令则可以返回给定的有序集合键 key 中， 值介于 min 和 max 之间的成员。</p>\n<pre><code class=\"lang-shell\">ZRANGEBYLEX key min max [LIMIT offset count]\n</code></pre>\n<p>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。</p>\n<p>特殊值<code>+</code>和<code>-</code>在<code>min</code>参数以及 <code>max</code> 参数中具有特殊的意义， 其中<code>+</code>表示正无限， 而 <code>-</code>表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 <code>ZRANGEBYLEX &lt;zset&gt; - +</code> ， 命令将返回有序集合中的所有元素。<br> 示类代码：</p>\n<pre><code class=\"lang-shell\">redis&gt; ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g\n(integer) 7\n\nredis&gt; ZRANGEBYLEX myzset - [c\n1) &quot;a&quot;\n2) &quot;b&quot;\n3) &quot;c&quot;\n\nredis&gt; ZRANGEBYLEX myzset - (c\n1) &quot;a&quot;\n2) &quot;b&quot;\n\nredis&gt; ZRANGEBYLEX myzset [aaa (g\n1) &quot;b&quot;\n2) &quot;c&quot;\n3) &quot;d&quot;\n4) &quot;e&quot;\n5) &quot;f&quot;\n</code></pre>\n</li><li><p>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。</p>\n<pre><code class=\"lang-shell\">ZLEXCOUNT key min max\n</code></pre>\n</li><li>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会移除该集合中， 成员介于 min 和 max 范围内的所有元素。<pre><code class=\"lang-shell\">ZREMRANGEBYLEX key min max\n</code></pre>\n</li><li><p>计算给定的一个或多个有序集的结果集，并将该结果集储存到 destination 。</p>\n<pre><code class=\"lang-shell\"># 计算给定的一个或多个有序集的并集，并将该并集(结果集)储存到 destination 。\nZUNIONSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]\n# 计算给定的一个或多个有序集的交集，并将该交集(结果集)储存到 destination 。\nZINTERSTORE destination numkeys key [key …] [WEIGHTS weight [weight …]] [AGGREGATE SUM|MIN|MAX]\n</code></pre>\n<p>其中给定 key 的数量必须以 numkeys 参数指定。</p>\n<p>使用 <code>WEIGHTS</code> 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 <code>WEIGHTS</code> 选项，乘法因子默认设置为 1 。</p>\n<p>使用 <code>AGGREGATE</code> 选项，你可以指定并集的结果集的聚合方式。默认使用的参数 <code>SUM</code> ，可以将所有集合中某个成员的<code>score</code>值之 和 作为结果集中该成员的 <code>score</code>值；使用参数 <code>MIN</code> ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数<code>MAX</code>则是将所有集合中某个成员的 最大<code>score</code> 值作为结果集中该成员的<code>score</code> 值。</p>\n</li><li>迭代有序集合中的元素（包括元素成员和元素分值）<pre><code class=\"lang-shell\">ZSCAN key cursor [MATCH pattern] [COUNT count]\n</code></pre>\n</li></ol>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/4.jpg', '/article/183', 49, '2020-10-15', NULL, 0, 178, 191, 1, 0, 0, 1);
INSERT INTO `blog_article` VALUES (191, 'MySQL高级：explain分析执行计划', '表示的是查询中执行select子句或者是操作表的顺序,id相同表示加载表的顺序是从上到下,即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等table输出结果集的表type表示表的连接类型', '通过以上步骤查询到效率低的 SQL 语句后，可以通过 `EXPLAIN`或者 `DESC`命令获取 MySQL如何执行 SELECT 语句\n的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。\n查询SQL语句的执行计划 ：\n```sql\nexplain select * from tb_item where id = 1;\n```\n| 字段  | 含义  |\n| ------------ | ------------ |\n|  id |  select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。|\n|  select_type |  表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等|\n|table | 输出结果集的表 |\n|type|表示表的连接类型，性能由好到差的连接类型为( system ---> const -----> eq_ref ------> ref-------> ref_or_null----> index_merge ---> index_subquery -----> range -----> index ------>all )|\n|possible_keys |表示查询时，可能使用的索引|\n|key |表示实际使用的索引|\n|key_len |索引字段的长度|\n|rows |扫描行的数量|\n|extra |执行情况的说明和描述|\n\n## 环境准备\n![](/images/190/1606054155461160605383.png)\n```sql\nCREATE TABLE `t_role` (\n`id` varchar(32) NOT NULL,\n`role_name` varchar(255) DEFAULT NULL,\n`role_code` varchar(255) DEFAULT NULL,\n`description` varchar(255) DEFAULT NULL,\nPRIMARY KEY (`id`),\nUNIQUE KEY `unique_role_name` (`role_name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `t_user` (\n`id` varchar(32) NOT NULL,\n`username` varchar(45) NOT NULL,\n`password` varchar(96) NOT NULL,\n`name` varchar(45) NOT NULL,\nPRIMARY KEY (`id`),\nUNIQUE KEY `unique_user_username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `user_role` (\n`id` int(11) NOT NULL auto_increment ,\n`user_id` varchar(32) DEFAULT NULL,\n`role_id` varchar(32) DEFAULT NULL,\nPRIMARY KEY (`id`),\nKEY `fk_ur_user_id` (`user_id`),\nKEY `fk_ur_role_id` (`role_id`),\nCONSTRAINT `fk_ur_role_id` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`) ON\nDELETE NO ACTION ON UPDATE NO ACTION,\nCONSTRAINT `fk_ur_user_id` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON\nDELETE NO ACTION ON UPDATE NO ACTION\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(\'1\',\'super\',\'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe\',\'\n超级管理员\');\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(\'2\',\'admin\',\'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe\',\'\n系统管理员\');\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(\'3\',\'itcast\',\'$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui\',\n\'test02\');\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(\'4\',\'stu1\',\'$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa\',\'学\n生1\');\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(\'5\',\'stu2\',\'$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm\',\'学\n生2\');\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(\'6\',\'t1\',\'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe\',\'老师\n1\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'5\',\'学\n生\',\'student\',\'学生\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'7\',\'老\n师\',\'teacher\',\'老师\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'8\',\'教\n学管理员\',\'teachmanager\',\'教学管理员\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'9\',\'管\n理员\',\'admin\',\'管理员\');\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(\'10\',\'超\n级管理员\',\'super\',\'超级管理员\');\n```\n3.3.2 explain 之 id\n\nid 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种：\n1. id 相同表示加载表的顺序是从上到下。\n2. id 不同id值越大，优先级越高，越先被执行。\n3. id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。\n\n3.3.3 explain 之 select_type\n表示 SELECT 的类型，常见的取值，如下表所示：\n\n|  select_type |  含义 |\n| ------------ | ------------ |\n|  SIMPLE |  简单的select查询，查询中不包含子查询或者UNION |\n| PRIMARY  | 查询中若包含任何复杂的子查询，最外层查询标记为该标识  |\n|  SUBQUERY |  在SELECT 或 WHERE 列表中包含了子查询  |\n|  DERIVED |  在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中 |\n| UNION  |  若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子\n查询中，外层SELECT将被标记为 ： DERIVED |\n| UNION\nRESULT  |  从UNION表获取结果的SELECT |\n\n\n\n\n\n', '<p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 <code>EXPLAIN</code>或者 <code>DESC</code>命令获取 MySQL如何执行 SELECT 语句<br>的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>查询SQL语句的执行计划 ：</p>\n<pre><code class=\"lang-sql\">explain select * from tb_item where id = 1;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td>\n</tr>\n<tr>\n<td>table</td>\n<td>输出结果集的表</td>\n</tr>\n<tr>\n<td>type</td>\n<td>表示表的连接类型，性能由好到差的连接类型为( system —-&gt; const ——-&gt; eq_ref ———&gt; ref———-&gt; ref_or_null——&gt; index_merge —-&gt; index_subquery ——-&gt; range ——-&gt; index ———&gt;all )</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>表示查询时，可能使用的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>表示实际使用的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>索引字段的长度</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>扫描行的数量</td>\n</tr>\n<tr>\n<td>extra</td>\n<td>执行情况的说明和描述</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2-u73AFu5883u51C6u5907\"><a name=\"环境准备\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>环境准备</h2><p><img src=\"/images/190/1606054155461160605383.png\" alt=\"\"></p>\n<pre><code class=\"lang-sql\">CREATE TABLE `t_role` (\n`id` varchar(32) NOT NULL,\n`role_name` varchar(255) DEFAULT NULL,\n`role_code` varchar(255) DEFAULT NULL,\n`description` varchar(255) DEFAULT NULL,\nPRIMARY KEY (`id`),\nUNIQUE KEY `unique_role_name` (`role_name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `t_user` (\n`id` varchar(32) NOT NULL,\n`username` varchar(45) NOT NULL,\n`password` varchar(96) NOT NULL,\n`name` varchar(45) NOT NULL,\nPRIMARY KEY (`id`),\nUNIQUE KEY `unique_user_username` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nCREATE TABLE `user_role` (\n`id` int(11) NOT NULL auto_increment ,\n`user_id` varchar(32) DEFAULT NULL,\n`role_id` varchar(32) DEFAULT NULL,\nPRIMARY KEY (`id`),\nKEY `fk_ur_user_id` (`user_id`),\nKEY `fk_ur_role_id` (`role_id`),\nCONSTRAINT `fk_ur_role_id` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`) ON\nDELETE NO ACTION ON UPDATE NO ACTION,\nCONSTRAINT `fk_ur_user_id` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON\nDELETE NO ACTION ON UPDATE NO ACTION\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(&#39;1&#39;,&#39;super&#39;,&#39;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;\n超级管理员&#39;);\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(&#39;2&#39;,&#39;admin&#39;,&#39;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;\n系统管理员&#39;);\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(&#39;3&#39;,&#39;itcast&#39;,&#39;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#39;,\n&#39;test02&#39;);\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(&#39;4&#39;,&#39;stu1&#39;,&#39;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#39;,&#39;学\n生1&#39;);\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(&#39;5&#39;,&#39;stu2&#39;,&#39;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#39;,&#39;学\n生2&#39;);\ninsert into `t_user` (`id`, `username`, `password`, `name`)\nvalues(&#39;6&#39;,&#39;t1&#39;,&#39;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#39;,&#39;老师\n1&#39;);\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#39;5&#39;,&#39;学\n生&#39;,&#39;student&#39;,&#39;学生&#39;);\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#39;7&#39;,&#39;老\n师&#39;,&#39;teacher&#39;,&#39;老师&#39;);\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#39;8&#39;,&#39;教\n学管理员&#39;,&#39;teachmanager&#39;,&#39;教学管理员&#39;);\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#39;9&#39;,&#39;管\n理员&#39;,&#39;admin&#39;,&#39;管理员&#39;);\nINSERT INTO `t_role` (`id`, `role_name`, `role_code`, `description`) VALUES(&#39;10&#39;,&#39;超\n级管理员&#39;,&#39;super&#39;,&#39;超级管理员&#39;);\n</code></pre>\n<p>3.3.2 explain 之 id</p>\n<p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种：</p>\n<ol>\n<li>id 相同表示加载表的顺序是从上到下。</li><li>id 不同id值越大，优先级越高，越先被执行。</li><li>id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</li></ol>\n<p>3.3.3 explain 之 select_type<br>表示 SELECT 的类型，常见的取值，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>select_type</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>SIMPLE</td>\n<td>简单的select查询，查询中不包含子查询或者UNION</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>在SELECT 或 WHERE 列表中包含了子查询</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子</td>\n</tr>\n</tbody>\n</table>\n<p>查询中，外层SELECT将被标记为 ： DERIVED |<br>| UNION<br>RESULT  |  从UNION表获取结果的SELECT |</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/10.jpg', '/article/191', 48, '2020-11-22', NULL, 0, 183, 193, 0, 1, 0, 1);
INSERT INTO `blog_article` VALUES (193, 'MySQL问题汇总（持续更新）', '1.MySQL的tinyint字段,JDBC的URL增加tinyInt1isBit=false参数,读取出来为true或者false问题MySQL官网这里说到当配置信息中tinyInt1isBit=true(默认为true)', '## 1.MySQL的tinyint字段，读取出来为true或者false问题\n\n[MySQL官网](https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-type-conversions.html)\n\n![](/images/192/1606109294281file_1606109294000.png)\n\n这里说到当配置信息中tinyInt1isBit=true(默认为true)，如果tinyint的长度设置为1，返回的就是boolean类型，如果大于1，返回integer类型\n\n解决方案 有两种：\n\nJDBC的URL增加 tinyInt1isBit=false参数，注意参数名区分大小写，否则不生效\n将tinyint（1）改为tinyint（N）N>1', '<h2 id=\"h2-1-mysql-tinyint-true-false-\"><a name=\"1.MySQL的tinyint字段，读取出来为true或者false问题\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>1.MySQL的tinyint字段，读取出来为true或者false问题</h2><p><a href=\"https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-type-conversions.html\">MySQL官网</a></p>\n<p><img src=\"/images/192/1606109294281file_1606109294000.png\" alt=\"\"></p>\n<p>这里说到当配置信息中tinyInt1isBit=true(默认为true)，如果tinyint的长度设置为1，返回的就是boolean类型，如果大于1，返回integer类型</p>\n<p>解决方案 有两种：</p>\n<p>JDBC的URL增加 tinyInt1isBit=false参数，注意参数名区分大小写，否则不生效<br>将tinyint（1）改为tinyint（N）N&gt;1</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/10.jpg', '/article/193', 48, '2020-11-23', NULL, 0, 191, 196, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (196, 'Oracle中connect by prior的使用', '用于表示是否是循环行,则表示所有满足查询条件的行作为根节点,三级部门2-2&#39', '## 作用\nconnect by主要用于父子，祖孙，上下级等层级关系的查询\n## 语法\n{ CONNECT BY [ NOCYCLE ] condition [AND condition]... [ START WITH condition ]\n| [START WITH condition] CONNECT BY [ NOCYCLE ] condition [AND condition]...}\n\n解释：\n\n|  关键字 |   含义|\n| ------------ | ------------ |\n| start with  |  指定起始节点的条件。为可选项，若该子句被省略，则表示所有满足查询条件的行作为根节点。 |\n|  connect by | 指定父子行的条件关系  |\n|prior | 查询父行的限定符，格式: prior column1 = column2 or column1 = prior column2 and ... ，prior跟父id放一边|\n|nocycle| 若数据表中存在循环行，那么不添加此关键字会报错，添加关键字后，便不会报错，但循环的两行只会显示其中的第一条。**循环行: 该行只有一个子行，而且子行又是该行的祖先行**|\n|connect_by_iscycle| 前置条件:在使用了nocycle之后才能使用此关键字，用于表示是否是循环行，0表示否，1 表示是|\n\n|connect_by_isleaf| 伪列,是否叶子节点，0否，1是|\n\n|level| 伪列,表示层级，值越小层级越高，最高节点为1|\n\n## 环境准备\n\n```shell\ncreate table dept_test(\n	dept_id number(18),\n	p_id number(18),\n	dept_name varchar2(200)\n);\n\n-- 添加数据\ninsert into dept_test values(\'1\',0,\'一级部门\');\ninsert into dept_test values(\'2\',1,\'二级部门1\');\ninsert into dept_test values(\'3\',1,\'二级部门2\');\ninsert into dept_test values(\'4\',2,\'三级部门1-1\');\ninsert into dept_test values(\'5\',2,\'三级部门1-2\');\ninsert into dept_test values(\'6\',3,\'三级部门2-1\');\ninsert into dept_test values(\'7\',3,\'三级部门2-2\');\n```\n\n![](/images/null/1606705355149部门组织架构.jpg)\n\n\n查询一级部门下所有子节点（自顶向下）\n```\nselect *,level,connect_by_isleaf from dept_test \nstart with dept_id = 1 （或者 p_id = 0）\nconnect by prior dept_id = p_id\n```\n\n查询三级部门2-2所有父节点（自底向上）\n```\nselect *,level,connect_by_isleaf from dept_test \nstart with dept_id = 7 \nconnect by prior p_id = dept_id\n```', '<h2 id=\"h2-u4F5Cu7528\"><a name=\"作用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>作用</h2><p>connect by主要用于父子，祖孙，上下级等层级关系的查询</p>\n<h2 id=\"h2-u8BEDu6CD5\"><a name=\"语法\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>语法</h2><p>{ CONNECT BY [ NOCYCLE ] condition [AND condition]… [ START WITH condition ]<br>| [START WITH condition] CONNECT BY [ NOCYCLE ] condition [AND condition]…}</p>\n<p>解释：</p>\n<table>\n<thead>\n<tr>\n<th>关键字</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>start with</td>\n<td>指定起始节点的条件。为可选项，若该子句被省略，则表示所有满足查询条件的行作为根节点。</td>\n</tr>\n<tr>\n<td>connect by</td>\n<td>指定父子行的条件关系</td>\n</tr>\n<tr>\n<td>prior</td>\n<td>查询父行的限定符，格式: prior column1 = column2 or column1 = prior column2 and … ，prior跟父id放一边</td>\n</tr>\n<tr>\n<td>nocycle</td>\n<td>若数据表中存在循环行，那么不添加此关键字会报错，添加关键字后，便不会报错，但循环的两行只会显示其中的第一条。<strong>循环行: 该行只有一个子行，而且子行又是该行的祖先行</strong></td>\n</tr>\n<tr>\n<td>connect_by_iscycle</td>\n<td>前置条件:在使用了nocycle之后才能使用此关键字，用于表示是否是循环行，0表示否，1 表示是</td>\n</tr>\n</tbody>\n</table>\n<p>|connect_by_isleaf| 伪列,是否叶子节点，0否，1是|</p>\n<p>|level| 伪列,表示层级，值越小层级越高，最高节点为1|</p>\n<h2 id=\"h2-u73AFu5883u51C6u5907\"><a name=\"环境准备\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>环境准备</h2><pre><code class=\"lang-shell\">create table dept_test(\n    dept_id number(18),\n    p_id number(18),\n    dept_name varchar2(200)\n);\n\n-- 添加数据\ninsert into dept_test values(&#39;1&#39;,0,&#39;一级部门&#39;);\ninsert into dept_test values(&#39;2&#39;,1,&#39;二级部门1&#39;);\ninsert into dept_test values(&#39;3&#39;,1,&#39;二级部门2&#39;);\ninsert into dept_test values(&#39;4&#39;,2,&#39;三级部门1-1&#39;);\ninsert into dept_test values(&#39;5&#39;,2,&#39;三级部门1-2&#39;);\ninsert into dept_test values(&#39;6&#39;,3,&#39;三级部门2-1&#39;);\ninsert into dept_test values(&#39;7&#39;,3,&#39;三级部门2-2&#39;);\n</code></pre>\n<p><img src=\"/images/null/1606705355149部门组织架构.jpg\" alt=\"\"></p>\n<p>查询一级部门下所有子节点（自顶向下）</p>\n<pre><code>select *,level,connect_by_isleaf from dept_test \nstart with dept_id = 1 （或者 p_id = 0）\nconnect by prior dept_id = p_id\n</code></pre><p>查询三级部门2-2所有父节点（自底向上）</p>\n<pre><code>select *,level,connect_by_isleaf from dept_test \nstart with dept_id = 7 \nconnect by prior p_id = dept_id\n</code></pre>', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/17.jpg', '/article/196', 50, '2020-11-30', NULL, 0, 193, 197, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (171, 'Redis学习笔记：（一）NoSQL', '大数据量高性能NoSQL数据库都具有非常高的读写性能,特别是多表关联查询的需求任何大数据量的web系统,不需要像关系型数据库一样需要预先定义表结构查询性能不高', '## NoSQL概念\nNoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库，主要是为了解决关系型数据库的短板。\n\n## 为什么使用NoSQL\n我们先来看看随着软件行业的发展，关系型数据库面临了哪些挑战：\n大数据时代的数据特点：**海量Volume**、**多样Variety**、**实时Velocity**；和对互联网架构的要求：**高并发**、**高可括**、**高性能**。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。，**NoSql数据库的出现即是为了解决这些问题了，尤其是大数据应用难题，包括超大规模数据的存储。但是NoSql并不是用来替代关系型数据库的，因为它本身也有着不可克服的缺陷**\n\n今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。\n\n\n### 单机MySQL的美好年代\n在90年代，一个网站的浏览量一般都不大，用单个数据库完全可以轻松应付。 在那个时候，更多的都是静态网页，动态交互类型的网站不多。\n![](https://img-blog.csdnimg.cn/20201011163020382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\nDAL : Data Access Layer（数据访问层 – Hibernate，MyBatis）\n上述架构下，我们来看看数据存储的瓶颈是什么?\n\n+ 数据量的总大小一个机器放不下时\n+ 数据的索引(B+ Tree)一个机器的内存放不下时\n+ 浏览量(读写混合)一个实例不能承受\n\n如果满足了上述1or3个，进化...\n\n### Memcached(缓存)+MySQL+垂直拆分\n后来，随着网站浏览量的增多，几乎大部分使用MySQL架构的网站在数据库方面都开始出现了性能问题，web程序不再仅仅专注在功能业务，同时也在追求性能。程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当浏览量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。\n![](https://img-blog.csdnimg.cn/20201011163036663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n\n### Mysql主从读写分离\n由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模 式成为这个时候的网站标配了。\n\n![](https://img-blog.csdnimg.cn/20201011162529423.png#pic_center)\n### 分表分库+水平拆分+mysql集群\n在Memcached的高速缓存，MySQL的主从复制， 读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。\n\n同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。\n\n![](https://img-blog.csdnimg.cn/20201011163133425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n### MySQL的扩展性瓶颈\nMySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小， 如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差(需要复杂的技术来实现)，大数据下IO压力大，表结构更改困难，正是当前使用MySOL的开发人员面临的问题。\n\n### 今天是什么样子? ?\n![](https://img-blog.csdnimg.cn/20201011163152713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n\n## NoSQL特点\n+ 易扩展\nNoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。\n+ 大数据量高性能\nNoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。\n这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了\n+ 多样灵活的数据模型\nNoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦\n\n## NoSQL数据库和传统数据库对比\nNoSQL\n- 代表着不仅仅是SQL\n- 没有声明性查询语言\n- 没有预定义的模式 -键 - 值对存储，列存储，文档存储，图形数据库\n- 最终一致性，而非ACID属性\n- 非结构化和不可预知的数据\n- CAP定理\n- 高性能，高可用性和可伸缩性\n\nRDBMS\n- 高度组织化结构化数据\n- 结构化查询语言（SQL）\n- 数据和关系都存储在单独的表中。\n- 数据操纵语言，数据定义语言\n- 严格的一致性\n- 基础事务\n \n\n\n\n## 常见的NoSQl数据库\n+ Redis\n+ Memcache\n+ Mongdb\n\n## 当下的NoSQL经典应用\n==当下的应用是sql和nosql一起使用++\n\nAlibaba中文站商品信息如何存放，看看阿里巴巴中文网站首页以女装/女包包为例\n![](https://img-blog.csdnimg.cn/20201011164947849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n### 阿里架构发展历程\n演变过程\n![](https://img-blog.csdnimg.cn/20201011165045490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n第五代架构\n![](https://img-blog.csdnimg.cn/20201011165111314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n第五代架构使命\n![](https://img-blog.csdnimg.cn/20201011165131302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n和我们相关的，多数据源多数据类型的存储问题\n![](https://img-blog.csdnimg.cn/20201011165218335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n商品基本信息（名称、价格，出厂日期，生产厂商等）\n关系型数据库：mysql/oracle等，主要是mysql，目前淘宝在去O化(也即拿掉Oracle)，\n商品描述、详情、评价信息(多文字类)\n+ 多文字信息描述类，IO读写性能变差\n+ 文档数据库MongDB\n商品的图片\n+ 商品图片展现类\n分布式的文件系统中\n+ 淘宝自家TFS\n+ Google的GFS\n+ Hadoop的HDFS\n商品的关键字\n+ 淘宝自家\n+ ISearch\n商品的波段性的热点高频信息（如，情人节的巧克力）\n+ 内存数据库\n+ Tair、Redis、Memcache\n商品的交易、价格计算、积分累计\n+ 外部系统，外部第3方支付接口\n+ 支付宝\n\n### 大型互联网应用(大数据、高并发、多样数据类型)的难点和解决方案\n难点\n数据类型多样性\n数据源多样性和变化重构\n数据源改造而数据服务平台不需要大面积重构\n解决方法\nEAI\nUDSL 统一数据平台服务层\n![](https://img-blog.csdnimg.cn/20201011195557569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n![](https://img-blog.csdnimg.cn/20201011195620102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n![](https://img-blog.csdnimg.cn/20201011195631518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n![](https://img-blog.csdnimg.cn/20201011195640535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n![](https://img-blog.csdnimg.cn/20201011195648581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n## NoSQL数据模型简介\n以一个电商客户、订单、订购、地址模型来对比关系型数据库和非关系型数据库\n\n传统关系型数据库设计，ER图（1：1、1：N、N：1）主外键等\n![](https://img-blog.csdnimg.cn/2020101119575831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\nNOSQL使用聚合模型处理\n+ KV（key-value）键值对\n+ BSON ：是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，比如：\n	```json\n	{\n	 \"customer\":{\n	   \"id\":1136,\n	   \"name\":\"Z3\",\n	   \"billingAddress\":[{\"city\":\"beijing\"}],\n	   \"orders\":[\n	    {\n	      \"id\":17,\n	      \"customerId\":1136,\n	      \"orderItems\":[{\"productId\":27,\"price\":77.5,\"productName\":\"thinking in java\"}],\n	      \"shippingAddress\":[{\"city\":\"beijing\"}]\n	      \"orderPayment\":[{\"ccinfo\":\"111-222-333\",\"txnid\":\"asdfadcd334\",\"billingAddress\":{\"city\":\"beijing\"}}],\n	      }\n	    ]\n	  }\n	}\n	```\n\n+ 列族\n顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一 列或者某几列的查询有非常大的IO优势。\n![](https://img-blog.csdnimg.cn/20201011202139285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n+ 图(Graph)\n![](https://img-blog.csdnimg.cn/20201011202154450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n\n为什么用聚合模型来处理\n+ 高并发的操作是不太建议用关联查询的，互联网公司用冗余数据来避免关联查询\n+ 分布式事务是支持不了太多的并发的\n\n## NoSQL数据库的四大分类\n+ KV\n新浪：BerkeleyDB + Redis\n美团：Redis + tair\n阿里、百度：memcache + Redis\n+ 文档型数据库（bson格式比较多）\nCouchDB\nMongoDB\nMongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。\nMongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n+ 列存储数据库\nCassandra、HBase\n分布式文件系统\n+ 图关系数据库\n它不是放图形的、放的是关系比如：朋友圈社交网络、广告推荐系统\n社交网络、推荐系统。专注于构建关系图谱\nNeo4j、InfoGrid\n+ 四者对比\n\n| 分类 | Examples举例	 | 典型应用场景| 数据模型| 优点	| 缺点|\n|--|--|--|--|--|--|\n|键值（key-value）| 	Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB	|内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。|	Key 指向 Value 的键值对，通常用hash table来实现 |	查找速度快	|数据无结构化通常只被当作字符串或者二进制数据|\n|列存储数据库|Cassandra, HBase, Riak	|分布式的文件系统|	以列簇式存储，将同一列数据存在一起	|查找速度快，可扩展性强，更容易进行分布式扩展	|功能相对局限|\n|文档型数据库| 	CouchDB, MongoDb	| Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）|	Key-Value对应的键值对，Value为结构化数据	|数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构|	查询性能不高，而且缺乏统一的查询语法。|\n|图形(Graph)数据库|	Neo4J, InfoGrid, Infinite Graph|	社交网络，推荐系统等。专注于构建关系图谱|	图结构	|利用图结构相关算法。比如最短路径寻址，N度关系查找等	|很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。|\n\n\n\n## 分布式数据库CAP原理\n### 传统数据库的ACID规则\n关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：\n+ A (Atomicity) 原子性\n原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。\n+ C (Consistency) 一致性\n一致性 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。\n+ I (Isolation) 独立性\n所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要获取的数据正在被另外一个事务修改，只要另外一个事务未提交，它所获取的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的\n+ D (Durability) 持久性\n持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。\n\n### 分布式数据库的CAP理论\nCAP其实是下面三个术语的缩写：\n+ Consistency（强一致性）：\n任何一个读操作总是能读取到之前完成的写操作结果，也就是在分布式环境中，多点的数据是一致的。\n传统的ACID数据库是很少存在一致性问题的，因为数据的单点原因，数据的存取又具有良好的事务性，不会出现读写的不一致。\n+ Availability（可用性）：\n每一个操作总是能够在确定的时间内返回，也就是系统随时都是可用的。\n+ Partition tolerance（分区容错性）：\n分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，这样就具有好的分区容错性。\n\n### CAP的3进2原则\nCAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。分布式架构的时候必须做出取舍。\n\n因此，根据CAP原理将分布式数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：\n+ CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。比如传统Oracle数据库。\n+ CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。比如Redis、Mongodb等NoSQL数据库。\n+ AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。这是大多数网站架构的选择。\n![经典CAP图](https://img-blog.csdnimg.cn/20201011200038149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center)\n\n一致性与可用性的决择\n一致性和可用性之间取一个平衡。大多数网站架构的选择。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向。\n对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地\n+ 数据库事务一致性需求，很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。\n\n+ 数据库的写实时性和读实时性需求\n对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说在微博发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。\n\n+ 对复杂的SQL查询，特别是多表关联查询的需求\n\n任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。\n\n### BASE\nBASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。\nBASE其实是下面三个术语的缩写：\n+ 基本可用（Basically Available）\n+ 软状态（Soft state）\n+ 最终一致（Eventually consistent）\n它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法\n\n\n### 分布式+集群简介\n分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：PC、工作站、局域网和广域网上等。简单来讲：\n+ 分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。\n+ 集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和连接。', '<h2 id=\"h2-nosql-\"><a name=\"NoSQL概念\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NoSQL概念</h2><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库，主要是为了解决关系型数据库的短板。</p>\n<h2 id=\"h2--nosql\"><a name=\"为什么使用NoSQL\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>为什么使用NoSQL</h2><p>我们先来看看随着软件行业的发展，关系型数据库面临了哪些挑战：<br>大数据时代的数据特点：<strong>海量Volume</strong>、<strong>多样Variety</strong>、<strong>实时Velocity</strong>；和对互联网架构的要求：<strong>高并发</strong>、<strong>高可括</strong>、<strong>高性能</strong>。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。，<strong>NoSql数据库的出现即是为了解决这些问题了，尤其是大数据应用难题，包括超大规模数据的存储。但是NoSql并不是用来替代关系型数据库的，因为它本身也有着不可克服的缺陷</strong></p>\n<p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p>\n<h3 id=\"h3--mysql-\"><a name=\"单机MySQL的美好年代\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>单机MySQL的美好年代</h3><p>在90年代，一个网站的浏览量一般都不大，用单个数据库完全可以轻松应付。 在那个时候，更多的都是静态网页，动态交互类型的网站不多。<br><img src=\"https://img-blog.csdnimg.cn/20201011163020382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<p>DAL : Data Access Layer（数据访问层 – Hibernate，MyBatis）<br>上述架构下，我们来看看数据存储的瓶颈是什么?</p>\n<ul>\n<li>数据量的总大小一个机器放不下时</li><li>数据的索引(B+ Tree)一个机器的内存放不下时</li><li>浏览量(读写混合)一个实例不能承受</li></ul>\n<p>如果满足了上述1or3个，进化…</p>\n<h3 id=\"h3-memcached-mysql-\"><a name=\"Memcached(缓存)+MySQL+垂直拆分\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Memcached(缓存)+MySQL+垂直拆分</h3><p>后来，随着网站浏览量的增多，几乎大部分使用MySQL架构的网站在数据库方面都开始出现了性能问题，web程序不再仅仅专注在功能业务，同时也在追求性能。程序员们开始大量的使用缓存技术来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过文件缓存来缓解数据库压力，但是当浏览量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。<br><img src=\"https://img-blog.csdnimg.cn/20201011163036663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h3 id=\"h3-mysql-\"><a name=\"Mysql主从读写分离\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>Mysql主从读写分离</h3><p>由于数据库的写入压力增加，Memcached 只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性。Mysql的master-slave模 式成为这个时候的网站标配了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011162529423.png#pic_center\" alt=\"\"></p>\n<h3 id=\"h3--mysql-\"><a name=\"分表分库+水平拆分+mysql集群\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分表分库+水平拆分+mysql集群</h3><p>在Memcached的高速缓存，MySQL的主从复制， 读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于MyISAM使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用InnoDB引擎代替MyISAM。</p>\n<p>同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20201011163133425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h3 id=\"h3-mysql-\"><a name=\"MySQL的扩展性瓶颈\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>MySQL的扩展性瓶颈</h3><p>MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小， 如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差(需要复杂的技术来实现)，大数据下IO压力大，表结构更改困难，正是当前使用MySOL的开发人员面临的问题。</p>\n<h3 id=\"h3--\"><a name=\"今天是什么样子? ?\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>今天是什么样子? ?</h3><p><img src=\"https://img-blog.csdnimg.cn/20201011163152713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h2 id=\"h2-nosql-\"><a name=\"NoSQL特点\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NoSQL特点</h2><ul>\n<li>易扩展<br>NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</li><li>大数据量高性能<br>NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。<br>这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</li><li>多样灵活的数据模型<br>NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</li></ul>\n<h2 id=\"h2-nosql-\"><a name=\"NoSQL数据库和传统数据库对比\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NoSQL数据库和传统数据库对比</h2><p>NoSQL</p>\n<ul>\n<li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式 -键 - 值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul>\n<p>RDBMS</p>\n<ul>\n<li>高度组织化结构化数据</li><li>结构化查询语言（SQL）</li><li>数据和关系都存储在单独的表中。</li><li>数据操纵语言，数据定义语言</li><li>严格的一致性</li><li>基础事务</li></ul>\n<h2 id=\"h2--nosql-\"><a name=\"常见的NoSQl数据库\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>常见的NoSQl数据库</h2><ul>\n<li>Redis</li><li>Memcache</li><li>Mongdb</li></ul>\n<h2 id=\"h2--nosql-\"><a name=\"当下的NoSQL经典应用\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>当下的NoSQL经典应用</h2><p>==当下的应用是sql和nosql一起使用++</p>\n<p>Alibaba中文站商品信息如何存放，看看阿里巴巴中文网站首页以女装/女包包为例<br><img src=\"https://img-blog.csdnimg.cn/20201011164947849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h3 id=\"h3-u963Fu91CCu67B6u6784u53D1u5C55u5386u7A0B\"><a name=\"阿里架构发展历程\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>阿里架构发展历程</h3><p>演变过程<br><img src=\"https://img-blog.csdnimg.cn/20201011165045490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br>第五代架构<br><img src=\"https://img-blog.csdnimg.cn/20201011165111314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br>第五代架构使命<br><img src=\"https://img-blog.csdnimg.cn/20201011165131302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br>和我们相关的，多数据源多数据类型的存储问题<br><img src=\"https://img-blog.csdnimg.cn/20201011165218335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br>商品基本信息（名称、价格，出厂日期，生产厂商等）<br>关系型数据库：mysql/oracle等，主要是mysql，目前淘宝在去O化(也即拿掉Oracle)，<br>商品描述、详情、评价信息(多文字类)</p>\n<ul>\n<li>多文字信息描述类，IO读写性能变差</li><li>文档数据库MongDB<br>商品的图片</li><li>商品图片展现类<br>分布式的文件系统中</li><li>淘宝自家TFS</li><li>Google的GFS</li><li>Hadoop的HDFS<br>商品的关键字</li><li>淘宝自家</li><li>ISearch<br>商品的波段性的热点高频信息（如，情人节的巧克力）</li><li>内存数据库</li><li>Tair、Redis、Memcache<br>商品的交易、价格计算、积分累计</li><li>外部系统，外部第3方支付接口</li><li>支付宝</li></ul>\n<h3 id=\"h3--\"><a name=\"大型互联网应用(大数据、高并发、多样数据类型)的难点和解决方案\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>大型互联网应用(大数据、高并发、多样数据类型)的难点和解决方案</h3><p>难点<br>数据类型多样性<br>数据源多样性和变化重构<br>数据源改造而数据服务平台不需要大面积重构<br>解决方法<br>EAI<br>UDSL 统一数据平台服务层<br><img src=\"https://img-blog.csdnimg.cn/20201011195557569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20201011195620102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20201011195631518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20201011195640535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"><br><img src=\"https://img-blog.csdnimg.cn/20201011195648581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<h2 id=\"h2-nosql-\"><a name=\"NoSQL数据模型简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NoSQL数据模型简介</h2><p>以一个电商客户、订单、订购、地址模型来对比关系型数据库和非关系型数据库</p>\n<p>传统关系型数据库设计，ER图（1：1、1：N、N：1）主外键等<br><img src=\"https://img-blog.csdnimg.cn/2020101119575831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n<p>NOSQL使用聚合模型处理</p>\n<ul>\n<li>KV（key-value）键值对</li><li><p>BSON ：是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，比如：</p>\n<pre><code class=\"lang-json\">  {\n   &quot;customer&quot;:{\n     &quot;id&quot;:1136,\n     &quot;name&quot;:&quot;Z3&quot;,\n     &quot;billingAddress&quot;:[{&quot;city&quot;:&quot;beijing&quot;}],\n     &quot;orders&quot;:[\n      {\n        &quot;id&quot;:17,\n        &quot;customerId&quot;:1136,\n        &quot;orderItems&quot;:[{&quot;productId&quot;:27,&quot;price&quot;:77.5,&quot;productName&quot;:&quot;thinking in java&quot;}],\n        &quot;shippingAddress&quot;:[{&quot;city&quot;:&quot;beijing&quot;}]\n        &quot;orderPayment&quot;:[{&quot;ccinfo&quot;:&quot;111-222-333&quot;,&quot;txnid&quot;:&quot;asdfadcd334&quot;,&quot;billingAddress&quot;:{&quot;city&quot;:&quot;beijing&quot;}}],\n        }\n      ]\n    }\n  }\n</code></pre>\n</li><li><p>列族<br>顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一 列或者某几列的查询有非常大的IO优势。<br><img src=\"https://img-blog.csdnimg.cn/20201011202139285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></p>\n</li><li>图(Graph)<br><img src=\"https://img-blog.csdnimg.cn/20201011202154450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"\"></li></ul>\n<p>为什么用聚合模型来处理</p>\n<ul>\n<li>高并发的操作是不太建议用关联查询的，互联网公司用冗余数据来避免关联查询</li><li>分布式事务是支持不了太多的并发的</li></ul>\n<h2 id=\"h2-nosql-\"><a name=\"NoSQL数据库的四大分类\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>NoSQL数据库的四大分类</h2><ul>\n<li>KV<br>新浪：BerkeleyDB + Redis<br>美团：Redis + tair<br>阿里、百度：memcache + Redis</li><li>文档型数据库（bson格式比较多）<br>CouchDB<br>MongoDB<br>MongoDB是一个基于分布式文件存储的数据库。由C++语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。<br>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li><li>列存储数据库<br>Cassandra、HBase<br>分布式文件系统</li><li>图关系数据库<br>它不是放图形的、放的是关系比如：朋友圈社交网络、广告推荐系统<br>社交网络、推荐系统。专注于构建关系图谱<br>Neo4j、InfoGrid</li><li>四者对比</li></ul>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>Examples举例</th>\n<th>典型应用场景</th>\n<th>数据模型</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>键值（key-value）</td>\n<td>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td>\n<td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td>\n<td>Key 指向 Value 的键值对，通常用hash table来实现</td>\n<td>查找速度快</td>\n<td>数据无结构化通常只被当作字符串或者二进制数据</td>\n</tr>\n<tr>\n<td>列存储数据库</td>\n<td>Cassandra, HBase, Riak</td>\n<td>分布式的文件系统</td>\n<td>以列簇式存储，将同一列数据存在一起</td>\n<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>\n<td>功能相对局限</td>\n</tr>\n<tr>\n<td>文档型数据库</td>\n<td>CouchDB, MongoDb</td>\n<td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td>\n<td>Key-Value对应的键值对，Value为结构化数据</td>\n<td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>\n<td>查询性能不高，而且缺乏统一的查询语法。</td>\n</tr>\n<tr>\n<td>图形(Graph)数据库</td>\n<td>Neo4J, InfoGrid, Infinite Graph</td>\n<td>社交网络，推荐系统等。专注于构建关系图谱</td>\n<td>图结构</td>\n<td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>\n<td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"h2--cap-\"><a name=\"分布式数据库CAP原理\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分布式数据库CAP原理</h2><h3 id=\"h3--acid-\"><a name=\"传统数据库的ACID规则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>传统数据库的ACID规则</h3><p>关系型数据库遵循ACID规则，事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p>\n<ul>\n<li>A (Atomicity) 原子性<br>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li><li>C (Consistency) 一致性<br>一致性 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。</li><li>I (Isolation) 独立性<br>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要获取的数据正在被另外一个事务修改，只要另外一个事务未提交，它所获取的数据就不受未提交事务的影响。比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的</li><li>D (Durability) 持久性<br>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</li></ul>\n<h3 id=\"h3--cap-\"><a name=\"分布式数据库的CAP理论\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分布式数据库的CAP理论</h3><p>CAP其实是下面三个术语的缩写：</p>\n<ul>\n<li>Consistency（强一致性）：<br>任何一个读操作总是能读取到之前完成的写操作结果，也就是在分布式环境中，多点的数据是一致的。<br>传统的ACID数据库是很少存在一致性问题的，因为数据的单点原因，数据的存取又具有良好的事务性，不会出现读写的不一致。</li><li>Availability（可用性）：<br>每一个操作总是能够在确定的时间内返回，也就是系统随时都是可用的。</li><li>Partition tolerance（分区容错性）：<br>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，这样就具有好的分区容错性。</li></ul>\n<h3 id=\"h3-cap-3-2-\"><a name=\"CAP的3进2原则\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>CAP的3进2原则</h3><p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。分布式架构的时候必须做出取舍。</p>\n<p>因此，根据CAP原理将分布式数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：</p>\n<ul>\n<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。比如传统Oracle数据库。</li><li>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。比如Redis、Mongodb等NoSQL数据库。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。这是大多数网站架构的选择。<br><img src=\"https://img-blog.csdnimg.cn/20201011200038149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fhd214MTIz,size_16,color_FFFFFF,t_70#pic_center\" alt=\"经典CAP图\"></li></ul>\n<p>一致性与可用性的决择<br>一致性和可用性之间取一个平衡。大多数网站架构的选择。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向。<br>对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p>\n<ul>\n<li><p>数据库事务一致性需求，很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。</p>\n</li><li><p>数据库的写实时性和读实时性需求<br>对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说在微博发一条消息之后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p>\n</li><li><p>对复杂的SQL查询，特别是多表关联查询的需求</p>\n</li></ul>\n<p>任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p>\n<h3 id=\"h3-base\"><a name=\"BASE\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>BASE</h3><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。<br>BASE其实是下面三个术语的缩写：</p>\n<ul>\n<li>基本可用（Basically Available）</li><li>软状态（Soft state）</li><li>最终一致（Eventually consistent）<br>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</li></ul>\n<h3 id=\"h3--\"><a name=\"分布式+集群简介\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>分布式+集群简介</h3><p>分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：PC、工作站、局域网和广域网上等。简单来讲：</p>\n<ul>\n<li>分布式：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。</li><li>集群：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和连接。</li></ul>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/4.jpg', '/article/171', 49, '2020-10-12', NULL, 0, 170, 178, 0, 0, 0, 1);
INSERT INTO `blog_article` VALUES (205, '递归', '递归代码还有很多别的问题,3.存在递归终止条件把问题分解为子问题,f(n)=f(n-1)+f(n-2)那f(n)问题就解决了', '推荐注册返佣金的这个功能我想你应该不陌生吧？现在很多 App 都有这个功能。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。\n\n一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。\n![](/images/202/16067251797792984d45578440e9a348144c70d124a0e.jpg)\n基于这个背景，我的问题是，给定一个用户 ID，如何查找这个用户的“最终推荐人”？ 带着这个问题，我们来学习今天的内容，递归（Recursion）！\n## 如何理解“递归”？\n从我自己学习数据结构和算法的经历来看，我个人觉得，有两个最难理解的知识点，一个是动态规划，另一个就是递归。\n\n递归是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。\n\n不过，别看我说了这么多，递归本身可是一点儿都不“高冷”，咱们生活中就有很多用到递归的例子。\n\n周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？\n\n别忘了你是程序员，这个可难不倒你，递归就开始排上用场了。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。\n\n这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：\n```java\nf(n)=f(n-1)+1 其中，f(1)=1\n```\nf(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，\n如下：\n```java\nint f(int n) { \n	if (n == 1) return 1;\n	return f(n-1) + 1\n}\n```\n\n## 递归需要满足的三个条件\n刚刚这个例子是非常典型的递归，那究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。\n1.一个问题的解可以分解为几个子问题的解。何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。\n2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。\n3.存在递归终止条件把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。\n\n## 如何编写递归代码？\n刚刚铺垫了这么多，现在我们来看，如何来写递归代码？我个人觉得，写递归代码最关键的是**写出递推公式，找到终止条件**，剩下将递推公式转化为代码就很简单了。\n\n假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？\n\n寻找递推公式\n我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：\n```java\nf(n) = f(n-1)+f(n-2)\n```\n\n终止条件\n有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)=1。这个递归终止条件足够吗？我们可以用 n=2，n=3 这样比较小的数试验一下。n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。所以，递归终止条件就是 f(1)=1，f(2)=2。这个时候，你可以再拿 n=3，n=4 来验证一下，这个终止条件是否足够并且正确。我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2)有了这个公式，我们转化成递归代码就简单多了。\n最终的递归代码是这样的：\n```java\nint f(int n) {\n	if (n == 1) return 1; \n	if (n == 2) return 2; \n	return f(n-1) + f(n-2);\n}\n```\n我总结一下，写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。\n\n虽然我讲了这么多方法，但是作为初学者的你，现在是不是还是有种想不太清楚的感觉呢？实际上，我刚学递归的时候，也有这种感觉，这也是文章开头我说递归代码比较难理解的地方。\n\n刚讲的电影院的例子，我们的递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”，我们很容易能够想清楚“递“和”归”的每一个步骤，所以写起来、理解起来都不难。\n\n但是，当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。像我刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。\n\n计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。\n\n对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？\n\n如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。\n\n因此，编写递归代码的关键是，**只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**\n\n##递归代码要警惕堆栈溢出\n在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？我们又该如何预防堆栈溢出呢？\n\n我在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。\n比如前面的讲到的电影院的例子，如果我们将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：\n> Exception in thread \"main\" java.lang.StackOverflowError\n\n那么，如何避免出现堆栈溢出呢？我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。不过，我写的代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x<=0。\n```java\n// 全局变量，表示递归的深度。\nint depth = 0;\n\nint f(int n) {\n	++depth；\n	if (depth > 1000) throw exception;\n  \n	if (n == 1) return 1;\n	return f(n-1) + 1;\n}\n```\n\n但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。\n\n递归代码要警惕重复计算除此之外，使用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的：\n![](/images/202/1606724406944e7e778994e90265344f6ac9da39e01bf.jpg)\n\n从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。\n\n为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。\n\n按照上面的思路，我们来改造一下刚才的代码：\n\n```java\n\npublic int f(int n) {\n	if (n == 1) return 1;\n	if (n == 2) return 2;\n	// hasSolvedList可以理解成一个Map，key是n，value是f(n)\n	if (hasSolvedList.containsKey(n)) {\n    	return hasSolvedList.get(n);\n	}\n  \n	int ret = f(n-1) + f(n-2);\n	hasSolvedList.put(n, ret);\n	return ret;\n}\n```\n除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。\n\n## 怎么将递归代码改写为非递归代码？\n我们刚说了，递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个电影院的例子，我们抛开场景，只看 f(x) =f(x-1)+1 这个递推公式。我们这样改写看看\n```java\nint f(int n) {\n	int ret = 1;\n	for (int i = 2; i <= n; ++i) {\n		ret = ret + 1;\n	}\n	return ret;\n}\n```\n同样，第二个例子也可以改为非递归的实现方式。\n```java\n\nint f(int n) {\n	if (n == 1) return 1;\n	if (n == 2) return 2;\n	\n	int ret = 0;\n	int pre = 2;\n	int prepre = 1;\n	for (int i = 3; i <= n; ++i) {\n		ret = pre + prepre;\n		prepre = pre;\n		pre = ret;\n	}\n	return ret;\n}\n```\n那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？\n笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。\n但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。\n\n## 解答开篇\n到此为止，递归相关的基础知识已经讲完了，咱们来看一下开篇的问题：如何找到“最终推荐人”？我的解决方案是这样的：\n```java\n\nlong findRootReferrerId(long actorId) {\n  Long referrerId = select referrer_id from [table] where actor_id = actorId;\n  if (referrerId == null) return actorId;\n  return findRootReferrerId(referrerId);\n}\n\n```\n是不是非常简洁？用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。\n第一，如果递归很深，可能会有堆栈溢出的问题。\n\n第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。\n\n第一个问题，我前面已经解答过了，可以用限制递归深度来解决。\n\n第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。如何来检测环的存在呢？这个我暂时不细说，你可以自己思考下，后面的章节我们还会讲。\n\n## 内容小结\n关于递归的知识，到这里就算全部讲完了。我来总结一下。\n\n递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。\n\n不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。\n\n递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。\n\n##个人总结\n### 递归的条件\n就是当数据量减小时，求解思路与原来一样，并不会因为数据量减小改变求解思路，并且当数据足够小时，有明确的结果。比面示例中的台阶问题，其中n个台阶，n=100和n=99或者98的求解思路是一样的，并且n=1的时候，就有明确的结果\n### 递归的思考方式\n当我们看到递归时，不要试图想清楚整个递和归过程的做法，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。\n比如还是示例中的台阶问题，我们不需要一层层去考虑f(n-1),f(n-2)返回什么，就假设已经知道了f(n-1)和f(n-2)的值，f(n) = f(n-1) + f(n-2) 那f(n)问题就解决了\n', '<p>推荐注册返佣金的这个功能我想你应该不陌生吧？现在很多 App 都有这个功能。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p>\n<p>一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。<br><img src=\"/images/202/16067251797792984d45578440e9a348144c70d124a0e.jpg\" alt=\"\"><br>基于这个背景，我的问题是，给定一个用户 ID，如何查找这个用户的“最终推荐人”？ 带着这个问题，我们来学习今天的内容，递归（Recursion）！</p>\n<h2 id=\"h2--\"><a name=\"如何理解“递归”？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何理解“递归”？</h2><p>从我自己学习数据结构和算法的经历来看，我个人觉得，有两个最难理解的知识点，一个是动态规划，另一个就是递归。</p>\n<p>递归是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。</p>\n<p>不过，别看我说了这么多，递归本身可是一点儿都不“高冷”，咱们生活中就有很多用到递归的例子。</p>\n<p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？</p>\n<p>别忘了你是程序员，这个可难不倒你，递归就开始排上用场了。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。</p>\n<p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：</p>\n<pre><code class=\"lang-java\">f(n)=f(n-1)+1 其中，f(1)=1\n</code></pre>\n<p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，<br>如下：</p>\n<pre><code class=\"lang-java\">int f(int n) { \n    if (n == 1) return 1;\n    return f(n-1) + 1\n}\n</code></pre>\n<h2 id=\"h2-u9012u5F52u9700u8981u6EE1u8DB3u7684u4E09u4E2Au6761u4EF6\"><a name=\"递归需要满足的三个条件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>递归需要满足的三个条件</h2><p>刚刚这个例子是非常典型的递归，那究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。<br>1.一个问题的解可以分解为几个子问题的解。何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。<br>2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。<br>3.存在递归终止条件把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。</p>\n<h2 id=\"h2--\"><a name=\"如何编写递归代码？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>如何编写递归代码？</h2><p>刚刚铺垫了这么多，现在我们来看，如何来写递归代码？我个人觉得，写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就很简单了。</p>\n<p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p>\n<p>寻找递推公式<br>我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：</p>\n<pre><code class=\"lang-java\">f(n) = f(n-1)+f(n-2)\n</code></pre>\n<p>终止条件<br>有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)=1。这个递归终止条件足够吗？我们可以用 n=2，n=3 这样比较小的数试验一下。n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。所以，递归终止条件就是 f(1)=1，f(2)=2。这个时候，你可以再拿 n=3，n=4 来验证一下，这个终止条件是否足够并且正确。我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2)有了这个公式，我们转化成递归代码就简单多了。<br>最终的递归代码是这样的：</p>\n<pre><code class=\"lang-java\">int f(int n) {\n    if (n == 1) return 1; \n    if (n == 2) return 2; \n    return f(n-1) + f(n-2);\n}\n</code></pre>\n<p>我总结一下，写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p>\n<p>虽然我讲了这么多方法，但是作为初学者的你，现在是不是还是有种想不太清楚的感觉呢？实际上，我刚学递归的时候，也有这种感觉，这也是文章开头我说递归代码比较难理解的地方。</p>\n<p>刚讲的电影院的例子，我们的递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”，我们很容易能够想清楚“递“和”归”的每一个步骤，所以写起来、理解起来都不难。</p>\n<p>但是，当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。像我刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。</p>\n<p>计算机擅长做重复的事情，所以递归正合它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p>\n<p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p>\n<p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p>\n<p>因此，编写递归代码的关键是，<strong>只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p>\n<h2 id=\"h2-u9012u5F52u4EE3u7801u8981u8B66u60D5u5806u6808u6EA2u51FA\"><a name=\"递归代码要警惕堆栈溢出\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>递归代码要警惕堆栈溢出</h2><p>在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？我们又该如何预防堆栈溢出呢？</p>\n<p>我在“栈”那一节讲过，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。<br>比如前面的讲到的电影院的例子，如果我们将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：</p>\n<blockquote>\n<p>Exception in thread “main” java.lang.StackOverflowError</p>\n</blockquote>\n<p>那么，如何避免出现堆栈溢出呢？我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。不过，我写的代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。</p>\n<pre><code class=\"lang-java\">// 全局变量，表示递归的深度。\nint depth = 0;\n\nint f(int n) {\n    ++depth；\n    if (depth &gt; 1000) throw exception;\n\n    if (n == 1) return 1;\n    return f(n-1) + 1;\n}\n</code></pre>\n<p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p>\n<p>递归代码要警惕重复计算除此之外，使用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的：<br><img src=\"/images/202/1606724406944e7e778994e90265344f6ac9da39e01bf.jpg\" alt=\"\"></p>\n<p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p>\n<p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p>\n<p>按照上面的思路，我们来改造一下刚才的代码：</p>\n<pre><code class=\"lang-java\">\npublic int f(int n) {\n    if (n == 1) return 1;\n    if (n == 2) return 2;\n    // hasSolvedList可以理解成一个Map，key是n，value是f(n)\n    if (hasSolvedList.containsKey(n)) {\n        return hasSolvedList.get(n);\n    }\n\n    int ret = f(n-1) + f(n-2);\n    hasSolvedList.put(n, ret);\n    return ret;\n}\n</code></pre>\n<p>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p>\n<h2 id=\"h2--\"><a name=\"怎么将递归代码改写为非递归代码？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>怎么将递归代码改写为非递归代码？</h2><p>我们刚说了，递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个电影院的例子，我们抛开场景，只看 f(x) =f(x-1)+1 这个递推公式。我们这样改写看看</p>\n<pre><code class=\"lang-java\">int f(int n) {\n    int ret = 1;\n    for (int i = 2; i &lt;= n; ++i) {\n        ret = ret + 1;\n    }\n    return ret;\n}\n</code></pre>\n<p>同样，第二个例子也可以改为非递归的实现方式。</p>\n<pre><code class=\"lang-java\">\nint f(int n) {\n    if (n == 1) return 1;\n    if (n == 2) return 2;\n\n    int ret = 0;\n    int pre = 2;\n    int prepre = 1;\n    for (int i = 3; i &lt;= n; ++i) {\n        ret = pre + prepre;\n        prepre = pre;\n        pre = ret;\n    }\n    return ret;\n}\n</code></pre>\n<p>那是不是所有的递归代码都可以改为这种迭代循环的非递归写法呢？<br>笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。<br>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>\n<h2 id=\"h2-u89E3u7B54u5F00u7BC7\"><a name=\"解答开篇\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>解答开篇</h2><p>到此为止，递归相关的基础知识已经讲完了，咱们来看一下开篇的问题：如何找到“最终推荐人”？我的解决方案是这样的：</p>\n<pre><code class=\"lang-java\">\nlong findRootReferrerId(long actorId) {\n  Long referrerId = select referrer_id from [table] where actor_id = actorId;\n  if (referrerId == null) return actorId;\n  return findRootReferrerId(referrerId);\n}\n</code></pre>\n<p>是不是非常简洁？用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。<br>第一，如果递归很深，可能会有堆栈溢出的问题。</p>\n<p>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环。</p>\n<p>第一个问题，我前面已经解答过了，可以用限制递归深度来解决。</p>\n<p>第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。如何来检测环的存在呢？这个我暂时不细说，你可以自己思考下，后面的章节我们还会讲。</p>\n<h2 id=\"h2-u5185u5BB9u5C0Fu7ED3\"><a name=\"内容小结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>内容小结</h2><p>关于递归的知识，到这里就算全部讲完了。我来总结一下。</p>\n<p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。</p>\n<p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是写出递推公式，找出终止条件，然后再翻译成递归代码。</p>\n<p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p>\n<h2 id=\"h2-u4E2Au4EBAu603Bu7ED3\"><a name=\"个人总结\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>个人总结</h2><h3 id=\"h3-u9012u5F52u7684u6761u4EF6\"><a name=\"递归的条件\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>递归的条件</h3><p>就是当数据量减小时，求解思路与原来一样，并不会因为数据量减小改变求解思路，并且当数据足够小时，有明确的结果。比面示例中的台阶问题，其中n个台阶，n=100和n=99或者98的求解思路是一样的，并且n=1的时候，就有明确的结果</p>\n<h3 id=\"h3-u9012u5F52u7684u601Du8003u65B9u5F0F\"><a name=\"递归的思考方式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>递归的思考方式</h3><p>当我们看到递归时，不要试图想清楚整个递和归过程的做法，如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。<br>比如还是示例中的台阶问题，我们不需要一层层去考虑f(n-1),f(n-2)返回什么，就假设已经知道了f(n-1)和f(n-2)的值，f(n) = f(n-1) + f(n-2) 那f(n)问题就解决了</p>\n', 'https://cdn.jsdelivr.net/gh/wangmx996/wangmx996.github.io/medias/featureimages/7.jpg', '/article/205', 51, '2020-11-30', NULL, 0, 204, NULL, 0, 0, 0, 1);

-- ----------------------------
-- Table structure for blog_article_tags
-- ----------------------------
DROP TABLE IF EXISTS `blog_article_tags`;
CREATE TABLE `blog_article_tags`  (
  `article_id` int(0) NOT NULL,
  `tags_id` int(0) NOT NULL,
  INDEX `FK9r85o7v8n5p0xd15uy4ia97k2`(`article_id`) USING BTREE,
  INDEX `UK_or3bbv5t5xhbum5t8s9gb8luy`(`tags_id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Fixed;

-- ----------------------------
-- Records of blog_article_tags
-- ----------------------------
INSERT INTO `blog_article_tags` VALUES (121, 118);
INSERT INTO `blog_article_tags` VALUES (117, 114);
INSERT INTO `blog_article_tags` VALUES (121, 119);
INSERT INTO `blog_article_tags` VALUES (117, 115);
INSERT INTO `blog_article_tags` VALUES (130, 127);
INSERT INTO `blog_article_tags` VALUES (130, 128);
INSERT INTO `blog_article_tags` VALUES (152, 111);
INSERT INTO `blog_article_tags` VALUES (116, 115);
INSERT INTO `blog_article_tags` VALUES (116, 114);
INSERT INTO `blog_article_tags` VALUES (154, 129);
INSERT INTO `blog_article_tags` VALUES (124, 122);
INSERT INTO `blog_article_tags` VALUES (154, 128);
INSERT INTO `blog_article_tags` VALUES (154, 127);
INSERT INTO `blog_article_tags` VALUES (109, 16);
INSERT INTO `blog_article_tags` VALUES (130, 129);
INSERT INTO `blog_article_tags` VALUES (126, 114);
INSERT INTO `blog_article_tags` VALUES (108, 16);
INSERT INTO `blog_article_tags` VALUES (107, 16);
INSERT INTO `blog_article_tags` VALUES (106, 16);
INSERT INTO `blog_article_tags` VALUES (105, 16);
INSERT INTO `blog_article_tags` VALUES (178, 174);
INSERT INTO `blog_article_tags` VALUES (161, 160);
INSERT INTO `blog_article_tags` VALUES (152, 110);
INSERT INTO `blog_article_tags` VALUES (152, 112);
INSERT INTO `blog_article_tags` VALUES (121, 120);
INSERT INTO `blog_article_tags` VALUES (126, 125);
INSERT INTO `blog_article_tags` VALUES (104, 16);
INSERT INTO `blog_article_tags` VALUES (103, 16);
INSERT INTO `blog_article_tags` VALUES (102, 16);
INSERT INTO `blog_article_tags` VALUES (101, 17);
INSERT INTO `blog_article_tags` VALUES (183, 182);
INSERT INTO `blog_article_tags` VALUES (171, 174);
INSERT INTO `blog_article_tags` VALUES (178, 175);
INSERT INTO `blog_article_tags` VALUES (101, 16);
INSERT INTO `blog_article_tags` VALUES (124, 114);
INSERT INTO `blog_article_tags` VALUES (178, 16);
INSERT INTO `blog_article_tags` VALUES (183, 174);
INSERT INTO `blog_article_tags` VALUES (171, 167);
INSERT INTO `blog_article_tags` VALUES (171, 163);
INSERT INTO `blog_article_tags` VALUES (191, 127);
INSERT INTO `blog_article_tags` VALUES (193, 127);
INSERT INTO `blog_article_tags` VALUES (196, 195);
INSERT INTO `blog_article_tags` VALUES (205, 203);

-- ----------------------------
-- Table structure for blog_categories
-- ----------------------------
DROP TABLE IF EXISTS `blog_categories`;
CREATE TABLE `blog_categories`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 52 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_categories
-- ----------------------------
INSERT INTO `blog_categories` VALUES (51, '数据结构与算法', NULL);
INSERT INTO `blog_categories` VALUES (50, '数据库', NULL);
INSERT INTO `blog_categories` VALUES (49, 'Redis', NULL);
INSERT INTO `blog_categories` VALUES (48, 'MySQL', NULL);
INSERT INTO `blog_categories` VALUES (47, '工具', NULL);
INSERT INTO `blog_categories` VALUES (46, 'Spring', NULL);
INSERT INTO `blog_categories` VALUES (45, 'SpringBoot', NULL);
INSERT INTO `blog_categories` VALUES (44, 'Nginx', NULL);
INSERT INTO `blog_categories` VALUES (43, 'Docker', NULL);

-- ----------------------------
-- Table structure for blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `blog_comment`;
CREATE TABLE `blog_comment`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `comment_content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `create_date` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `likes` int(0) NOT NULL,
  `comment_user_id` int(0) DEFAULT NULL,
  `parent_id` int(0) DEFAULT NULL,
  `repay_user_id` int(0) DEFAULT NULL,
  `article_id` int(0) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKjrfd6po1t5s5ydv51idbdjh64`(`comment_user_id`) USING BTREE,
  INDEX `FK3tlf8ln9y3n59pdaqrq88lf0h`(`parent_id`) USING BTREE,
  INDEX `FK5dd23e6ln4gx556j56gxy6r2p`(`repay_user_id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1058 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for blog_mood
-- ----------------------------
DROP TABLE IF EXISTS `blog_mood`;
CREATE TABLE `blog_mood`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `mood_content` varchar(1000) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `create_date` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Table structure for blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `blog_tags`;
CREATE TABLE `blog_tags`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 325 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog_tags
-- ----------------------------
INSERT INTO `blog_tags` VALUES (122, '热部署');
INSERT INTO `blog_tags` VALUES (120, '验证码');
INSERT INTO `blog_tags` VALUES (115, 'Spring');
INSERT INTO `blog_tags` VALUES (118, '工具');
INSERT INTO `blog_tags` VALUES (119, 'kaptcha');
INSERT INTO `blog_tags` VALUES (114, 'SpringBoot');
INSERT INTO `blog_tags` VALUES (125, '配置文件');
INSERT INTO `blog_tags` VALUES (112, '反向代理');
INSERT INTO `blog_tags` VALUES (111, '负载均衡');
INSERT INTO `blog_tags` VALUES (110, 'Nginx');
INSERT INTO `blog_tags` VALUES (17, '虚拟化 ');
INSERT INTO `blog_tags` VALUES (16, 'Docker');
INSERT INTO `blog_tags` VALUES (127, 'MySQL');
INSERT INTO `blog_tags` VALUES (128, '索引');
INSERT INTO `blog_tags` VALUES (129, '优化');
INSERT INTO `blog_tags` VALUES (160, 'IDEA');
INSERT INTO `blog_tags` VALUES (163, 'NoSQL');
INSERT INTO `blog_tags` VALUES (167, 'CAP');
INSERT INTO `blog_tags` VALUES (174, 'Redis');
INSERT INTO `blog_tags` VALUES (175, '安装');
INSERT INTO `blog_tags` VALUES (182, 'Redis命令');
INSERT INTO `blog_tags` VALUES (195, 'Oracle');
INSERT INTO `blog_tags` VALUES (203, '递归');

-- ----------------------------
-- Table structure for box_category
-- ----------------------------
DROP TABLE IF EXISTS `box_category`;
CREATE TABLE `box_category`  (
  `id` int unsigned NOT NULL,
  `parent_id` int(0) NOT NULL DEFAULT 0,
  `sort` int(0) NOT NULL DEFAULT 0,
  `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `icon` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `levels` int(0) DEFAULT NULL,
  `create_time` timestamp(0) DEFAULT NULL,
  `update_time` timestamp(0) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '站分类' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of box_category
-- ----------------------------
INSERT INTO `box_category` VALUES (1, 0, 1, '常用推荐', 'fa-star-o', 1, '2019-01-21 12:48:58', '2019-12-18 12:01:59');
INSERT INTO `box_category` VALUES (2, 0, 2, '社区资讯', 'fa-bullhorn', 1, '2019-01-21 12:50:17', '2019-12-18 12:02:05');
INSERT INTO `box_category` VALUES (3, 0, 5, '灵感采集', 'fa-lightbulb-o', 1, '2019-01-21 13:53:10', '2019-12-19 11:14:45');
INSERT INTO `box_category` VALUES (4, 3, 4, '发现产品', 'fa-star-o', 2, '2019-01-21 13:53:31', '2019-01-21 13:53:34');
INSERT INTO `box_category` VALUES (5, 3, 5, '界面灵感', 'fa-star-o', 2, '2019-01-21 13:53:49', '2019-01-21 13:55:42');
INSERT INTO `box_category` VALUES (6, 3, 6, '网页灵感', 'fa-star-o', 2, '2019-01-21 13:54:00', '2019-01-21 13:55:42');
INSERT INTO `box_category` VALUES (7, 0, 7, '素材资源', 'fa-thumbs-o-up', 1, '2019-01-21 13:54:42', '2019-01-21 13:55:42');
INSERT INTO `box_category` VALUES (8, 7, 8, '图标素材', 'fa-star-o', 2, '2019-01-21 13:54:59', '2019-01-21 14:12:01');
INSERT INTO `box_category` VALUES (9, 7, 9, 'LOGO设计', 'fa-star-o', 2, '2019-01-21 13:55:11', '2019-01-21 13:55:42');
INSERT INTO `box_category` VALUES (10, 7, 10, '平面素材', 'fa-star-o', 2, '2019-01-21 13:55:25', '2019-01-21 13:55:42');
INSERT INTO `box_category` VALUES (11, 7, 11, 'UI资源', 'fa-star-o', 2, '2019-01-21 13:55:31', '2019-01-21 13:55:42');
INSERT INTO `box_category` VALUES (12, 7, 12, 'Sketch资源', 'fa-star-o', 2, '2019-01-22 01:00:51', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (13, 7, 13, '字体资源', 'fa-star-o', 2, '2019-01-22 01:01:02', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (14, 7, 14, 'Mockup', 'fa-star-o', 2, '2019-01-22 01:01:12', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (15, 7, 15, '摄影图库', 'fa-star-o', 2, '2019-01-22 01:01:23', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (16, 7, 16, 'PPT资源', 'fa-star-o', 2, '2019-01-22 01:01:33', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (17, 0, 17, '常用工具', 'fa-cogs', 1, '2019-01-22 01:02:04', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (18, 17, 18, '图形创意', 'fa-star-o', 2, '2019-01-22 01:02:14', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (19, 17, 19, '界面设计', 'fa-star-o', 2, '2019-01-22 01:02:24', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (20, 17, 20, '交互动效', 'fa-star-o', 2, '2019-01-22 01:02:32', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (21, 17, 21, '在线配色', 'fa-star-o', 2, '2019-01-22 01:02:40', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (22, 17, 22, '在线工具', 'fa-star-o', 2, '2019-01-22 01:02:49', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (23, 17, 23, 'Chrome插件', 'fa-star-o', 2, '2019-01-22 01:02:58', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (24, 0, 24, '学习教程', 'fa-pencil', 1, '2019-01-22 01:03:17', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (25, 24, 25, '设计规范', 'fa-star-o', 2, '2019-01-22 01:03:29', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (26, 24, 26, '视频教程', 'fa-star-o', 2, '2019-01-22 01:03:36', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (27, 24, 27, '设计文章', 'fa-star-o', 2, '2019-01-22 01:03:44', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (28, 24, 28, '设计电台', 'fa-star-o', 2, '2019-01-22 01:03:52', '2019-01-22 01:07:04');
INSERT INTO `box_category` VALUES (35, 0, 0, '小玩意儿', 'fa-thumbs-up', 1, '2019-07-26 16:08:10', '2019-12-17 20:23:16');
INSERT INTO `box_category` VALUES (36, 0, 1, '常用搜索', 'fa-bar-chart-o', 1, '2019-12-19 10:14:01', NULL);
INSERT INTO `box_category` VALUES (37, 0, 3, '休闲娱乐', 'fa-automobile', 1, '2019-12-19 10:45:08', NULL);
INSERT INTO `box_category` VALUES (38, 0, 4, 'IT技术', 'fa-check', 1, '2019-12-19 11:14:21', '2019-12-19 11:15:31');
INSERT INTO `box_category` VALUES (39, 17, 2, '网站管理', 'fa-align-justify', 2, '2019-12-19 21:53:17', NULL);
INSERT INTO `box_category` VALUES (40, 17, 39, '常用邮箱登录入口', 'fa-angellist', 2, '2019-12-20 19:36:52', NULL);

-- ----------------------------
-- Table structure for box_site
-- ----------------------------
DROP TABLE IF EXISTS `box_site`;
CREATE TABLE `box_site`  (
  `id` int unsigned NOT NULL,
  `category_id` int(0) DEFAULT NULL,
  `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `thumb` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `description` varchar(300) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp(0) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 272 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci COMMENT = '网站信息' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of box_site
-- ----------------------------
INSERT INTO `box_site` VALUES (1, 1, 'Dribbble', '7db1257f40b9b04482744387a00b359d.png', '全球UI设计师作品分享平台。', 'https://dribbble.com/', '2019-01-21 15:23:29', '2019-03-12 02:13:08');
INSERT INTO `box_site` VALUES (2, 1, 'Behance', 'c3b59ad338e7e122072b867381e4b599.png', 'Adobe旗下的设计师交流平台，来自世界各地的设计师在这里分享自己的作品。', 'https://behance.net/', '2019-01-22 01:11:24', '2019-01-22 01:11:24');
INSERT INTO `box_site` VALUES (3, 1, 'UI中国', '9458ececbfeea651b5e871179f245ce5.png', '图形交互与界面设计交流、作品展示、学习平台。', 'http://www.ui.cn/', '2019-01-22 01:13:10', '2019-01-22 01:13:10');
INSERT INTO `box_site` VALUES (4, 1, '站酷', 'c2aa8b63006d36a026e419bf3e0d7e50.png', '中国人气设计师互动平台。', 'http://www.zcool.com.cn/', '2019-01-22 01:14:04', '2019-01-22 01:14:04');
INSERT INTO `box_site` VALUES (5, 1, 'Pinterest', '4b8c9c66df25d3867961ebbd6a824eea.png', '全球美图收藏采集站。', 'https://www.pinterest.com/', '2019-01-22 01:14:51', '2019-01-22 01:14:51');
INSERT INTO `box_site` VALUES (6, 1, '花瓣', '48c7741c42e39eae508c3d9eef4e7a97.png', '收集灵感,保存有用的素材。', 'http://huaban.com/', '2019-01-22 01:15:35', '2019-01-22 01:15:35');
INSERT INTO `box_site` VALUES (7, 1, 'Medium', '11b56d4a9cc9297638d46c4b67c73693.png', '高质量设计文章。', 'https://medium.com/', '2019-01-22 01:16:14', '2019-01-22 01:16:14');
INSERT INTO `box_site` VALUES (8, 1, '优设', '636342035cdd2fbc08097d012b5e5fad.png', '设计师交流学习平台。', 'http://www.uisdc.com/', '2019-01-22 01:17:07', '2019-01-22 01:17:07');
INSERT INTO `box_site` VALUES (9, 1, 'Producthunt', '8bdf511e23b183f9aac30aee3368152b.png', '发现新鲜有趣的产品。', 'https://www.producthunt.com/', '2019-01-22 01:17:50', '2019-01-22 01:17:50');
INSERT INTO `box_site` VALUES (10, 1, 'Youtube', '15b4f46186f718e92b97f6f282f140fd.png', '全球最大的学习分享平台。', 'https://www.youtube.com/', '2019-01-22 01:18:31', '2019-01-22 01:18:31');
INSERT INTO `box_site` VALUES (11, 36, 'Google', '643faef109965a9cedcf9cde74d0adb1.png', '全球最大的搜索平台。', 'https://www.google.com/', '2019-01-22 01:19:35', '2019-12-19 11:02:46');
INSERT INTO `box_site` VALUES (12, 2, '雷锋网', '57ab570b631cc25a23390f507d496bc6.png', '人工智能和智能硬件领域的互联网科技媒体。', 'https://www.leiphone.com/', '2019-01-22 01:21:05', '2019-01-22 01:21:05');
INSERT INTO `box_site` VALUES (13, 2, '36kr', 'adef44c84185d959446024452ad615cc.png', '创业资讯、科技新闻。', 'http://36kr.com/', '2019-01-22 01:21:52', '2019-01-22 01:21:52');
INSERT INTO `box_site` VALUES (14, 2, '数英网', 'cee8fd836f98652f52fcc6046ba9db89.png', '数字媒体及职业招聘网站。', 'https://www.digitaling.com/', '2019-01-22 01:23:15', '2019-01-22 01:23:15');
INSERT INTO `box_site` VALUES (15, 2, '猎云网', 'f9b1cfa239abdda5ee2dca7c04ca2d73.png', '互联网创业项目推荐和创业创新资讯。', 'http://www.lieyunwang.com/', '2019-01-22 01:24:21', '2019-01-22 01:24:21');
INSERT INTO `box_site` VALUES (16, 2, '人人都是产品经理', 'fe7dcb7b5937c3bcf6043ba7d9379fbe.png', '产品经理、产品爱好者学习交流平台。', 'http://www.woshipm.com/', '2019-01-22 01:25:07', '2019-01-22 01:25:07');
INSERT INTO `box_site` VALUES (17, 2, '互联网早读课', 'ecd5eefc4ec4bac49916a91c2da44412.png', '互联网行业深度阅读与学习平台。', 'https://www.zaodula.com/', '2019-01-22 01:25:41', '2019-01-22 01:25:41');
INSERT INTO `box_site` VALUES (18, 2, '产品壹佰', '2f4235fb1eb75822a44903d9894760d7.png', '为产品经理爱好者提供最优质的产品资讯、原创内容和相关视频课程。', 'http://www.chanpin100.com/', '2019-01-22 01:26:27', '2019-01-22 01:26:27');
INSERT INTO `box_site` VALUES (19, 2, 'PMCAFF', 'a76e60c2d42f5bbdacbf7dd120810194.png', '中国第一产品经理人气组织，专注于研究互联网产品。', 'http://www.pmcaff.com/', '2019-01-22 01:27:08', '2019-01-22 01:27:08');
INSERT INTO `box_site` VALUES (20, 2, '爱运营', 'f84a9e00d63b007ea09df75dbdaf9549.png', '网站运营人员学习交流，专注于网站产品运营管理、淘宝运营。', 'http://www.iyunying.org/', '2019-01-22 01:28:09', '2019-01-22 01:28:09');
INSERT INTO `box_site` VALUES (21, 2, '鸟哥笔记', 'e424308a81c187bc42e95addf462b4c8.png', '移动互联网第一干货平台。', 'http://www.niaogebiji.com/', '2019-01-22 01:29:56', '2019-01-22 01:29:56');
INSERT INTO `box_site` VALUES (22, 2, '古田路9号', 'e22a54099a69f7e76c471d7f6a253fe8.png', '国内专业品牌创意平台。', 'http://www.gtn9.com/', '2019-01-22 01:30:29', '2019-01-22 01:30:29');
INSERT INTO `box_site` VALUES (23, 2, '优阁网', '74a25f510e403f4ef28212146510dfa7.png', 'UI设计师学习交流社区。', 'http://www.uigreat.com/', '2019-01-22 01:32:17', '2019-01-22 01:32:17');
INSERT INTO `box_site` VALUES (24, 4, 'Producthunt', 'a1cc88fa0a3bf74349ba9c08a67abdc7.png', '发现新鲜有趣的产品。', 'https://www.producthunt.com/', '2019-01-22 01:33:37', '2019-01-22 01:33:37');
INSERT INTO `box_site` VALUES (25, 4, 'NEXT', '0e2b6c9a5afd4f83d2e22632b08f56ef.png', '不错过任何一个新产品。', 'http://next.36kr.com/posts', '2019-01-22 01:34:41', '2019-01-22 01:34:41');
INSERT INTO `box_site` VALUES (26, 4, '少数派', '2d01ac82bb496b607c43e7b2b29cd069.png', '高品质数字消费指南。', 'https://sspai.com/', '2019-01-22 01:36:08', '2019-01-22 01:36:08');
INSERT INTO `box_site` VALUES (27, 4, '利器', '98e2ee62a90b6243630f4aa479b4b47b.png', '创造者和他们的工具。', 'http://liqi.io/', '2019-01-22 01:36:53', '2019-01-22 01:36:53');
INSERT INTO `box_site` VALUES (28, 4, 'Today', '1726189292537c3a2733ebc673b7f1d6.png', '为身边的新产品喝彩。', 'http://today.itjuzi.com/', '2019-01-22 01:37:37', '2019-01-22 01:37:37');
INSERT INTO `box_site` VALUES (29, 4, '小众软件', '76b49053ce87ab3c7419c7cdf6fa4f07.png', '在这里发现更多有趣的应用。', 'https://faxian.appinn.com', '2019-01-22 01:38:04', '2019-01-22 01:38:04');
INSERT INTO `box_site` VALUES (30, 5, 'Pttrns', '1c759dc53774e5758a31fee0401e213a.png', 'Check out the finest collection of design patterns, resources, mobile apps and inspiration', 'https://www.pttrns.com/', '2019-01-22 01:39:09', '2019-01-22 01:39:09');
INSERT INTO `box_site` VALUES (31, 5, 'Collect UI', '7e802c77c7bb6c85c1e2bb608a4a13cd.png', 'Daily inspiration collected from daily ui archive and beyond.', 'http://collectui.com/', '2019-01-22 01:39:58', '2019-01-22 01:39:58');
INSERT INTO `box_site` VALUES (32, 5, 'UI uigreat', 'd140fe4bd548f273ddd00f35e1ad5ff5.png', 'APP界面截图参考。', 'http://ui.uigreat.com/', '2019-01-22 01:40:40', '2019-01-22 01:40:40');
INSERT INTO `box_site` VALUES (33, 5, 'Android Niceties', '8b6e0af7df3a5d77a14e41a0f5f36dc5.png', 'A collection of screenshots encompassing some of the most beautiful looking Android apps.', 'http://androidniceties.tumblr.com/', '2019-01-22 01:41:21', '2019-01-22 01:41:21');
INSERT INTO `box_site` VALUES (34, 6, 'Awwwards', 'bdd6c88417790c97de2c2d0643cc602c.png', 'aaa', 'https://www.awwwards.com/', '2019-01-22 01:44:09', '2019-01-22 01:51:33');
INSERT INTO `box_site` VALUES (35, 6, 'CSS Design Awards', '481219fe4285f1f4ec1311acce7deb06.png', 'Website Awards & Inspiration - CSS Gallery', 'https://www.cssdesignawards.com/', '2019-01-22 01:44:45', '2019-01-22 01:51:41');
INSERT INTO `box_site` VALUES (36, 6, 'The FWA', '8fe5280ff7dc3012fb88781dd9ff4b93.png', 'FWA - showcasing innovation every day since 2000', 'https://thefwa.com/', '2019-01-22 01:45:19', '2019-01-22 01:51:48');
INSERT INTO `box_site` VALUES (37, 6, 'Ecommercefolio', '950d52c71e28f1c9ed964732d6ed18fd.png', 'Only the Best Ecommerce Design Inspiration.', 'http://www.ecommercefolio.com/', '2019-01-22 01:50:41', '2019-01-22 01:50:41');
INSERT INTO `box_site` VALUES (38, 6, 'Lapa', '1824678ec13d01b76df47fc5975178fa.png', 'The best landing page design inspiration from around the web.', 'http://www.lapa.ninja/', '2019-01-22 01:51:15', '2019-01-22 01:51:15');
INSERT INTO `box_site` VALUES (39, 6, 'Reeoo', '5205b768b9b640bfada244ce9d15318d.png', 'web design inspiration and website gallery.', 'http://reeoo.com/', '2019-01-22 01:52:43', '2019-01-22 01:52:43');
INSERT INTO `box_site` VALUES (40, 6, 'Designmunk', '31de409b71235b76d605e98293d68cb3.png', 'Best Homepage Design Inspiration.', 'https://designmunk.com/', '2019-01-22 01:53:28', '2019-01-22 01:53:28');
INSERT INTO `box_site` VALUES (41, 6, 'Best Websites Gallery', '862823249aa701d8bc8af16ae98f1e3a.png', 'Website Showcase Inspiration | Best Websites Gallery.', 'https://bestwebsite.gallery/', '2019-01-22 01:57:32', '2019-01-22 01:57:32');
INSERT INTO `box_site` VALUES (42, 6, 'Pages', '90fd20bd3e7ae7c7fe37ea689dcca32c.png', 'Curated directory of the best Pages.', 'http://www.pages.xyz/', '2019-01-22 01:58:07', '2019-01-22 01:58:07');
INSERT INTO `box_site` VALUES (43, 6, 'SiteSee', 'da24d08a597456be98191b4a08eff4d6.png', 'SiteSee is a curated gallery of beautiful, modern websites collections.', 'https://sitesee.co/', '2019-01-22 01:58:42', '2019-01-22 01:58:42');
INSERT INTO `box_site` VALUES (44, 6, 'Site Inspire', 'c15c9017ad6874faae0df64bd969115b.png', 'A CSS gallery and showcase of the best web design inspiration.', 'https://www.siteinspire.com/', '2019-01-22 01:59:13', '2019-01-22 01:59:13');
INSERT INTO `box_site` VALUES (45, 6, 'WebInspiration', 'f8fe63594e2083755086ee294b036108.png', '网页设计欣赏,全球顶级网页设计。', 'http://web.uedna.com/', '2019-01-22 01:59:54', '2019-01-22 01:59:54');
INSERT INTO `box_site` VALUES (46, 6, 'navnav', '86b9e596068f2a71d2a2444733a4094e.png', 'A ton of CSS, jQuery, and JavaScript responsive navigation examples, demos, and tutorials from all over the web.', 'http://navnav.co/', '2019-01-22 02:00:24', '2019-01-22 02:00:24');
INSERT INTO `box_site` VALUES (47, 6, 'Really Good UX', '948b0f5b62e59ef0a97edf4b9a51c404.png', 'A library of screenshots and examples of really good UX. Brought to you by .', 'https://www.reallygoodux.io/', '2019-01-22 02:01:05', '2019-01-22 02:01:05');
INSERT INTO `box_site` VALUES (48, 8, 'Iconfinder', 'e3325f68179436ccfc25b9f0ffff5a39.png', '2,100,000+ free and premium vector icons.', 'https://www.iconfinder.com', '2019-01-22 03:01:41', '2019-01-22 03:01:41');
INSERT INTO `box_site` VALUES (49, 8, 'iconfont', 'e1f63337915f79f8bcad1952adb9f6e1.png', '阿里巴巴矢量图标库。', 'http://www.iconfont.cn/', '2019-01-22 03:02:16', '2019-01-22 03:02:16');
INSERT INTO `box_site` VALUES (50, 8, 'iconmonstr', 'afd4885651455f12dcac4f214460dd99.png', 'Free simple icons for your next project.', 'https://iconmonstr.com/', '2019-01-22 03:02:46', '2019-01-22 03:02:46');
INSERT INTO `box_site` VALUES (51, 8, 'FindIcons', '0171a46b0f643752aa90aa314a22a546.png', 'Search through 300,000 free icons.', 'https://findicons.com/', '2019-01-22 03:03:24', '2019-01-22 03:03:24');
INSERT INTO `box_site` VALUES (52, 8, 'Icon Archive', '40c43a8932f24370cf456789b2ab51db.png', 'Search 590,912 free icons.', 'http://www.iconarchive.com/', '2019-01-22 03:04:28', '2019-01-22 03:04:28');
INSERT INTO `box_site` VALUES (53, 8, 'IcoMoonApp', 'd19c97ead3760f1b70efa4ee9ad6859c.png', 'Icon Font, SVG, PDF & PNG Generator.', 'https://icomoon.io/app/', '2019-01-22 03:05:49', '2019-01-22 03:05:49');
INSERT INTO `box_site` VALUES (54, 8, 'easyicon', '34b4382075e047c6d1456f8fe591a1ef.png', 'PNG、ICO、ICNS格式图标搜索、图标下载服务。', 'http://www.easyicon.net/', '2019-01-22 03:06:47', '2019-01-22 03:06:47');
INSERT INTO `box_site` VALUES (55, 8, 'flaticon', '582cf7361a0b4f444628c68b98e5cfc7.png', '634,000+ Free vector icons in SVG, PSD, PNG, EPS format or as ICON FONT.', 'https://www.flaticon.com/', '2019-01-22 03:07:28', '2019-01-22 03:07:28');
INSERT INTO `box_site` VALUES (56, 8, 'UICloud', 'f9840e127d500449da1c5c721f3634c3.png', 'The largest user interface design database in the world.', 'http://ui-cloud.com/', '2019-01-22 03:08:10', '2019-01-22 03:08:10');
INSERT INTO `box_site` VALUES (57, 8, 'Material icons', '32a037ffbdd2f97f6f6e62e56321c519.png', 'Access over 900 material system icons, available in a variety of sizes and densities, and as a web font.', 'https://material.io/icons/', '2019-01-22 03:09:00', '2019-01-22 03:09:00');
INSERT INTO `box_site` VALUES (58, 8, 'Font Awesome Icon', '88440b8b0d5dc43a3f766670e2d11746.png', 'The complete set of 675 icons in Font Awesome.', 'https://fontawesome.com/', '2019-01-22 03:09:59', '2019-01-22 03:09:59');
INSERT INTO `box_site` VALUES (59, 8, 'ion icons', '6d0fd0bf35549f6d61037bd86e2ca242.png', 'The premium icon font for Ionic Framework.', 'http://ionicons.com/', '2019-01-22 03:10:37', '2019-01-22 03:10:37');
INSERT INTO `box_site` VALUES (60, 8, 'Simpleline Icons', 'acf446f1af754f863260cc10dd8d546e.png', 'Simple line Icons pack.', 'http://simplelineicons.com/', '2019-01-22 03:11:11', '2019-01-22 03:11:11');
INSERT INTO `box_site` VALUES (61, 9, 'Iconsfeed', 'aee21da67d9771c2ebf3f6779afc9649.png', 'iOS icons gallery.', 'http://www.iconsfeed.com/', '2019-01-22 03:12:11', '2019-01-22 03:12:11');
INSERT INTO `box_site` VALUES (62, 9, 'iOS Icon Gallery', '98c9f52ede06a56532d5d16afda9d570.png', 'Showcasing beautiful icon designs from the iOS App Store.', 'http://iosicongallery.com/', '2019-01-22 03:12:59', '2019-01-22 03:12:59');
INSERT INTO `box_site` VALUES (63, 9, 'World Vector Logo', 'c8da40d11f726d974293efc40c9acfb5.png', 'Brand logos free to download.', 'https://worldvectorlogo.com/', '2019-01-22 03:14:10', '2019-01-22 03:14:10');
INSERT INTO `box_site` VALUES (64, 9, 'Instant Logo Search', '907f35950eae72526a314306cc59efa7.png', 'Search & download thousands of logos instantly.', 'http://instantlogosearch.com/', '2019-01-22 03:14:50', '2019-01-22 03:14:50');
INSERT INTO `box_site` VALUES (65, 10, 'freepik', '6a96564b2d100bad3674db5e56794a97.png', 'More than a million free vectors, PSD, photos and free icons.', 'https://www.freepik.com/', '2019-01-22 03:17:22', '2019-01-22 03:17:22');
INSERT INTO `box_site` VALUES (66, 10, 'wallhalla', '9354f99621e8530d0f996fe4b96ad2c3.png', 'Find awesome high quality wallpapers for desktop and mobile in one place.', 'https://wallhalla.com/', '2019-01-22 03:17:55', '2019-01-22 03:17:55');
INSERT INTO `box_site` VALUES (67, 10, '365PSD', '13b10a2f9388e83101d7a35b83ff28bc.png', 'Free PSD & Graphics, Illustrations.', 'https://365psd.com/', '2019-01-22 03:18:22', '2019-01-22 03:18:22');
INSERT INTO `box_site` VALUES (68, 10, 'Medialoot', 'b117eb768a44d662ded91d1f0a9cb1c2.png', 'Free & Premium Design Resources — Medialoot.', 'https://medialoot.com/', '2019-01-22 03:18:52', '2019-01-22 03:18:52');
INSERT INTO `box_site` VALUES (69, 10, '千图网', '9a24027c0e9d498efb4ad88a330882f8.png', '专注免费设计素材下载的网站。', 'http://www.58pic.com/', '2019-01-22 03:19:35', '2019-01-22 03:19:35');
INSERT INTO `box_site` VALUES (70, 10, '千库网', '15ffa7b3a5cab15c7d23d402be12cc4c.png', '免费png图片背景素材下载。', 'http://588ku.com/', '2019-01-22 03:20:14', '2019-01-22 03:20:14');
INSERT INTO `box_site` VALUES (71, 10, '我图网', 'a887a255bbe7fe994e0479ae988372c7.png', '我图网,提供图片素材及模板下载,专注正版设计作品交易。', 'http://www.ooopic.com/', '2019-01-22 03:20:54', '2019-01-22 03:20:54');
INSERT INTO `box_site` VALUES (72, 10, '90设计', 'c510c1946d6191a98c6fd3b08ca720ec.png', '电商设计（淘宝美工）千图免费淘宝素材库。', 'http://90sheji.com/', '2019-01-22 03:21:29', '2019-01-22 03:21:29');
INSERT INTO `box_site` VALUES (73, 10, '昵图网', 'd4fba2a16c7a1692ea21f4f0a8ae7672.png', '原创素材共享平台。', 'http://www.nipic.com/', '2019-01-22 03:22:11', '2019-01-22 03:22:11');
INSERT INTO `box_site` VALUES (74, 10, '懒人图库', 'a7e5f98173ea111df83da146a86436a1.png', '懒人图库专注于提供网页素材下载。', 'http://www.lanrentuku.com/', '2019-01-22 03:23:20', '2019-01-22 03:23:20');
INSERT INTO `box_site` VALUES (75, 10, '素材搜索', 'cbca7fabfd7c6d1b117547466bc564ad.png', '设计素材搜索聚合。', 'http://so.ui001.com/', '2019-01-22 03:24:03', '2019-01-22 03:24:03');
INSERT INTO `box_site` VALUES (76, 10, 'PS饭团网', '7ffad2eac8cbad395d33914344d3aa0a.png', '不一样的设计素材库！让自己的设计与众不同！', 'http://psefan.com/', '2019-01-22 03:24:44', '2019-01-22 03:24:44');
INSERT INTO `box_site` VALUES (77, 10, '素材中国', 'ced6b2a53069c7d360ba78706244081f.png', '免费素材共享平台。', 'http://www.sccnn.com/', '2019-01-22 03:25:22', '2019-01-22 03:25:22');
INSERT INTO `box_site` VALUES (78, 11, 'Freebiesbug', '4288052485ced84952e206a4acfb92ad.png', 'Hand-picked resources for web designer and developers, constantly updated.', 'https://freebiesbug.com/', '2019-01-22 03:26:32', '2019-01-22 03:26:32');
INSERT INTO `box_site` VALUES (79, 11, 'Freebie Supply', '2ae393ad916a108ba20d21a8b907477e.png', 'Free Resources For Designers.', 'https://freebiesupply.com/', '2019-01-22 03:27:09', '2019-01-22 03:27:09');
INSERT INTO `box_site` VALUES (80, 11, '云瑞', '528f9304b0dab49f5fe2426d4d9d047c.png', '优秀设计资源的分享网站。', 'https://www.yrucd.com/', '2019-01-22 04:20:59', '2019-01-22 04:20:59');
INSERT INTO `box_site` VALUES (81, 11, 'Designmodo', '2061e0ccebfbb1a94a28d86237589b23.png', 'Web Design Blog and Shop.', 'https://designmodo.com/', '2019-01-22 04:21:38', '2019-01-22 04:21:38');
INSERT INTO `box_site` VALUES (82, 11, '稀土区', '4f5171443ad0ec6b13b7f96b8cead4bd.png', '优质设计开发资源分享。', 'https://xituqu.com/', '2019-01-22 04:22:15', '2019-01-22 04:22:15');
INSERT INTO `box_site` VALUES (83, 11, 'ui8', 'b815917aad63f449a96900979a16eb4e.png', 'UI Kits, Wireframe Kits, Templates, Icons and More.', 'https://ui8.net/', '2019-01-22 04:22:57', '2019-01-22 04:22:57');
INSERT INTO `box_site` VALUES (84, 11, 'uplabs', '42d3d29c62a19e8d4ca6395586d79ee7.png', 'Daily resources for product designers & developers.', 'https://www.uplabs.com/', '2019-01-22 04:23:39', '2019-01-22 04:23:39');
INSERT INTO `box_site` VALUES (85, 11, 'UIkit.me', '13b4ac8efdc9f92e52e7f271b8034b24.png', '最便捷新鲜的uikit资源下载网站。', 'http://www.uikit.me/', '2019-01-22 04:24:19', '2019-01-22 04:24:19');
INSERT INTO `box_site` VALUES (86, 11, 'Fribbble', '04c1b51de97ceac330358fa7d1685034.png', 'Free PSD files and other free design resources by Dribbblers.', 'http://www.fribbble.com/', '2019-01-22 04:24:54', '2019-01-22 04:24:54');
INSERT INTO `box_site` VALUES (87, 11, 'PrincipleRepo', 'e3e93f407dcc94461bea06979e89e4a2.png', 'Free, High Quality Principle Resources.', 'http://principlerepo.com/', '2019-01-22 04:25:30', '2019-01-22 04:25:30');
INSERT INTO `box_site` VALUES (88, 12, 'Sketch', 'ff6a2f8afaeb91004416c96788f9da95.png', 'The digital design toolkit.', 'https://sketchapp.com/', '2019-01-22 04:26:17', '2019-01-22 04:26:17');
INSERT INTO `box_site` VALUES (89, 12, 'Sketch Measure', '69bf814d311d932ea13b746ffc1f9f54.png', 'Friendly user interface offers you a more intuitive way of making marks.', 'http://utom.design/measure/', '2019-01-22 04:26:55', '2019-01-22 04:26:55');
INSERT INTO `box_site` VALUES (90, 12, 'Sketch App Sources', 'ccf82c5a27a285ba63cf3c4ff8964a25.png', 'Free design resources and plugins - Icons, UI Kits, Wireframes, iOS, Android Templates for Sketch', 'https://www.sketchappsources.com/', '2019-01-22 04:27:43', '2019-01-22 04:27:43');
INSERT INTO `box_site` VALUES (91, 12, 'Sketch.im', '6055276a55b62db423c2b060d3f6b044.png', 'Sketch 相关资源汇聚。', 'http://www.sketch.im/', '2019-01-22 04:28:20', '2019-01-22 04:28:20');
INSERT INTO `box_site` VALUES (92, 12, 'Sketch Hunt', 'c4bf007a61d761db1f895672a2519cd0.png', 'Sketch Hunt is an independent blog sharing gems in learning, plugins & design tools for fans of Sketch app.', 'http://sketchhunt.com/', '2019-01-22 04:29:44', '2019-01-22 04:29:44');
INSERT INTO `box_site` VALUES (93, 12, 'Sketch中文网', 'a26a90da0d304cd3502cdb53e85995b9.png', '分享最新的Sketch中文手册。', 'http://www.sketchcn.com/', '2019-01-22 04:30:21', '2019-01-22 04:30:21');
INSERT INTO `box_site` VALUES (94, 12, 'Awesome Sketch Plugins', '255cf49affef2fbaba8cd15c3e7329b5.png', 'A collection of really useful Sketch plugins.', 'https://awesome-sket.ch/', '2019-01-22 04:31:24', '2019-01-22 04:31:24');
INSERT INTO `box_site` VALUES (95, 12, 'Sketchcasts', 'fa8c8b179ab48ad61e61a18d1720e019.png', 'Learn Sketch Train your design skills with a weekly video tutorial', 'https://www.sketchcasts.net/', '2019-01-22 04:32:00', '2019-01-22 04:32:00');
INSERT INTO `box_site` VALUES (96, 13, 'Google Font', '91c604a4ca98b1bb5719e04c80043419.png', 'Making the web more beautiful, fast, and open through great typography.', 'https://fonts.google.com/', '2019-01-22 04:32:42', '2019-01-22 04:32:42');
INSERT INTO `box_site` VALUES (97, 13, 'Typekit', '7dbc17741d30274995615612dc1d075f.png', 'Quality fonts from the world’s best foundries.', 'https://typekit.com/', '2019-01-22 04:33:14', '2019-01-22 04:33:14');
INSERT INTO `box_site` VALUES (98, 13, '方正字库', '8ffeec1d3ad96a39dd4ede9794756b87.png', '方正字库官方网站。', 'http://www.foundertype.com/', '2019-01-22 04:37:57', '2019-01-22 04:37:57');
INSERT INTO `box_site` VALUES (99, 13, '字体传奇网', 'd5fc1ea541fe215ae449a0ae27a09a76.png', '中国首个字体品牌设计师交流网。', 'http://ziticq.com/', '2019-01-22 04:38:51', '2019-01-22 04:38:51');
INSERT INTO `box_site` VALUES (100, 13, '私藏字体', '125e538efd8b3ea68d3655cb81ccc06f.png', '优质字体免费下载站。', 'http://sicangziti.com/', '2019-01-22 04:40:03', '2019-01-22 04:40:03');
INSERT INTO `box_site` VALUES (101, 13, 'Fontsquirrel', '94684e5203623eb5540a4b5a0e0b70b0.png', 'FREE fonts for graphic designers.', 'https://www.fontsquirrel.com/', '2019-01-22 04:40:43', '2019-01-22 04:40:43');
INSERT INTO `box_site` VALUES (102, 13, 'Urban Fonts', '40139afeda032d1a3cd54459d065b31b.png', 'Download Free Fonts and Free Dingbats.', 'https://www.urbanfonts.com/', '2019-01-22 04:41:23', '2019-01-22 04:41:23');
INSERT INTO `box_site` VALUES (103, 13, 'Lost Type', 'cfe0904ec3e37914be51687a2b15f5cf.png', 'Lost Type is a Collaborative Digital Type Foundry.', 'http://www.losttype.com/', '2019-01-22 04:41:56', '2019-01-22 04:41:56');
INSERT INTO `box_site` VALUES (104, 13, 'FONTS2U', '19bd844dc123066620d1f6fda7287e48.png', 'Download free fonts for Windows and Macintosh.', 'https://fonts2u.com/', '2019-01-22 04:42:46', '2019-01-22 04:42:46');
INSERT INTO `box_site` VALUES (105, 13, 'Fontex', '1576a7303fb2fa3839016a599418203b.png', 'Free Fonts to Download + Premium Typefaces.', 'http://www.fontex.org/', '2019-01-22 04:43:17', '2019-01-22 04:43:17');
INSERT INTO `box_site` VALUES (106, 13, 'FontM', '5ee459b3c52027eb8dcd9c8c6e9266a0.png', 'Free Fonts.', 'http://fontm.com/', '2019-01-22 04:43:49', '2019-01-22 04:43:49');
INSERT INTO `box_site` VALUES (107, 13, 'My Fonts', '22572b2d9b38ea02f173074d59acf334.png', 'Fonts for Print, Products & Screens.', 'http://www.myfonts.com/', '2019-01-22 04:45:27', '2019-01-22 04:45:27');
INSERT INTO `box_site` VALUES (108, 13, 'Da Font', 'd0478f80b89bff215437714e62c6d997.png', 'Archive of freely downloadable fonts.', 'https://www.dafont.com/', '2019-01-22 04:46:04', '2019-01-22 04:46:04');
INSERT INTO `box_site` VALUES (109, 13, 'OnlineWebFonts', 'bccc59c04f6f283a63430700273ffdee.png', 'WEB Free Fonts for Windows and Mac / Font free Download.', 'https://www.onlinewebfonts.com/', '2019-01-22 04:46:36', '2019-01-22 04:46:36');
INSERT INTO `box_site` VALUES (110, 13, 'Abstract Fonts', 'fbedc66f865056e650a036f042625057.png', 'Abstract Fonts (13,866 free fonts).', 'http://www.abstractfonts.com/', '2019-01-22 04:47:08', '2019-01-22 04:47:08');
INSERT INTO `box_site` VALUES (111, 14, 'MockupZone', '75e599ff2f061dc25fa272de94045ca9.png', 'Mockup Zone is an online store where you can find free and premium PSD mockup files to show your designs in a professional way.', 'https://mockup.zone/', '2019-01-22 05:07:01', '2019-01-22 05:07:01');
INSERT INTO `box_site` VALUES (112, 14, 'Dunnnk', '7949d12743b95779412dd8673c324164.png', 'Generate Product Mockups For Free.', 'http://dunnnk.com/', '2019-01-22 05:08:13', '2019-01-22 05:08:13');
INSERT INTO `box_site` VALUES (113, 14, 'Graphberry', '1216f3642b463e7e9d493e4d00506566.png', 'Free design resources, Mockups, PSD web templates, Icons.', 'http://www.graphberry.com/', '2019-01-22 05:08:51', '2019-01-22 05:08:51');
INSERT INTO `box_site` VALUES (114, 14, 'Threed', '252114418dc086100cd58d10035a9436.png', 'Generate 3D Mockups right in your Browser', 'http://threed.io/', '2019-01-22 05:09:22', '2019-01-22 05:09:22');
INSERT INTO `box_site` VALUES (115, 14, 'Mockup World', 'c94ee98e4ada29c0916888820da31744.png', 'The best free Mockups from the Web', 'https://free.lstore.graphics/', '2019-01-22 05:09:54', '2019-01-22 05:09:54');
INSERT INTO `box_site` VALUES (116, 14, 'Lstore', '965f25d08ae3cd33fab21d764a514967.png', 'Exclusive mindblowing freebies for designers and developers.', 'https://free.lstore.graphics/', '2019-01-22 05:11:00', '2019-01-22 05:11:00');
INSERT INTO `box_site` VALUES (117, 14, 'pixeden', 'f8b5261bc1d5e5189b9c1216a6de8b3b.png', 'free web resources and graphic design templates.', 'https://www.pixeden.com/', '2019-01-22 05:11:36', '2019-01-22 05:11:36');
INSERT INTO `box_site` VALUES (118, 14, 'For Graphic TM', '20fceec1b9dd6c1183ad73a90becce7f.png', 'High Quality PSD Mockups for Graphic Designers.', 'http://forgraphictm.com/', '2019-01-22 05:12:28', '2019-01-22 05:12:28');
INSERT INTO `box_site` VALUES (119, 15, 'Unsplash', '72880b02dbea40fd84472abc05e6d23b.png', 'Beautiful, free photos.', 'https://unsplash.com/', '2019-01-22 05:16:19', '2019-01-22 05:16:19');
INSERT INTO `box_site` VALUES (120, 15, 'visualhunt', 'b2a1a1e4c043858ac2411f02b9236ff3.png', '100% Free High Quality Photos.', 'https://visualhunt.com/', '2019-01-22 05:16:55', '2019-01-22 05:16:55');
INSERT INTO `box_site` VALUES (121, 15, 'librestock', '94c5305f78dfadb241f9edcf3d9b870d.png', '65,084 high quality do-what-ever-you-want stock photos.', 'https://librestock.com/', '2019-01-22 05:17:27', '2019-01-22 05:17:34');
INSERT INTO `box_site` VALUES (122, 15, 'pixabay', '310cb7b52774323c7fdffe67aa0f12aa.png', '可在任何地方使用的免费图片和视频。', 'https://pixabay.com/', '2019-01-22 05:18:10', '2019-01-22 05:18:10');
INSERT INTO `box_site` VALUES (123, 15, 'SplitShire', '0e9933021af7cc4714e900c247010b30.png', 'Free Stock Photos and Videos for commercial use.', 'https://www.splitshire.com/', '2019-01-22 05:19:07', '2019-01-22 05:19:07');
INSERT INTO `box_site` VALUES (124, 15, 'StockSnap', 'fabf86558eb3a7c943c124f7f62f3542.png', 'Beautiful free stock photos.', 'https://stocksnap.io/', '2019-01-22 05:19:40', '2019-01-22 05:19:40');
INSERT INTO `box_site` VALUES (125, 15, 'albumarium', 'de8b7f26a21ea0b781f93a3163341731.png', 'The best place to find & share beautiful images.', 'http://albumarium.com/', '2019-01-22 05:20:11', '2019-01-22 05:20:11');
INSERT INTO `box_site` VALUES (126, 15, 'myphotopack', '80d85ea59d293bd43731a890f63c5dc9.png', 'A free photo pack just for you. Every month.', 'https://myphotopack.com/', '2019-01-22 05:20:44', '2019-01-22 05:20:44');
INSERT INTO `box_site` VALUES (127, 15, 'Notaselfie', 'eb5f9a9661e582883c9d3128bb9b4482.png', 'Photos that happen along the way. You can use the images anyway you like. Have fun!', 'http://notaselfie.com/', '2019-01-22 05:21:31', '2019-01-22 05:21:31');
INSERT INTO `box_site` VALUES (128, 15, 'papers', '3a6396ba24d253502f40432751a11b07.png', 'Wallpapers Every Hour!Hand collected :)', 'http://papers.co/', '2019-01-22 05:22:06', '2019-01-22 05:22:06');
INSERT INTO `box_site` VALUES (129, 15, 'stokpic', '9dce238279b24893eaa20a99fba802ea.png', 'Free Stock Photos For Commercial Use.', 'http://stokpic.com/', '2019-01-22 05:22:55', '2019-01-22 05:22:55');
INSERT INTO `box_site` VALUES (130, 15, '55mm', 'dd8adcbc65cc20e8fb6d6335fd57814a.png', 'Use our FREE photos to tell your story!', 'https://55mm.co/visuals', '2019-01-22 05:23:27', '2019-01-22 05:23:27');
INSERT INTO `box_site` VALUES (131, 15, 'thestocks', '2be533b5b00139b9022f09604f3bd136.png', 'Use our FREE photos to tell your story!', 'http://thestocks.im/', '2019-01-22 05:24:11', '2019-01-22 05:24:11');
INSERT INTO `box_site` VALUES (132, 15, 'freenaturestock', '85c87259ac26b4f48b084066b9e3ec8e.png', 'Exclusive mindblowing freebies for designers and developers.', 'http://freenaturestock.com/', '2019-01-22 05:27:20', '2019-01-22 05:27:20');
INSERT INTO `box_site` VALUES (133, 15, 'negativespace', '9b470b26c5e7e6604f3f17d2fe518af7.png', 'Beautiful, High-Resolution Free Stock Photos.', 'https://negativespace.co/', '2019-01-22 05:28:11', '2019-01-22 05:28:11');
INSERT INTO `box_site` VALUES (134, 15, 'gratisography', '37a9bff7f4d756e7b227ef295aa5ff82.png', 'Free high-resolution pictures you can use on your personal and commercial projects, free of copyright restrictions.', 'https://gratisography.com/', '2019-01-22 05:28:53', '2019-01-22 05:28:53');
INSERT INTO `box_site` VALUES (135, 15, 'imcreator', '568ae371ba49ce83463d5833af6a8e88.png', 'A curated collection of free web design resources, all for commercial use.', 'http://imcreator.com/free', '2019-03-12 02:21:55', '2019-03-12 02:21:55');
INSERT INTO `box_site` VALUES (136, 15, 'lifeofpix', '94bf5d51c1367552f337610dbc6aa44b.png', 'Free high resolution photography', 'http://www.lifeofpix.com/', '2019-03-12 02:22:49', '2019-03-12 02:22:49');
INSERT INTO `box_site` VALUES (137, 15, 'skitterphoto', '23663c43cb7025f3bf36e9733bea6171.png', 'Free Stock Photos for Creative Professionals', 'https://skitterphoto.com/', '2019-03-12 02:23:32', '2019-03-12 02:23:32');
INSERT INTO `box_site` VALUES (138, 15, 'mmtstock', 'd8d5768d2dc63763480478ae25aa176a.png', 'Free photos for commercial use', 'https://mmtstock.com/', '2019-03-12 02:24:19', '2019-03-12 02:24:19');
INSERT INTO `box_site` VALUES (139, 15, 'magdeleine', '12ca6edef00d1d897eb28c4a8e2f8915.png', 'HAND-PICKED FREE PHOTOS FOR YOUR INSPIRATION', 'https://magdeleine.co/browse/', '2019-03-12 02:25:17', '2019-03-12 02:25:17');
INSERT INTO `box_site` VALUES (140, 15, 'jeshoots', 'a016e8d2ae3ee88f0ec136440e92fca8.png', 'New Free Photos & Mockups in to your Inbox!', 'http://jeshoots.com/', '2019-03-12 02:25:49', '2019-03-12 02:25:49');
INSERT INTO `box_site` VALUES (141, 15, 'hdwallpapers', '74db036ddf1bbfc49a22a5a6dcd392ab.png', 'High Definition Wallpapers & Desktop Backgrounds', 'https://www.hdwallpapers.net', '2019-03-12 02:26:19', '2019-03-12 02:26:19');
INSERT INTO `box_site` VALUES (142, 15, 'publicdomainarchive', '3c7427a4bab6bb40c12a77014f809a2a.png', 'New 100% Free Stock Photos. Every. Single. Week.', 'http://publicdomainarchive.com/', '2019-03-12 02:26:49', '2019-03-12 02:26:49');
INSERT INTO `box_site` VALUES (143, 16, 'OfficePLUS', '4773ef0cfcf8c9fd158fc7db0bc2cf0b.png', 'OfficePLUS，微软Office官方在线模板网站！', 'http://www.officeplus.cn/Template/Home.shtml', '2019-03-12 02:27:23', '2019-03-12 02:27:23');
INSERT INTO `box_site` VALUES (144, 16, '优品PPT', 'b1d803179735ea628d1d914c63c0b9f7.png', '高质量的模版，而且还有PPT图表，PPT背景图等资源', 'http://www.ypppt.com/', '2019-03-12 02:27:52', '2019-03-12 02:27:52');
INSERT INTO `box_site` VALUES (145, 16, 'PPT+', 'bfabed8750869b0214622d158ec9bddf.png', 'PPT加直播、录制和分享—PPT+语音内容分享平台', 'http://www.pptplus.cn/', '2019-03-12 02:28:22', '2019-03-12 02:28:22');
INSERT INTO `box_site` VALUES (146, 16, 'PPTMind', '857bb0f6927c2a8c246653cb41136ce7.png', '分享高端ppt模板与keynote模板的数字作品交易平台', 'http://www.pptmind.com/', '2019-03-12 02:28:53', '2019-03-12 02:28:53');
INSERT INTO `box_site` VALUES (147, 16, 'tretars', '14a77db5ab4af0ba947b1e1707295c5d.png', 'The best free Mockups from the Web', 'http://www.tretars.com/ppt-templates', '2019-03-12 02:29:21', '2019-03-12 02:29:21');
INSERT INTO `box_site` VALUES (148, 16, '5百丁', '3f735ae4b6e18cd6cff3965661289aac.png', '中国领先的PPT模板共享平台', 'http://ppt.500d.me/', '2019-03-12 02:29:51', '2019-03-12 02:29:51');
INSERT INTO `box_site` VALUES (149, 18, 'photoshop', 'e7117e80fdb340589bc8969900e2af61.png', 'Photoshop不需要解释', 'https://www.adobe.com/cn/products/photoshop.html', '2019-03-12 02:30:54', '2019-03-12 02:30:54');
INSERT INTO `box_site` VALUES (150, 18, 'Affinity Designer', '290add1cdb3cdb80e6e30af137d48525.png', '专业创意软件', 'https://affinity.serif.com/', '2019-03-12 02:32:06', '2019-03-12 02:32:06');
INSERT INTO `box_site` VALUES (151, 18, 'Illustrator', '6882fdb094820bae95054ea1c38a3baf.png', '矢量图形和插图。', 'https://www.adobe.com/cn/products/illustrator/', '2019-03-12 02:32:51', '2019-03-12 02:32:51');
INSERT INTO `box_site` VALUES (152, 18, 'indesign', '4db54894b6751e253212a690dada0df8.png', '页面设计、布局和出版。', 'http://www.adobe.com/cn/products/indesign.html', '2019-03-12 02:33:19', '2019-03-12 02:33:19');
INSERT INTO `box_site` VALUES (153, 18, 'cinema-4d', 'ac0344f03fc1e59b4144fef92a12e211.png', 'Cinema 4D is the perfect package for all 3D artists who want to achieve breathtaking results fast and hassle-free.', 'https://www.maxon.net/en/products/cinema-4d/overview/', '2019-03-12 02:34:04', '2019-03-12 02:34:04');
INSERT INTO `box_site` VALUES (154, 18, '3ds-max', '3aacac5d23583cdc250a970a0e30a9aa.png', '3D modeling, animation, and rendering software', 'https://www.autodesk.com/products/3ds-max/overview', '2019-03-12 02:34:39', '2019-03-12 02:34:39');
INSERT INTO `box_site` VALUES (155, 18, 'Blender', '5d61addac4350caee364f0a3e850a3f7.png', 'Blender is the free and open source 3D creation suite.', 'https://www.blender.org/', '2019-03-12 02:35:09', '2019-03-12 02:35:09');
INSERT INTO `box_site` VALUES (156, 19, 'Sketch', '75cc5b5775361d5f0b471b706a115403.png', 'The digital design toolkit', 'https://sketchapp.com/', '2019-03-12 02:35:55', '2019-03-12 02:35:55');
INSERT INTO `box_site` VALUES (157, 19, 'Adobe XD', '9eda46042e2ad058951fa4e4bb3a9957.png', 'Introducing Adobe XD. Design. Prototype. Experience.', 'http://www.adobe.com/products/xd.html', '2019-03-12 02:36:39', '2019-03-12 02:36:39');
INSERT INTO `box_site` VALUES (158, 19, 'invisionapp', '7d5620f1b4fd85c4a7ea4733deed8823.png', 'Powerful design prototyping tools', 'https://www.invisionapp.com/', '2019-03-12 02:37:36', '2019-03-12 02:37:36');
INSERT INTO `box_site` VALUES (159, 19, 'marvelapp', '28ec81158c67d9783afccf8fcd1bbee6.png', 'Simple design, prototyping and collaboration', 'https://marvelapp.com/', '2019-03-12 02:38:14', '2019-03-12 02:38:14');
INSERT INTO `box_site` VALUES (160, 19, 'Muse CC', '612cf530fe80b5f28dc826c4384087bf.png', '无需利用编码即可进行网站设计。', 'https://creative.adobe.com/zh-cn/products/download/muse', '2019-03-12 02:38:53', '2019-03-12 02:38:53');
INSERT INTO `box_site` VALUES (161, 19, 'figma', '0623aab0bc72437206deca9d4c55df1c.png', 'Design, prototype, and gather feedback all in one place with Figma.', 'https://www.figma.com/', '2019-03-12 02:39:20', '2019-03-12 02:39:20');
INSERT INTO `box_site` VALUES (162, 20, 'Adobe After Effects CC', '01306292e590f37b934785ed67288f80.png', '电影般的视觉效果和动态图形。', 'https://www.adobe.com/cn/products/aftereffects/', '2019-03-12 02:40:17', '2019-03-12 02:40:17');
INSERT INTO `box_site` VALUES (163, 20, 'principle', '485a410f2076ad20856199caa300f548.png', 'Animate Your Ideas, Design Better Apps', 'http://principleformac.com/', '2019-03-12 02:40:48', '2019-03-12 02:40:48');
INSERT INTO `box_site` VALUES (164, 20, 'flinto', 'f655d57c7d752c429510e0f649d69666.png', 'Flinto is a Mac app used by top designers around the world to create interactive and animated prototypes of their app designs.', 'https://www.flinto.com/', '2019-03-12 02:41:26', '2019-03-12 02:41:26');
INSERT INTO `box_site` VALUES (165, 20, 'framer', 'e64c3cd0283a3bf6a75c9c4ba821049d.png', 'Design everything from detailed icons to high-fidelity interactions—all in one place.', 'https://framer.com/', '2019-03-12 02:42:05', '2019-03-12 02:42:05');
INSERT INTO `box_site` VALUES (166, 20, 'ProtoPie', 'bdbb0e0485d816b88c75c9276d273873.png', '高保真交互原型设计', 'http://www.protopie.cn/', '2019-03-12 02:42:41', '2019-03-12 02:42:41');
INSERT INTO `box_site` VALUES (167, 21, 'khroma', '8b158c18b49f0160100086bfcdbe158d.png', 'Khroma is the fastest way to discover, search, and save color combos you\'ll want to use.', 'http://khroma.co/generator/', '2019-03-12 02:45:06', '2019-03-12 02:45:06');
INSERT INTO `box_site` VALUES (168, 21, 'uigradients', '9842ff5c221d6411444d3c13660ba097.png', 'Beautiful colored gradients', 'https://uigradients.com', '2019-03-12 02:45:49', '2019-03-12 02:45:49');
INSERT INTO `box_site` VALUES (169, 21, 'gradients', '64d0ac5dc78b65d83ba500df5b1eab30.png', 'Curated gradients for designers and developers', 'http://gradients.io/', '2019-03-12 02:46:19', '2019-03-12 02:46:19');
INSERT INTO `box_site` VALUES (170, 21, 'Coolest', '9b77eaad5ef27823b9feb3f765b9d593.png', 'Coolest handpicked Gradient Hues for your next super ⚡ amazing stuff', 'https://webkul.github.io/coolhue/', '2019-03-12 02:46:47', '2019-03-12 02:46:47');
INSERT INTO `box_site` VALUES (171, 21, 'webgradients', '49bfc25c217107d7209eea098ad0307c.png', 'WebGradients is a free collection of 180 linear gradients that you can use as content backdrops in any part of your website.', 'https://webgradients.com/', '2019-03-12 02:47:17', '2019-03-12 02:47:17');
INSERT INTO `box_site` VALUES (172, 21, 'grabient', '8ab1a1044ef9bc5c306c60b81d83b0a2.png', '2017 Grabient by unfold', 'https://www.grabient.com/', '2019-03-12 02:48:04', '2019-03-12 02:48:04');
INSERT INTO `box_site` VALUES (173, 21, 'thedayscolor', '6e63366cb896fa19e204cf6b95691062.png', 'The daily color digest', 'http://www.thedayscolor.com/', '2019-03-12 02:48:34', '2019-03-12 02:48:34');
INSERT INTO `box_site` VALUES (174, 21, 'flatuicolors', '0b6e14ae22ff962a96ad66de4fc86aff.png', 'Copy Paste Color Pallette from Flat UI Theme', 'http://flatuicolors.com/', '2019-03-12 02:49:25', '2019-03-12 02:49:25');
INSERT INTO `box_site` VALUES (175, 21, 'coolors', '9176968478c5c42ed20bce8b69f25bf6.png', 'The super fast color schemes generator!', 'https://coolors.co/', '2019-03-12 02:50:11', '2019-03-12 02:50:11');
INSERT INTO `box_site` VALUES (176, 0, 'colorhunt', '37cf035215ac7e51cc0064c207f298e1.png', 'Beautiful Color Palettes', 'http://www.colorhunt.co/', '2019-03-12 02:50:35', '2019-03-12 02:50:35');
INSERT INTO `box_site` VALUES (177, 21, 'Adobe Color CC', 'ff4d69bedb642bd132297ed22018369b.png', 'Create color schemes with the color wheel or browse thousands of color combinations from the Color community.', 'https://color.adobe.com/zh/create/color-wheel', '2019-03-12 02:51:03', '2019-03-12 02:51:03');
INSERT INTO `box_site` VALUES (178, 21, 'flatuicolorpicker', '2faf82318597d846e9522c5f52500031.png', 'Best Flat Colors For UI Design', 'http://www.flatuicolorpicker.com/', '2019-03-12 02:51:35', '2019-03-12 02:51:35');
INSERT INTO `box_site` VALUES (179, 21, 'trianglify', '88261a86b35e5b015bbe35ab9141bc8f.png', 'Trianglify Generator', 'http://qrohlf.com/trianglify-generator/', '2019-03-12 02:52:12', '2019-03-12 02:52:12');
INSERT INTO `box_site` VALUES (180, 21, 'klart', 'c51065aaec56c7c65aafd40f4797dba0.png', 'Beautiful colors and designs to your inbox every week', 'https://klart.co/colors/', '2019-03-12 02:52:40', '2019-03-12 02:52:40');
INSERT INTO `box_site` VALUES (181, 21, 'vanschneider', '4690e9281c23d5fc9df0e2cfbe018edd.png', 'Color Claim was created in 2012 by Tobias van Schneider with the goal to collect & combine unique colors for my future projects.', 'http://www.vanschneider.com/colors', '2019-03-12 02:53:23', '2019-03-12 02:53:23');
INSERT INTO `box_site` VALUES (182, 22, 'tinypng', '9344c4d9769745c1e63d8f1e7b2f3f25.png', 'Optimize your images with a perfect balance in quality and file size.', 'https://tinypng.com/', '2019-03-12 02:54:39', '2019-03-12 02:54:39');
INSERT INTO `box_site` VALUES (183, 0, 'goqr', 'c3abf8084a1699d9a2618e76a90d3935.png', 'create QR codes for free (Logo, T-Shirt, vCard, EPS)', 'http://goqr.me/', '2019-03-12 02:55:04', '2019-03-12 02:55:04');
INSERT INTO `box_site` VALUES (184, 22, 'Android 9 patch', 'dc5b75e3455673384a8f738429789d4b.png', 'Android 9-patch shadow generator fully customizable shadows', 'http://inloop.github.io/shadow4android/', '2019-03-12 02:55:38', '2019-03-12 02:55:38');
INSERT INTO `box_site` VALUES (185, 22, 'screen sizes', 'd79583290bc400c0e8a2629d0e7f9f63.png', 'Viewport Sizes and Pixel Densities for Popular Devices', 'http://screensiz.es/', '2019-03-12 02:56:06', '2019-03-12 02:56:06');
INSERT INTO `box_site` VALUES (186, 22, 'svgomg', 'f573dc81e4689cb9ce482f35a6fb82f1.png', 'SVG在线压缩平台', 'https://jakearchibald.github.io/svgomg/', '2019-03-12 02:56:37', '2019-03-12 02:56:37');
INSERT INTO `box_site` VALUES (187, 22, '稿定抠图', '0a6b1b1ea1d5ca5cb49e8cf95470a3b5.png', '免费在线抠图软件,图片快速换背景-抠白底图', 'https://www.gaoding.com', '2019-03-12 02:56:59', '2019-03-12 02:56:59');
INSERT INTO `box_site` VALUES (188, 23, 'wappalyzer', '60696fcbba523de88eca68121dee7be7.png', 'Identify technology on websites', 'https://www.wappalyzer.com/', '2019-03-12 02:58:27', '2019-03-12 02:58:27');
INSERT INTO `box_site` VALUES (189, 23, 'Panda', '35e1bbf29c1116cb1dbb703b52ea2ae9.png', 'A smart news reader built for productivity.', 'http://usepanda.com/', '2019-03-12 02:58:50', '2019-03-12 02:58:50');
INSERT INTO `box_site` VALUES (190, 23, 'sizzy', '5ca0b65bcc3606640ba1b4aadd25c7df.png', 'A tool for developing responsive websites crazy-fast', 'https://sizzy.co/', '2019-03-12 02:59:17', '2019-03-12 02:59:17');
INSERT INTO `box_site` VALUES (191, 23, 'csspeeper', '84fedbd61bf8c93726b713bae36a88ae.png', 'Smart CSS viewer tailored for Designers.', 'https://csspeeper.com/', '2019-03-12 02:59:48', '2019-03-12 02:59:48');
INSERT INTO `box_site` VALUES (192, 23, 'insight', 'fc5a318293079a2674f1d92f3dce7650.png', 'IDE-like code search and navigation, on the cloud', 'http://insight.io/', '2019-03-12 03:00:22', '2019-03-12 03:00:22');
INSERT INTO `box_site` VALUES (193, 23, 'mustsee', '709ff744a41559fa06b8e8dc199206a3.png', 'Discover the world\'s most beautiful places at every opened tab.', 'http://mustsee.earth/', '2019-03-12 03:00:50', '2019-03-12 03:00:50');
INSERT INTO `box_site` VALUES (194, 25, 'Design Guidelines', 'cd3c32252bb659437d63d59ca6fec8fb.png', 'Design Guidelines — The way products are built.', 'http://designguidelines.co/', '2019-03-12 03:01:29', '2019-03-12 03:01:29');
INSERT INTO `box_site` VALUES (195, 25, 'Awesome design systems', '3adfef3862ba2083e737bbb0c9b734c1.png', 'A collection of awesome design systems', 'https://github.com/alexpate/awesome-design-systems', '2019-03-12 03:01:55', '2019-03-12 03:01:55');
INSERT INTO `box_site` VALUES (196, 25, 'Material Design', '34061dd29655cfb0781381568b26b1d6.png', 'Introduction - Material Design', 'https://material.io/guidelines/', '2019-03-12 03:02:28', '2019-03-12 03:02:28');
INSERT INTO `box_site` VALUES (197, 25, 'Human Interface Guidelines', '4fa8f4924f62370774915faf0fbc476d.png', 'Human Interface Guidelines iOS', 'https://developer.apple.com/ios/human-interface-guidelines', '2019-03-12 03:02:57', '2019-03-12 03:02:57');
INSERT INTO `box_site` VALUES (198, 25, 'Photoshop Etiquette', '9d6924419746baef1dcc5c203a321e6d.png', 'PS礼仪-WEB设计指南', 'http://viggoz.com/photoshopetiquette/', '2019-03-12 03:03:33', '2019-03-12 03:03:33');
INSERT INTO `box_site` VALUES (199, 26, 'Photoshop Lady', '975585f8d4d7efa6646b50dbc860cf5a.png', 'Your Favourite Photoshop Tutorials in One Place', 'http://www.photoshoplady.com/', '2019-03-12 03:04:09', '2019-03-12 03:04:09');
INSERT INTO `box_site` VALUES (200, 26, 'doyoudo', 'd810229b8e5bc36d3ac498fe4ee5ebee.png', '创意设计软件学习平台', 'http://doyoudo.com/', '2019-03-12 03:04:38', '2019-03-12 03:04:38');
INSERT INTO `box_site` VALUES (201, 26, '没位道', '1bb8a33edda0aaf2871ba17e6b265cf9.png', 'WEB UI免费视频公开课', 'http://www.c945.com/web-ui-tutorial/', '2019-03-12 03:05:04', '2019-03-12 03:05:04');
INSERT INTO `box_site` VALUES (202, 26, '慕课网', '806fbd13251a921287ec2a3e815eafc8.png', '程序员的梦工厂（有UI课程）', 'https://www.imooc.com/', '2019-03-12 03:05:29', '2019-03-12 03:05:29');
INSERT INTO `box_site` VALUES (203, 27, '优设网', '03508090a91cb0380760bb568054f31b.png', '设计师交流学习平台', 'http://www.uisdc.com/', '2019-03-12 03:06:02', '2019-03-12 03:06:02');
INSERT INTO `box_site` VALUES (204, 27, 'Web Design Ledger', '29345c700e66d707075758c51421b718.png', 'Web Design Blog', 'https://webdesignledger.com', '2019-03-12 03:06:28', '2019-03-12 03:06:28');
INSERT INTO `box_site` VALUES (205, 27, 'Medium', 'f9d1866ec8568b6a7744936842d773ac.png', 'Read, write and share stories that matter', 'https://medium.com/', '2019-03-12 03:06:57', '2019-03-12 03:06:57');
INSERT INTO `box_site` VALUES (206, 28, 'UX Coffee', 'c9aae7e06ebabe9549d78c8b0cd0757d.png', '《UX Coffee 设计咖》是一档关于用户体验的播客节目。我们邀请来自硅谷和国内的学者和职人来聊聊「产品设计」、「用户体验」和「个人成长」。', 'http://uxcoffee.co/', '2019-03-12 03:08:40', '2019-03-12 03:08:40');
INSERT INTO `box_site` VALUES (207, 28, 'Anyway.FM', '7fe5dade254de0528e78ce32736ff9f4.png', '设计杂谈 • UI 设计师 JJ 和 Leon 主播的设计播客', 'https://anyway.fm/', '2019-03-12 03:09:19', '2019-03-12 03:09:19');
INSERT INTO `box_site` VALUES (208, 28, '异能电台', 'c8e819279d4110794e2588dfb1a4bd64.png', '将全宇宙设计师的故事讲给你听。', 'https://www.yineng.fm', '2019-03-12 03:09:52', '2019-03-12 03:09:52');
INSERT INTO `box_site` VALUES (237, 35, '小毛驴在线音乐', 'a9a5f02e-f2a8-4b48-8d26-9e1979bb4abf.jpg', '在线播放音乐，集成各大主流音乐播放器资源！', 'http://music.zywhs.club/', '2019-12-18 11:58:22', '2019-12-18 11:59:49');
INSERT INTO `box_site` VALUES (238, 35, '小毛驴在线视频', 'cee4aab9-d7ba-4247-a266-be1e34e469e8.jpg', '在线视频，直播播放，集成各大主流视频播放器资源！（庆余年有全集！速度简直太快啦）', 'http://video.zywhs.club/', '2019-12-18 12:01:29', '2019-12-21 17:32:53');
INSERT INTO `box_site` VALUES (240, 36, 'Bing', '5aae5f1d-d75c-4212-b836-32987efa3342.png', '微软Bing搜索是国际领先的搜索引擎,为中国用户提供网页、图片、视频、学术、词典、翻译、地图等全球信息搜索服务。', 'https://www.bing.com', '2019-12-19 10:15:52', '2019-12-19 10:17:36');
INSERT INTO `box_site` VALUES (241, 36, 'DuckDuckGo', '5539a36f-9137-424f-9172-5e25b44a82d2.png', 'DuckDuckGo是一个互联网搜寻引擎，其总部位于美国宾州Valley Forge市。', 'http://www.duckduckgoog.com/', '2019-12-19 10:19:27', NULL);
INSERT INTO `box_site` VALUES (242, 36, 'Wikipedia', '86e59930-4a93-4d1c-9aa1-ef5214c87df2.png', '维基百科（Wikipedia），是一个基于维基技术的多语言百科全书协作计划，用多种语言编写的网络百科全书。', 'https://en.wikipedia.org/wiki/Main_Page', '2019-12-19 10:20:54', '2019-12-19 10:22:24');
INSERT INTO `box_site` VALUES (243, 2, 'Twitter', '6684fa33-715b-4483-8f63-c24e81b614e7.png', 'Twitter（通称推特）是一家美国社交网络及微博客服务的网站，是全球互联网上访问量最大的十个网站之一。', 'https://twitter.com/', '2019-12-19 10:24:06', '2019-12-19 10:25:56');
INSERT INTO `box_site` VALUES (244, 2, 'Facebook', '7fc582ed-6cd0-40fe-87fa-133621d0840b.png', 'Facebook（中文译为脸书或者脸谱网）是美国的一个社交网络服务网站 ，创立于2004年2月4日，总部位于美国加利福尼亚州门洛帕克。  ', 'https://www.facebook.com', '2019-12-19 10:43:52', '2019-12-19 11:04:14');
INSERT INTO `box_site` VALUES (245, 37, 'Steam', '9b2acfe6-1823-450f-b296-3b86dd90b783.png', '蒸汽，蒸汽，欧里给！', 'https://store.steampowered.com/', '2019-12-19 10:46:58', '2019-12-19 11:03:24');
INSERT INTO `box_site` VALUES (246, 2, 'Reddit', 'c05d87f0-c35e-4245-809e-10f6d2a7c79b.png', 'Reddit是个社交新闻站点，口号：提前于新闻发声，来自互联网的声音。其拥有者是Condé Nast Digital公司（Advance Magazine Publishers Inc的子公司）。', 'https://www.reddit.com/', '2019-12-19 10:49:04', '2019-12-19 11:04:55');
INSERT INTO `box_site` VALUES (247, 2, 'Tumblr', 'f4774642-c31b-4e00-8420-d1e612bfc7cb.png', 'Tumblr（/ˈtʌmblər/，中文名：汤博乐）成立于2007年，是目前全球最大的轻博客网站，也是轻博客网站的始祖。', 'https://www.tumblr.com/', '2019-12-19 10:50:54', '2019-12-19 11:05:15');
INSERT INTO `box_site` VALUES (248, 2, 'Instagram', '90e48e52-8ef0-4878-ba56-ed483db7acf4.png', 'Instagram（照片墙）是一款运行在移动端上的社交应用，以一种快速、美妙和有趣的方式将你随时抓拍下的图片彼此分享。', 'https://www.instagram.com/', '2019-12-19 10:51:51', '2019-12-19 11:03:59');
INSERT INTO `box_site` VALUES (249, 1, '中国知网', 'b3843f8b-0570-4597-85a7-90ee1d16cd1b.png', '中国知网知识发现网络平台—面向海内外读者提供中国学术文献、外文文献、学位论文、报纸、会议、年鉴、工具书等各类资源统一检索、统一导航、在线阅读和下载服务。', 'https://www.cnki.net/', '2019-12-19 11:02:02', NULL);
INSERT INTO `box_site` VALUES (250, 38, '掘金', '8f496727-f9ad-4836-bcf8-bad7b6a8eb24.png', '掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。', 'https://juejin.im/', '2019-12-19 11:16:44', NULL);
INSERT INTO `box_site` VALUES (251, 38, 'CSDN', '1543976f-ae00-40a7-ba31-abc38bdbe16f.png', 'CSDN是全球知名中文IT技术交流平台,创建于1999年,包含原创博客、精品问答、职业培训、技术论坛、资源下载等产品服务,提供原创、优质、完整内容的专业IT技术开发社区', 'https://www.csdn.net/', '2019-12-19 11:17:51', NULL);
INSERT INTO `box_site` VALUES (252, 38, '博客园', 'abd15ba0-c80a-4862-a240-10780447b3dd.png', '博客园是一个面向开发者的知识分享社区。自创建以来,博客园一直致力并专注于为开发者打造一个纯净的技术交流社区,推动并帮助开发者通过互联网分享知识', 'https://www.cnblogs.com/', '2019-12-19 11:22:28', NULL);
INSERT INTO `box_site` VALUES (253, 1, '蚂蚁加速器', 'ecaf50d6-da10-40b0-97d1-052f9d7696db.png', '很好用的免费加速器', 'https://d.antss049.xyz/aff/7Nc5', '2019-12-19 14:32:19', NULL);
INSERT INTO `box_site` VALUES (255, 1, '小青豆影视', '5ec99a87-8e59-4c9d-9f9c-cd29effd06d3.png', '电影在线播放,电影在线观看,小青豆影视（庆余年全集！）', 'http://www.bbc334.com/index.php/user/visit.html?uid=2', '2019-12-19 16:39:22', '2019-12-20 10:00:11');
INSERT INTO `box_site` VALUES (257, 38, 'GitHub', 'd8cd44df-2c92-4c7e-9ad9-8b90bc2cd452.png', 'GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。', 'https://github.com/', '2019-12-19 21:21:27', NULL);
INSERT INTO `box_site` VALUES (258, 39, '友盟', 'fe9e1aed-9fe2-4b5c-abca-864b4f133291.png', '友盟+,国内领先的第三方全域数据智能服务商。专注为互联网企业提供一站式数据分析运营服务近10年。', 'https://www.umeng.com/', '2019-12-19 21:55:09', NULL);
INSERT INTO `box_site` VALUES (259, 39, '百度统计', '26126464-6a00-4651-9b36-f93a3cf12996.png', '百度移动统计是一款专业免费的移动应用统计分析工具,支持android,ios平台。', 'https://tongji.baidu.com/web/welcome/basic', '2019-12-19 21:57:19', '2019-12-19 23:21:10');
INSERT INTO `box_site` VALUES (261, 35, '站长的个人博客', 'd5cb0f9e-e4b6-45ec-bbdb-ad8b18596c4c.png', '这是站长的个人博客。来玩哦', 'http://blogs.zywhs.club/', '2019-12-20 15:51:09', NULL);
INSERT INTO `box_site` VALUES (262, 38, '码云', 'dd05d146-f536-4da8-9d98-b9e5b2e6c626.png', '码云& #40;gitee.com& #41;是 OSCHINA.NET 推出的代码托管平台,支持 Git 和 SVN,提供免费的私有仓库托管。', 'https://gitee.com/', '2019-12-20 17:06:05', '2019-12-20 17:09:45');
INSERT INTO `box_site` VALUES (263, 1, 'windows系统', '3c5aa6eb-e952-401d-b4be-f3e956203f9b.jpg', '正版win10下载地址', 'https://www.microsoft.com/zh-cn/software-download/windows10', '2019-12-20 18:08:29', NULL);
INSERT INTO `box_site` VALUES (264, 40, 'QQ邮箱', '60da1720-8a75-471f-862d-d903a4fa9c43.jpg', 'QQ邮箱登录入口', 'https://mail.qq.com/', '2019-12-20 19:38:56', NULL);
INSERT INTO `box_site` VALUES (265, 40, '网易邮箱', '246a83d5-eb77-4837-a944-7899cb327a28.jpg', '网易邮箱163登录入口', 'https://mail.163.com/', '2019-12-20 19:40:55', '2019-12-20 19:53:07');
INSERT INTO `box_site` VALUES (266, 40, '网易邮箱', '012c0357-3ce8-4912-b766-053c12ecc008.jpg', '网易邮箱126登录入口', 'https://mail.126.com/', '2019-12-20 19:51:31', NULL);
INSERT INTO `box_site` VALUES (267, 40, '中国移动139邮箱', 'b58b2846-7370-4053-9c85-260d1daadae9.jpg', '中国移动139邮箱登录入口', 'http://html5.mail.10086.cn/pad/pad_login.html', '2019-12-20 19:55:52', NULL);
INSERT INTO `box_site` VALUES (268, 40, 'outlook邮箱', 'e746060e-6ee0-4c49-9496-a82d737e65e5.png', 'outlook邮箱登录及注册入口', 'https://outlook.live.com/owa/', '2019-12-20 19:59:57', NULL);
INSERT INTO `box_site` VALUES (269, 36, '磁力搜索', '416e2dcb-81f8-4fd0-bcaf-b6131d68727e.png', '磁力搜索', 'http://cilisou8.com/', '2019-12-22 14:01:00', NULL);

-- ----------------------------
-- Table structure for sys_permission
-- ----------------------------
DROP TABLE IF EXISTS `sys_permission`;
CREATE TABLE `sys_permission`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `url` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `icon` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `parent_id` int(0) DEFAULT 0,
  `checked` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `open` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `isleaf` int(0) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1245 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_permission
-- ----------------------------
INSERT INTO `sys_permission` VALUES (5, '系统设置', '/admin/sysManager', 'icon-kongzhitai', '系统设置', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (7, '博客管理', '/admin/article', 'icon-wenzhangguanli', '博客管理', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (1, '仪表盘', '/admin/index', 'icon-ziyuan', '仪表盘', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (3, '角色管理', '/admin/role', 'icon-jiaoseguanli', '角色管理', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (2, '用户管理', '/admin/user', 'icon-yonghuguanli', '用户管理', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (8, '分类管理', '/admin/categories', 'icon-fenleiguanli', '分类管理', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (12, '博客修改页面', 'article/toUpdate', '', '', 7, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (13, '标签新增', '/admin/tags/add', '', '', 9, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (6, '发布博客', '/admin/editor', 'icon-bianji', '发布博客', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (10, '评论管理', '/admin/comment', 'icon-pinglunguanli', '评论管理', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (9, '标签管理', '/admin/tags', 'icon-biaoqianguanli', '标签管理', 0, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (11, '保存博客', '/article/save', NULL, '保存博客', 7, NULL, NULL, NULL);
INSERT INTO `sys_permission` VALUES (4, '权限管理', '/admin/permission', 'icon-quanxianguanli1', '权限管理', 0, NULL, NULL, NULL);

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` int(0) NOT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `role_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (0, '博客管理员', '管理员', 'administrator');
INSERT INTO `sys_role` VALUES (1, '博主', '博主', 'bloger');
INSERT INTO `sys_role` VALUES (2, '访客', '访客', 'visitor');

-- ----------------------------
-- Table structure for sys_role_permission
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_permission`;
CREATE TABLE `sys_role_permission`  (
  `role_id` int(0) NOT NULL,
  `permission_id` int(0) NOT NULL,
  INDEX `FK9q28ewrhntqeipl1t04kh1be7`(`role_id`) USING BTREE,
  INDEX `UK_8n7kjpptsuop8jvkeh4ls34ct`(`permission_id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Fixed;

-- ----------------------------
-- Records of sys_role_permission
-- ----------------------------
INSERT INTO `sys_role_permission` VALUES (1, 10);
INSERT INTO `sys_role_permission` VALUES (1, 13);
INSERT INTO `sys_role_permission` VALUES (1, 9);
INSERT INTO `sys_role_permission` VALUES (1, 8);
INSERT INTO `sys_role_permission` VALUES (1, 12);
INSERT INTO `sys_role_permission` VALUES (1, 11);
INSERT INTO `sys_role_permission` VALUES (1, 7);
INSERT INTO `sys_role_permission` VALUES (1, 6);
INSERT INTO `sys_role_permission` VALUES (1, 1);
INSERT INTO `sys_role_permission` VALUES (0, 5);
INSERT INTO `sys_role_permission` VALUES (0, 4);
INSERT INTO `sys_role_permission` VALUES (0, 3);
INSERT INTO `sys_role_permission` VALUES (0, 2);
INSERT INTO `sys_role_permission` VALUES (0, 1);

-- ----------------------------
-- Table structure for sys_sequence
-- ----------------------------
DROP TABLE IF EXISTS `sys_sequence`;
CREATE TABLE `sys_sequence`  (
  `NAME` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `CURRENT_VALUE` int(0) NOT NULL DEFAULT 0,
  `INCREMENT` int(0) NOT NULL DEFAULT 1,
  PRIMARY KEY (`NAME`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of sys_sequence
-- ----------------------------
INSERT INTO `sys_sequence` VALUES ('TBL_FS', 207, 1);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `password` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `avatar` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `address` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `phone_num` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `birthday` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `email` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `gender` int(0) DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `salt` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 112 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (0, 'admin', '8e829e26e6040049b4d97ac5ff126943', '管理员', '/upload/1.jpg', '地球村', '18232153202', '2019-05-01', '1130467636@qq.com', 1, '管理员', 's4f8p5wwcp4l64ju8q');
INSERT INTO `sys_user` VALUES (2, 'jingjing', '66a9cbe78b874b71fc61594302726223', '宋静静', '/upload/1.jpg', NULL, '', NULL, 'songjingjing19@sina.com', 0, '博主媳妇', 'ddlu8w6ii079ylqr');
INSERT INTO `sys_user` VALUES (1, 'wangmx', '8e829e26e6040049b4d97ac5ff126943', '王明晓', '/images/avatar/avatar.jpg', '河北省石家庄市桥西区', '17332997682', '1991-04-08', '1130467636@qq.com', 1, '123', 's4f8p5wwcp4l64ju8q');

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `role_id` int(0) DEFAULT NULL,
  `user_id` int(0) NOT NULL,
  PRIMARY KEY (`user_id`) USING BTREE,
  INDEX `FKhh52n8vd4ny9ff4x9fb8v65qx`(`role_id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Fixed;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (2, 2);
INSERT INTO `sys_user_role` VALUES (0, 0);
INSERT INTO `sys_user_role` VALUES (1, 1);

-- ----------------------------
-- Function structure for currval
-- ----------------------------
DROP FUNCTION IF EXISTS `currval`;
delimiter ;;
CREATE DEFINER=`root`@`%` FUNCTION `currval`(seq_name VARCHAR(50)) RETURNS int
BEGIN
DECLARE VALUE INTEGER;
SET VALUE=0;
SELECT current_value INTO VALUE
FROM sys_sequence 
WHERE NAME=seq_name;
RETURN VALUE;
END
;;
delimiter ;

-- ----------------------------
-- Function structure for nextval
-- ----------------------------
DROP FUNCTION IF EXISTS `nextval`;
delimiter ;;
CREATE DEFINER=`root`@`%` FUNCTION `nextval`(seq_name varchar(50)) RETURNS int
BEGIN
UPDATE sys_sequence
SET CURRENT_VALUE = CURRENT_VALUE + INCREMENT
where name=seq_name;
return currval(seq_name);
END
;;
delimiter ;

SET FOREIGN_KEY_CHECKS = 1;
